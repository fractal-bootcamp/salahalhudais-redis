/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/engine.io";
exports.ids = ["vendor-chunks/engine.io"];
exports.modules = {

/***/ "(rsc)/../node_modules/engine.io/build/engine.io.js":
/*!****************************************************!*\
  !*** ../node_modules/engine.io/build/engine.io.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.protocol = exports.Transport = exports.Socket = exports.uServer = exports.parser = exports.transports = exports.Server = void 0;\nexports.listen = listen;\nexports.attach = attach;\nconst http_1 = __webpack_require__(/*! http */ \"http\");\nconst server_1 = __webpack_require__(/*! ./server */ \"(rsc)/../node_modules/engine.io/build/server.js\");\nObject.defineProperty(exports, \"Server\", ({ enumerable: true, get: function () { return server_1.Server; } }));\nconst index_1 = __webpack_require__(/*! ./transports/index */ \"(rsc)/../node_modules/engine.io/build/transports/index.js\");\nexports.transports = index_1.default;\nconst parser = __webpack_require__(/*! engine.io-parser */ \"(rsc)/../node_modules/engine.io-parser/build/cjs/index.js\");\nexports.parser = parser;\nvar userver_1 = __webpack_require__(/*! ./userver */ \"(rsc)/../node_modules/engine.io/build/userver.js\");\nObject.defineProperty(exports, \"uServer\", ({ enumerable: true, get: function () { return userver_1.uServer; } }));\nvar socket_1 = __webpack_require__(/*! ./socket */ \"(rsc)/../node_modules/engine.io/build/socket.js\");\nObject.defineProperty(exports, \"Socket\", ({ enumerable: true, get: function () { return socket_1.Socket; } }));\nvar transport_1 = __webpack_require__(/*! ./transport */ \"(rsc)/../node_modules/engine.io/build/transport.js\");\nObject.defineProperty(exports, \"Transport\", ({ enumerable: true, get: function () { return transport_1.Transport; } }));\nexports.protocol = parser.protocol;\n/**\n * Creates an http.Server exclusively used for WS upgrades.\n *\n * @param {Number} port\n * @param {Function} callback\n * @param {Object} options\n * @return {Server} websocket.io server\n */\nfunction listen(port, options, fn) {\n    if (\"function\" === typeof options) {\n        fn = options;\n        options = {};\n    }\n    const server = (0, http_1.createServer)(function (req, res) {\n        res.writeHead(501);\n        res.end(\"Not Implemented\");\n    });\n    // create engine server\n    const engine = attach(server, options);\n    engine.httpServer = server;\n    server.listen(port, fn);\n    return engine;\n}\n/**\n * Captures upgrade requests for a http.Server.\n *\n * @param {http.Server} server\n * @param {Object} options\n * @return {Server} engine server\n */\nfunction attach(server, options) {\n    const engine = new server_1.Server(options);\n    engine.attach(server, options);\n    return engine;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC9lbmdpbmUuaW8uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLEdBQUcsaUJBQWlCLEdBQUcsY0FBYyxHQUFHLGVBQWUsR0FBRyxjQUFjLEdBQUcsa0JBQWtCLEdBQUcsY0FBYztBQUM5SCxjQUFjO0FBQ2QsY0FBYztBQUNkLGVBQWUsbUJBQU8sQ0FBQyxrQkFBTTtBQUM3QixpQkFBaUIsbUJBQU8sQ0FBQyxpRUFBVTtBQUNuQywwQ0FBeUMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDNUcsZ0JBQWdCLG1CQUFPLENBQUMscUZBQW9CO0FBQzVDLGtCQUFrQjtBQUNsQixlQUFlLG1CQUFPLENBQUMsbUZBQWtCO0FBQ3pDLGNBQWM7QUFDZCxnQkFBZ0IsbUJBQU8sQ0FBQyxtRUFBVztBQUNuQywyQ0FBMEMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDL0csZUFBZSxtQkFBTyxDQUFDLGlFQUFVO0FBQ2pDLDBDQUF5QyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUM1RyxrQkFBa0IsbUJBQU8sQ0FBQyx1RUFBYTtBQUN2Qyw2Q0FBNEMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDckgsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2FsL3JlZGlzLXByb2plY3Qvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC9lbmdpbmUuaW8uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnByb3RvY29sID0gZXhwb3J0cy5UcmFuc3BvcnQgPSBleHBvcnRzLlNvY2tldCA9IGV4cG9ydHMudVNlcnZlciA9IGV4cG9ydHMucGFyc2VyID0gZXhwb3J0cy50cmFuc3BvcnRzID0gZXhwb3J0cy5TZXJ2ZXIgPSB2b2lkIDA7XG5leHBvcnRzLmxpc3RlbiA9IGxpc3RlbjtcbmV4cG9ydHMuYXR0YWNoID0gYXR0YWNoO1xuY29uc3QgaHR0cF8xID0gcmVxdWlyZShcImh0dHBcIik7XG5jb25zdCBzZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuL3NlcnZlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlcnZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VydmVyXzEuU2VydmVyOyB9IH0pO1xuY29uc3QgaW5kZXhfMSA9IHJlcXVpcmUoXCIuL3RyYW5zcG9ydHMvaW5kZXhcIik7XG5leHBvcnRzLnRyYW5zcG9ydHMgPSBpbmRleF8xLmRlZmF1bHQ7XG5jb25zdCBwYXJzZXIgPSByZXF1aXJlKFwiZW5naW5lLmlvLXBhcnNlclwiKTtcbmV4cG9ydHMucGFyc2VyID0gcGFyc2VyO1xudmFyIHVzZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuL3VzZXJ2ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1U2VydmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1c2VydmVyXzEudVNlcnZlcjsgfSB9KTtcbnZhciBzb2NrZXRfMSA9IHJlcXVpcmUoXCIuL3NvY2tldFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNvY2tldFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc29ja2V0XzEuU29ja2V0OyB9IH0pO1xudmFyIHRyYW5zcG9ydF8xID0gcmVxdWlyZShcIi4vdHJhbnNwb3J0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhbnNwb3J0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cmFuc3BvcnRfMS5UcmFuc3BvcnQ7IH0gfSk7XG5leHBvcnRzLnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sO1xuLyoqXG4gKiBDcmVhdGVzIGFuIGh0dHAuU2VydmVyIGV4Y2x1c2l2ZWx5IHVzZWQgZm9yIFdTIHVwZ3JhZGVzLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBwb3J0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1NlcnZlcn0gd2Vic29ja2V0LmlvIHNlcnZlclxuICovXG5mdW5jdGlvbiBsaXN0ZW4ocG9ydCwgb3B0aW9ucywgZm4pIHtcbiAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygb3B0aW9ucykge1xuICAgICAgICBmbiA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgY29uc3Qgc2VydmVyID0gKDAsIGh0dHBfMS5jcmVhdGVTZXJ2ZXIpKGZ1bmN0aW9uIChyZXEsIHJlcykge1xuICAgICAgICByZXMud3JpdGVIZWFkKDUwMSk7XG4gICAgICAgIHJlcy5lbmQoXCJOb3QgSW1wbGVtZW50ZWRcIik7XG4gICAgfSk7XG4gICAgLy8gY3JlYXRlIGVuZ2luZSBzZXJ2ZXJcbiAgICBjb25zdCBlbmdpbmUgPSBhdHRhY2goc2VydmVyLCBvcHRpb25zKTtcbiAgICBlbmdpbmUuaHR0cFNlcnZlciA9IHNlcnZlcjtcbiAgICBzZXJ2ZXIubGlzdGVuKHBvcnQsIGZuKTtcbiAgICByZXR1cm4gZW5naW5lO1xufVxuLyoqXG4gKiBDYXB0dXJlcyB1cGdyYWRlIHJlcXVlc3RzIGZvciBhIGh0dHAuU2VydmVyLlxuICpcbiAqIEBwYXJhbSB7aHR0cC5TZXJ2ZXJ9IHNlcnZlclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1NlcnZlcn0gZW5naW5lIHNlcnZlclxuICovXG5mdW5jdGlvbiBhdHRhY2goc2VydmVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZW5naW5lID0gbmV3IHNlcnZlcl8xLlNlcnZlcihvcHRpb25zKTtcbiAgICBlbmdpbmUuYXR0YWNoKHNlcnZlciwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGVuZ2luZTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/engine.io/build/engine.io.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/engine.io/build/parser-v3/index.js":
/*!**********************************************************!*\
  !*** ../node_modules/engine.io/build/parser-v3/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// imported from https://github.com/socketio/engine.io-parser/tree/2.2.x\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.packets = exports.protocol = void 0;\nexports.encodePacket = encodePacket;\nexports.encodeBase64Packet = encodeBase64Packet;\nexports.decodePacket = decodePacket;\nexports.decodeBase64Packet = decodeBase64Packet;\nexports.encodePayload = encodePayload;\nexports.decodePayload = decodePayload;\nexports.encodePayloadAsBinary = encodePayloadAsBinary;\nexports.decodePayloadAsBinary = decodePayloadAsBinary;\n/**\n * Module dependencies.\n */\nvar utf8 = __webpack_require__(/*! ./utf8 */ \"(rsc)/../node_modules/engine.io/build/parser-v3/utf8.js\");\n/**\n * Current protocol version.\n */\nexports.protocol = 3;\nconst hasBinary = (packets) => {\n    for (const packet of packets) {\n        if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) {\n            return true;\n        }\n    }\n    return false;\n};\n/**\n * Packet types.\n */\nexports.packets = {\n    open: 0 // non-ws\n    ,\n    close: 1 // non-ws\n    ,\n    ping: 2,\n    pong: 3,\n    message: 4,\n    upgrade: 5,\n    noop: 6\n};\nvar packetslist = Object.keys(exports.packets);\n/**\n * Premade error packet.\n */\nvar err = { type: 'error', data: 'parser error' };\nconst EMPTY_BUFFER = Buffer.concat([]);\n/**\n * Encodes a packet.\n *\n *     <packet type id> [ <data> ]\n *\n * Example:\n *\n *     5hello world\n *     3\n *     4\n *\n * Binary is encoded in an identical principle\n *\n * @api private\n */\nfunction encodePacket(packet, supportsBinary, utf8encode, callback) {\n    if (typeof supportsBinary === 'function') {\n        callback = supportsBinary;\n        supportsBinary = null;\n    }\n    if (typeof utf8encode === 'function') {\n        callback = utf8encode;\n        utf8encode = null;\n    }\n    if (Buffer.isBuffer(packet.data)) {\n        return encodeBuffer(packet, supportsBinary, callback);\n    }\n    else if (packet.data && (packet.data.buffer || packet.data) instanceof ArrayBuffer) {\n        return encodeBuffer({ type: packet.type, data: arrayBufferToBuffer(packet.data) }, supportsBinary, callback);\n    }\n    // Sending data as a utf-8 string\n    var encoded = exports.packets[packet.type];\n    // data fragment is optional\n    if (undefined !== packet.data) {\n        encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);\n    }\n    return callback('' + encoded);\n}\n;\n/**\n * Encode Buffer data\n */\nfunction encodeBuffer(packet, supportsBinary, callback) {\n    if (!supportsBinary) {\n        return encodeBase64Packet(packet, callback);\n    }\n    var data = packet.data;\n    var typeBuffer = Buffer.allocUnsafe(1);\n    typeBuffer[0] = exports.packets[packet.type];\n    return callback(Buffer.concat([typeBuffer, data]));\n}\n/**\n * Encodes a packet with binary data in a base64 string\n *\n * @param {Object} packet, has `type` and `data`\n * @return {String} base64 encoded message\n */\nfunction encodeBase64Packet(packet, callback) {\n    var data = Buffer.isBuffer(packet.data) ? packet.data : arrayBufferToBuffer(packet.data);\n    var message = 'b' + exports.packets[packet.type];\n    message += data.toString('base64');\n    return callback(message);\n}\n;\n/**\n * Decodes a packet. Data also available as an ArrayBuffer if requested.\n *\n * @return {Object} with `type` and `data` (if any)\n * @api private\n */\nfunction decodePacket(data, binaryType, utf8decode) {\n    if (data === undefined) {\n        return err;\n    }\n    var type;\n    // String data\n    if (typeof data === 'string') {\n        type = data.charAt(0);\n        if (type === 'b') {\n            return decodeBase64Packet(data.slice(1), binaryType);\n        }\n        if (utf8decode) {\n            data = tryDecode(data);\n            if (data === false) {\n                return err;\n            }\n        }\n        if (Number(type) != type || !packetslist[type]) {\n            return err;\n        }\n        if (data.length > 1) {\n            return { type: packetslist[type], data: data.slice(1) };\n        }\n        else {\n            return { type: packetslist[type] };\n        }\n    }\n    // Binary data\n    if (binaryType === 'arraybuffer') {\n        // wrap Buffer/ArrayBuffer data into an Uint8Array\n        var intArray = new Uint8Array(data);\n        type = intArray[0];\n        return { type: packetslist[type], data: intArray.buffer.slice(1) };\n    }\n    if (data instanceof ArrayBuffer) {\n        data = arrayBufferToBuffer(data);\n    }\n    type = data[0];\n    return { type: packetslist[type], data: data.slice(1) };\n}\n;\nfunction tryDecode(data) {\n    try {\n        data = utf8.decode(data, { strict: false });\n    }\n    catch (e) {\n        return false;\n    }\n    return data;\n}\n/**\n * Decodes a packet encoded in a base64 string.\n *\n * @param {String} base64 encoded message\n * @return {Object} with `type` and `data` (if any)\n */\nfunction decodeBase64Packet(msg, binaryType) {\n    var type = packetslist[msg.charAt(0)];\n    var data = Buffer.from(msg.slice(1), 'base64');\n    if (binaryType === 'arraybuffer') {\n        var abv = new Uint8Array(data.length);\n        for (var i = 0; i < abv.length; i++) {\n            abv[i] = data[i];\n        }\n        // @ts-ignore\n        data = abv.buffer;\n    }\n    return { type: type, data: data };\n}\n;\n/**\n * Encodes multiple messages (payload).\n *\n *     <length>:data\n *\n * Example:\n *\n *     11:hello world2:hi\n *\n * If any contents are binary, they will be encoded as base64 strings. Base64\n * encoded strings are marked with a b before the length specifier\n *\n * @param {Array} packets\n * @api private\n */\nfunction encodePayload(packets, supportsBinary, callback) {\n    if (typeof supportsBinary === 'function') {\n        callback = supportsBinary;\n        supportsBinary = null;\n    }\n    if (supportsBinary && hasBinary(packets)) {\n        return encodePayloadAsBinary(packets, callback);\n    }\n    if (!packets.length) {\n        return callback('0:');\n    }\n    function encodeOne(packet, doneCallback) {\n        encodePacket(packet, supportsBinary, false, function (message) {\n            doneCallback(null, setLengthHeader(message));\n        });\n    }\n    map(packets, encodeOne, function (err, results) {\n        return callback(results.join(''));\n    });\n}\n;\nfunction setLengthHeader(message) {\n    return message.length + ':' + message;\n}\n/**\n * Async array map using after\n */\nfunction map(ary, each, done) {\n    const results = new Array(ary.length);\n    let count = 0;\n    for (let i = 0; i < ary.length; i++) {\n        each(ary[i], (error, msg) => {\n            results[i] = msg;\n            if (++count === ary.length) {\n                done(null, results);\n            }\n        });\n    }\n}\n/*\n * Decodes data when a payload is maybe expected. Possible binary contents are\n * decoded from their base64 representation\n *\n * @param {String} data, callback method\n * @api public\n */\nfunction decodePayload(data, binaryType, callback) {\n    if (typeof data !== 'string') {\n        return decodePayloadAsBinary(data, binaryType, callback);\n    }\n    if (typeof binaryType === 'function') {\n        callback = binaryType;\n        binaryType = null;\n    }\n    if (data === '') {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n    }\n    var length = '', n, msg, packet;\n    for (var i = 0, l = data.length; i < l; i++) {\n        var chr = data.charAt(i);\n        if (chr !== ':') {\n            length += chr;\n            continue;\n        }\n        // @ts-ignore\n        if (length === '' || (length != (n = Number(length)))) {\n            // parser error - ignoring payload\n            return callback(err, 0, 1);\n        }\n        msg = data.slice(i + 1, i + 1 + n);\n        if (length != msg.length) {\n            // parser error - ignoring payload\n            return callback(err, 0, 1);\n        }\n        if (msg.length) {\n            packet = decodePacket(msg, binaryType, false);\n            if (err.type === packet.type && err.data === packet.data) {\n                // parser error in individual packet - ignoring payload\n                return callback(err, 0, 1);\n            }\n            var more = callback(packet, i + n, l);\n            if (false === more)\n                return;\n        }\n        // advance cursor\n        i += n;\n        length = '';\n    }\n    if (length !== '') {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n    }\n}\n;\n/**\n *\n * Converts a buffer to a utf8.js encoded string\n *\n * @api private\n */\nfunction bufferToString(buffer) {\n    var str = '';\n    for (var i = 0, l = buffer.length; i < l; i++) {\n        str += String.fromCharCode(buffer[i]);\n    }\n    return str;\n}\n/**\n *\n * Converts a utf8.js encoded string to a buffer\n *\n * @api private\n */\nfunction stringToBuffer(string) {\n    var buf = Buffer.allocUnsafe(string.length);\n    for (var i = 0, l = string.length; i < l; i++) {\n        buf.writeUInt8(string.charCodeAt(i), i);\n    }\n    return buf;\n}\n/**\n *\n * Converts an ArrayBuffer to a Buffer\n *\n * @api private\n */\nfunction arrayBufferToBuffer(data) {\n    // data is either an ArrayBuffer or ArrayBufferView.\n    var length = data.byteLength || data.length;\n    var offset = data.byteOffset || 0;\n    return Buffer.from(data.buffer || data, offset, length);\n}\n/**\n * Encodes multiple messages (payload) as binary.\n *\n * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\n * 255><data>\n *\n * Example:\n * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\n *\n * @param {Array} packets\n * @return {Buffer} encoded payload\n * @api private\n */\nfunction encodePayloadAsBinary(packets, callback) {\n    if (!packets.length) {\n        return callback(EMPTY_BUFFER);\n    }\n    map(packets, encodeOneBinaryPacket, function (err, results) {\n        return callback(Buffer.concat(results));\n    });\n}\n;\nfunction encodeOneBinaryPacket(p, doneCallback) {\n    function onBinaryPacketEncode(packet) {\n        var encodingLength = '' + packet.length;\n        var sizeBuffer;\n        if (typeof packet === 'string') {\n            sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);\n            sizeBuffer[0] = 0; // is a string (not true binary = 0)\n            for (var i = 0; i < encodingLength.length; i++) {\n                sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);\n            }\n            sizeBuffer[sizeBuffer.length - 1] = 255;\n            return doneCallback(null, Buffer.concat([sizeBuffer, stringToBuffer(packet)]));\n        }\n        sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);\n        sizeBuffer[0] = 1; // is binary (true binary = 1)\n        for (var i = 0; i < encodingLength.length; i++) {\n            sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);\n        }\n        sizeBuffer[sizeBuffer.length - 1] = 255;\n        doneCallback(null, Buffer.concat([sizeBuffer, packet]));\n    }\n    encodePacket(p, true, true, onBinaryPacketEncode);\n}\n/*\n * Decodes data when a payload is maybe expected. Strings are decoded by\n * interpreting each byte as a key code for entries marked to start with 0. See\n * description of encodePayloadAsBinary\n\n * @param {Buffer} data, callback method\n * @api public\n */\nfunction decodePayloadAsBinary(data, binaryType, callback) {\n    if (typeof binaryType === 'function') {\n        callback = binaryType;\n        binaryType = null;\n    }\n    var bufferTail = data;\n    var buffers = [];\n    var i;\n    while (bufferTail.length > 0) {\n        var strLen = '';\n        var isString = bufferTail[0] === 0;\n        for (i = 1;; i++) {\n            if (bufferTail[i] === 255)\n                break;\n            // 310 = char length of Number.MAX_VALUE\n            if (strLen.length > 310) {\n                return callback(err, 0, 1);\n            }\n            strLen += '' + bufferTail[i];\n        }\n        bufferTail = bufferTail.slice(strLen.length + 1);\n        var msgLength = parseInt(strLen, 10);\n        var msg = bufferTail.slice(1, msgLength + 1);\n        if (isString)\n            msg = bufferToString(msg);\n        buffers.push(msg);\n        bufferTail = bufferTail.slice(msgLength + 1);\n    }\n    var total = buffers.length;\n    for (i = 0; i < total; i++) {\n        var buffer = buffers[i];\n        callback(decodePacket(buffer, binaryType, true), i, total);\n    }\n}\n;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC9wYXJzZXItdjMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLEdBQUcsZ0JBQWdCO0FBQ2xDLG9CQUFvQjtBQUNwQiwwQkFBMEI7QUFDMUIsb0JBQW9CO0FBQ3BCLDBCQUEwQjtBQUMxQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLHVFQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwyREFBMkQ7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxlQUFlO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGVBQWU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWwvcmVkaXMtcHJvamVjdC9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3BhcnNlci12My9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIGltcG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3NvY2tldGlvL2VuZ2luZS5pby1wYXJzZXIvdHJlZS8yLjIueFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYWNrZXRzID0gZXhwb3J0cy5wcm90b2NvbCA9IHZvaWQgMDtcbmV4cG9ydHMuZW5jb2RlUGFja2V0ID0gZW5jb2RlUGFja2V0O1xuZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQgPSBlbmNvZGVCYXNlNjRQYWNrZXQ7XG5leHBvcnRzLmRlY29kZVBhY2tldCA9IGRlY29kZVBhY2tldDtcbmV4cG9ydHMuZGVjb2RlQmFzZTY0UGFja2V0ID0gZGVjb2RlQmFzZTY0UGFja2V0O1xuZXhwb3J0cy5lbmNvZGVQYXlsb2FkID0gZW5jb2RlUGF5bG9hZDtcbmV4cG9ydHMuZGVjb2RlUGF5bG9hZCA9IGRlY29kZVBheWxvYWQ7XG5leHBvcnRzLmVuY29kZVBheWxvYWRBc0JpbmFyeSA9IGVuY29kZVBheWxvYWRBc0JpbmFyeTtcbmV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5ID0gZGVjb2RlUGF5bG9hZEFzQmluYXJ5O1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xuLyoqXG4gKiBDdXJyZW50IHByb3RvY29sIHZlcnNpb24uXG4gKi9cbmV4cG9ydHMucHJvdG9jb2wgPSAzO1xuY29uc3QgaGFzQmluYXJ5ID0gKHBhY2tldHMpID0+IHtcbiAgICBmb3IgKGNvbnN0IHBhY2tldCBvZiBwYWNrZXRzKSB7XG4gICAgICAgIGlmIChwYWNrZXQuZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhwYWNrZXQuZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4vKipcbiAqIFBhY2tldCB0eXBlcy5cbiAqL1xuZXhwb3J0cy5wYWNrZXRzID0ge1xuICAgIG9wZW46IDAgLy8gbm9uLXdzXG4gICAgLFxuICAgIGNsb3NlOiAxIC8vIG5vbi13c1xuICAgICxcbiAgICBwaW5nOiAyLFxuICAgIHBvbmc6IDMsXG4gICAgbWVzc2FnZTogNCxcbiAgICB1cGdyYWRlOiA1LFxuICAgIG5vb3A6IDZcbn07XG52YXIgcGFja2V0c2xpc3QgPSBPYmplY3Qua2V5cyhleHBvcnRzLnBhY2tldHMpO1xuLyoqXG4gKiBQcmVtYWRlIGVycm9yIHBhY2tldC5cbiAqL1xudmFyIGVyciA9IHsgdHlwZTogJ2Vycm9yJywgZGF0YTogJ3BhcnNlciBlcnJvcicgfTtcbmNvbnN0IEVNUFRZX0JVRkZFUiA9IEJ1ZmZlci5jb25jYXQoW10pO1xuLyoqXG4gKiBFbmNvZGVzIGEgcGFja2V0LlxuICpcbiAqICAgICA8cGFja2V0IHR5cGUgaWQ+IFsgPGRhdGE+IF1cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICA1aGVsbG8gd29ybGRcbiAqICAgICAzXG4gKiAgICAgNFxuICpcbiAqIEJpbmFyeSBpcyBlbmNvZGVkIGluIGFuIGlkZW50aWNhbCBwcmluY2lwbGVcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5jb2RlUGFja2V0KHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIHV0ZjhlbmNvZGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBwb3J0c0JpbmFyeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgICAgICBzdXBwb3J0c0JpbmFyeSA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdXRmOGVuY29kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IHV0ZjhlbmNvZGU7XG4gICAgICAgIHV0ZjhlbmNvZGUgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHBhY2tldC5kYXRhKSkge1xuICAgICAgICByZXR1cm4gZW5jb2RlQnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFja2V0LmRhdGEgJiYgKHBhY2tldC5kYXRhLmJ1ZmZlciB8fCBwYWNrZXQuZGF0YSkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gZW5jb2RlQnVmZmVyKHsgdHlwZTogcGFja2V0LnR5cGUsIGRhdGE6IGFycmF5QnVmZmVyVG9CdWZmZXIocGFja2V0LmRhdGEpIH0sIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8vIFNlbmRpbmcgZGF0YSBhcyBhIHV0Zi04IHN0cmluZ1xuICAgIHZhciBlbmNvZGVkID0gZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgICAvLyBkYXRhIGZyYWdtZW50IGlzIG9wdGlvbmFsXG4gICAgaWYgKHVuZGVmaW5lZCAhPT0gcGFja2V0LmRhdGEpIHtcbiAgICAgICAgZW5jb2RlZCArPSB1dGY4ZW5jb2RlID8gdXRmOC5lbmNvZGUoU3RyaW5nKHBhY2tldC5kYXRhKSwgeyBzdHJpY3Q6IGZhbHNlIH0pIDogU3RyaW5nKHBhY2tldC5kYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGxiYWNrKCcnICsgZW5jb2RlZCk7XG59XG47XG4vKipcbiAqIEVuY29kZSBCdWZmZXIgZGF0YVxuICovXG5mdW5jdGlvbiBlbmNvZGVCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gICAgfVxuICAgIHZhciBkYXRhID0gcGFja2V0LmRhdGE7XG4gICAgdmFyIHR5cGVCdWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMSk7XG4gICAgdHlwZUJ1ZmZlclswXSA9IGV4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV07XG4gICAgcmV0dXJuIGNhbGxiYWNrKEJ1ZmZlci5jb25jYXQoW3R5cGVCdWZmZXIsIGRhdGFdKSk7XG59XG4vKipcbiAqIEVuY29kZXMgYSBwYWNrZXQgd2l0aCBiaW5hcnkgZGF0YSBpbiBhIGJhc2U2NCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0LCBoYXMgYHR5cGVgIGFuZCBgZGF0YWBcbiAqIEByZXR1cm4ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuICovXG5mdW5jdGlvbiBlbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjaykge1xuICAgIHZhciBkYXRhID0gQnVmZmVyLmlzQnVmZmVyKHBhY2tldC5kYXRhKSA/IHBhY2tldC5kYXRhIDogYXJyYXlCdWZmZXJUb0J1ZmZlcihwYWNrZXQuZGF0YSk7XG4gICAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdO1xuICAgIG1lc3NhZ2UgKz0gZGF0YS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpO1xufVxuO1xuLyoqXG4gKiBEZWNvZGVzIGEgcGFja2V0LiBEYXRhIGFsc28gYXZhaWxhYmxlIGFzIGFuIEFycmF5QnVmZmVyIGlmIHJlcXVlc3RlZC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWNvZGVQYWNrZXQoZGF0YSwgYmluYXJ5VHlwZSwgdXRmOGRlY29kZSkge1xuICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG4gICAgdmFyIHR5cGU7XG4gICAgLy8gU3RyaW5nIGRhdGFcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHR5cGUgPSBkYXRhLmNoYXJBdCgwKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdiJykge1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZUJhc2U2NFBhY2tldChkYXRhLnNsaWNlKDEpLCBiaW5hcnlUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXRmOGRlY29kZSkge1xuICAgICAgICAgICAgZGF0YSA9IHRyeURlY29kZShkYXRhKTtcbiAgICAgICAgICAgIGlmIChkYXRhID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE51bWJlcih0eXBlKSAhPSB0eXBlIHx8ICFwYWNrZXRzbGlzdFt0eXBlXSkge1xuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogZGF0YS5zbGljZSgxKSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0gfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBCaW5hcnkgZGF0YVxuICAgIGlmIChiaW5hcnlUeXBlID09PSAnYXJyYXlidWZmZXInKSB7XG4gICAgICAgIC8vIHdyYXAgQnVmZmVyL0FycmF5QnVmZmVyIGRhdGEgaW50byBhbiBVaW50OEFycmF5XG4gICAgICAgIHZhciBpbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgICAgICB0eXBlID0gaW50QXJyYXlbMF07XG4gICAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdLCBkYXRhOiBpbnRBcnJheS5idWZmZXIuc2xpY2UoMSkgfTtcbiAgICB9XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICBkYXRhID0gYXJyYXlCdWZmZXJUb0J1ZmZlcihkYXRhKTtcbiAgICB9XG4gICAgdHlwZSA9IGRhdGFbMF07XG4gICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IGRhdGEuc2xpY2UoMSkgfTtcbn1cbjtcbmZ1bmN0aW9uIHRyeURlY29kZShkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IHV0ZjguZGVjb2RlKGRhdGEsIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIHBhY2tldCBlbmNvZGVkIGluIGEgYmFzZTY0IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG4gKi9cbmZ1bmN0aW9uIGRlY29kZUJhc2U2NFBhY2tldChtc2csIGJpbmFyeVR5cGUpIHtcbiAgICB2YXIgdHlwZSA9IHBhY2tldHNsaXN0W21zZy5jaGFyQXQoMCldO1xuICAgIHZhciBkYXRhID0gQnVmZmVyLmZyb20obXNnLnNsaWNlKDEpLCAnYmFzZTY0Jyk7XG4gICAgaWYgKGJpbmFyeVR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICAgICAgdmFyIGFidiA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhYnYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFidltpXSA9IGRhdGFbaV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBkYXRhID0gYWJ2LmJ1ZmZlcjtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogZGF0YSB9O1xufVxuO1xuLyoqXG4gKiBFbmNvZGVzIG11bHRpcGxlIG1lc3NhZ2VzIChwYXlsb2FkKS5cbiAqXG4gKiAgICAgPGxlbmd0aD46ZGF0YVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDExOmhlbGxvIHdvcmxkMjpoaVxuICpcbiAqIElmIGFueSBjb250ZW50cyBhcmUgYmluYXJ5LCB0aGV5IHdpbGwgYmUgZW5jb2RlZCBhcyBiYXNlNjQgc3RyaW5ncy4gQmFzZTY0XG4gKiBlbmNvZGVkIHN0cmluZ3MgYXJlIG1hcmtlZCB3aXRoIGEgYiBiZWZvcmUgdGhlIGxlbmd0aCBzcGVjaWZpZXJcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5jb2RlUGF5bG9hZChwYWNrZXRzLCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIHN1cHBvcnRzQmluYXJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gc3VwcG9ydHNCaW5hcnk7XG4gICAgICAgIHN1cHBvcnRzQmluYXJ5ID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnRzQmluYXJ5ICYmIGhhc0JpbmFyeShwYWNrZXRzKSkge1xuICAgICAgICByZXR1cm4gZW5jb2RlUGF5bG9hZEFzQmluYXJ5KHBhY2tldHMsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soJzA6Jyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgICAgICBlbmNvZGVQYWNrZXQocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgZmFsc2UsIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICBkb25lQ2FsbGJhY2sobnVsbCwgc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdHMuam9pbignJykpO1xuICAgIH0pO1xufVxuO1xuZnVuY3Rpb24gc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbWVzc2FnZS5sZW5ndGggKyAnOicgKyBtZXNzYWdlO1xufVxuLyoqXG4gKiBBc3luYyBhcnJheSBtYXAgdXNpbmcgYWZ0ZXJcbiAqL1xuZnVuY3Rpb24gbWFwKGFyeSwgZWFjaCwgZG9uZSkge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBuZXcgQXJyYXkoYXJ5Lmxlbmd0aCk7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuICAgICAgICBlYWNoKGFyeVtpXSwgKGVycm9yLCBtc2cpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdHNbaV0gPSBtc2c7XG4gICAgICAgICAgICBpZiAoKytjb3VudCA9PT0gYXJ5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRvbmUobnVsbCwgcmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qXG4gKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFBvc3NpYmxlIGJpbmFyeSBjb250ZW50cyBhcmVcbiAqIGRlY29kZWQgZnJvbSB0aGVpciBiYXNlNjQgcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBkZWNvZGVQYXlsb2FkKGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZGVjb2RlUGF5bG9hZEFzQmluYXJ5KGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICAgICAgYmluYXJ5VHlwZSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChkYXRhID09PSAnJykge1xuICAgICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gJycsIG4sIG1zZywgcGFja2V0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGNociA9IGRhdGEuY2hhckF0KGkpO1xuICAgICAgICBpZiAoY2hyICE9PSAnOicpIHtcbiAgICAgICAgICAgIGxlbmd0aCArPSBjaHI7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmIChsZW5ndGggPT09ICcnIHx8IChsZW5ndGggIT0gKG4gPSBOdW1iZXIobGVuZ3RoKSkpKSB7XG4gICAgICAgICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBtc2cgPSBkYXRhLnNsaWNlKGkgKyAxLCBpICsgMSArIG4pO1xuICAgICAgICBpZiAobGVuZ3RoICE9IG1zZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtc2cubGVuZ3RoKSB7XG4gICAgICAgICAgICBwYWNrZXQgPSBkZWNvZGVQYWNrZXQobXNnLCBiaW5hcnlUeXBlLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoZXJyLnR5cGUgPT09IHBhY2tldC50eXBlICYmIGVyci5kYXRhID09PSBwYWNrZXQuZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIHBhcnNlciBlcnJvciBpbiBpbmRpdmlkdWFsIHBhY2tldCAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtb3JlID0gY2FsbGJhY2socGFja2V0LCBpICsgbiwgbCk7XG4gICAgICAgICAgICBpZiAoZmFsc2UgPT09IG1vcmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkdmFuY2UgY3Vyc29yXG4gICAgICAgIGkgKz0gbjtcbiAgICAgICAgbGVuZ3RoID0gJyc7XG4gICAgfVxuICAgIGlmIChsZW5ndGggIT09ICcnKSB7XG4gICAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgfVxufVxuO1xuLyoqXG4gKlxuICogQ29udmVydHMgYSBidWZmZXIgdG8gYSB1dGY4LmpzIGVuY29kZWQgc3RyaW5nXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlclRvU3RyaW5nKGJ1ZmZlcikge1xuICAgIHZhciBzdHIgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGJ1ZmZlci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmZmVyW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbi8qKlxuICpcbiAqIENvbnZlcnRzIGEgdXRmOC5qcyBlbmNvZGVkIHN0cmluZyB0byBhIGJ1ZmZlclxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0J1ZmZlcihzdHJpbmcpIHtcbiAgICB2YXIgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKHN0cmluZy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gc3RyaW5nLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBidWYud3JpdGVVSW50OChzdHJpbmcuY2hhckNvZGVBdChpKSwgaSk7XG4gICAgfVxuICAgIHJldHVybiBidWY7XG59XG4vKipcbiAqXG4gKiBDb252ZXJ0cyBhbiBBcnJheUJ1ZmZlciB0byBhIEJ1ZmZlclxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhcnJheUJ1ZmZlclRvQnVmZmVyKGRhdGEpIHtcbiAgICAvLyBkYXRhIGlzIGVpdGhlciBhbiBBcnJheUJ1ZmZlciBvciBBcnJheUJ1ZmZlclZpZXcuXG4gICAgdmFyIGxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aCB8fCBkYXRhLmxlbmd0aDtcbiAgICB2YXIgb2Zmc2V0ID0gZGF0YS5ieXRlT2Zmc2V0IHx8IDA7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGRhdGEuYnVmZmVyIHx8IGRhdGEsIG9mZnNldCwgbGVuZ3RoKTtcbn1cbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkgYXMgYmluYXJ5LlxuICpcbiAqIDwxID0gYmluYXJ5LCAwID0gc3RyaW5nPjxudW1iZXIgZnJvbSAwLTk+PG51bWJlciBmcm9tIDAtOT5bLi4uXTxudW1iZXJcbiAqIDI1NT48ZGF0YT5cbiAqXG4gKiBFeGFtcGxlOlxuICogMSAzIDI1NSAxIDIgMywgaWYgdGhlIGJpbmFyeSBjb250ZW50cyBhcmUgaW50ZXJwcmV0ZWQgYXMgOCBiaXQgaW50ZWdlcnNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAcmV0dXJuIHtCdWZmZXJ9IGVuY29kZWQgcGF5bG9hZFxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVuY29kZVBheWxvYWRBc0JpbmFyeShwYWNrZXRzLCBjYWxsYmFjaykge1xuICAgIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEVNUFRZX0JVRkZFUik7XG4gICAgfVxuICAgIG1hcChwYWNrZXRzLCBlbmNvZGVPbmVCaW5hcnlQYWNrZXQsIGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEJ1ZmZlci5jb25jYXQocmVzdWx0cykpO1xuICAgIH0pO1xufVxuO1xuZnVuY3Rpb24gZW5jb2RlT25lQmluYXJ5UGFja2V0KHAsIGRvbmVDYWxsYmFjaykge1xuICAgIGZ1bmN0aW9uIG9uQmluYXJ5UGFja2V0RW5jb2RlKHBhY2tldCkge1xuICAgICAgICB2YXIgZW5jb2RpbmdMZW5ndGggPSAnJyArIHBhY2tldC5sZW5ndGg7XG4gICAgICAgIHZhciBzaXplQnVmZmVyO1xuICAgICAgICBpZiAodHlwZW9mIHBhY2tldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHNpemVCdWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoZW5jb2RpbmdMZW5ndGgubGVuZ3RoICsgMik7XG4gICAgICAgICAgICBzaXplQnVmZmVyWzBdID0gMDsgLy8gaXMgYSBzdHJpbmcgKG5vdCB0cnVlIGJpbmFyeSA9IDApXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kaW5nTGVuZ3RoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2l6ZUJ1ZmZlcltpICsgMV0gPSBwYXJzZUludChlbmNvZGluZ0xlbmd0aFtpXSwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2l6ZUJ1ZmZlcltzaXplQnVmZmVyLmxlbmd0aCAtIDFdID0gMjU1O1xuICAgICAgICAgICAgcmV0dXJuIGRvbmVDYWxsYmFjayhudWxsLCBCdWZmZXIuY29uY2F0KFtzaXplQnVmZmVyLCBzdHJpbmdUb0J1ZmZlcihwYWNrZXQpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHNpemVCdWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoZW5jb2RpbmdMZW5ndGgubGVuZ3RoICsgMik7XG4gICAgICAgIHNpemVCdWZmZXJbMF0gPSAxOyAvLyBpcyBiaW5hcnkgKHRydWUgYmluYXJ5ID0gMSlcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGluZ0xlbmd0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2l6ZUJ1ZmZlcltpICsgMV0gPSBwYXJzZUludChlbmNvZGluZ0xlbmd0aFtpXSwgMTApO1xuICAgICAgICB9XG4gICAgICAgIHNpemVCdWZmZXJbc2l6ZUJ1ZmZlci5sZW5ndGggLSAxXSA9IDI1NTtcbiAgICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIEJ1ZmZlci5jb25jYXQoW3NpemVCdWZmZXIsIHBhY2tldF0pKTtcbiAgICB9XG4gICAgZW5jb2RlUGFja2V0KHAsIHRydWUsIHRydWUsIG9uQmluYXJ5UGFja2V0RW5jb2RlKTtcbn1cbi8qXG4gKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFN0cmluZ3MgYXJlIGRlY29kZWQgYnlcbiAqIGludGVycHJldGluZyBlYWNoIGJ5dGUgYXMgYSBrZXkgY29kZSBmb3IgZW50cmllcyBtYXJrZWQgdG8gc3RhcnQgd2l0aCAwLiBTZWVcbiAqIGRlc2NyaXB0aW9uIG9mIGVuY29kZVBheWxvYWRBc0JpbmFyeVxuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBkZWNvZGVQYXlsb2FkQXNCaW5hcnkoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuICAgICAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIGJ1ZmZlclRhaWwgPSBkYXRhO1xuICAgIHZhciBidWZmZXJzID0gW107XG4gICAgdmFyIGk7XG4gICAgd2hpbGUgKGJ1ZmZlclRhaWwubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgc3RyTGVuID0gJyc7XG4gICAgICAgIHZhciBpc1N0cmluZyA9IGJ1ZmZlclRhaWxbMF0gPT09IDA7XG4gICAgICAgIGZvciAoaSA9IDE7OyBpKyspIHtcbiAgICAgICAgICAgIGlmIChidWZmZXJUYWlsW2ldID09PSAyNTUpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyAzMTAgPSBjaGFyIGxlbmd0aCBvZiBOdW1iZXIuTUFYX1ZBTFVFXG4gICAgICAgICAgICBpZiAoc3RyTGVuLmxlbmd0aCA+IDMxMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyTGVuICs9ICcnICsgYnVmZmVyVGFpbFtpXTtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXJUYWlsID0gYnVmZmVyVGFpbC5zbGljZShzdHJMZW4ubGVuZ3RoICsgMSk7XG4gICAgICAgIHZhciBtc2dMZW5ndGggPSBwYXJzZUludChzdHJMZW4sIDEwKTtcbiAgICAgICAgdmFyIG1zZyA9IGJ1ZmZlclRhaWwuc2xpY2UoMSwgbXNnTGVuZ3RoICsgMSk7XG4gICAgICAgIGlmIChpc1N0cmluZylcbiAgICAgICAgICAgIG1zZyA9IGJ1ZmZlclRvU3RyaW5nKG1zZyk7XG4gICAgICAgIGJ1ZmZlcnMucHVzaChtc2cpO1xuICAgICAgICBidWZmZXJUYWlsID0gYnVmZmVyVGFpbC5zbGljZShtc2dMZW5ndGggKyAxKTtcbiAgICB9XG4gICAgdmFyIHRvdGFsID0gYnVmZmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IGJ1ZmZlcnNbaV07XG4gICAgICAgIGNhbGxiYWNrKGRlY29kZVBhY2tldChidWZmZXIsIGJpbmFyeVR5cGUsIHRydWUpLCBpLCB0b3RhbCk7XG4gICAgfVxufVxuO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/engine.io/build/parser-v3/index.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/engine.io/build/parser-v3/utf8.js":
/*!*********************************************************!*\
  !*** ../node_modules/engine.io/build/parser-v3/utf8.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("/*! https://mths.be/utf8js v2.1.2 by @mathias */\nvar stringFromCharCode = String.fromCharCode;\n// Taken from https://mths.be/punycode\nfunction ucs2decode(string) {\n    var output = [];\n    var counter = 0;\n    var length = string.length;\n    var value;\n    var extra;\n    while (counter < length) {\n        value = string.charCodeAt(counter++);\n        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n            // high surrogate, and there is a next character\n            extra = string.charCodeAt(counter++);\n            if ((extra & 0xFC00) == 0xDC00) { // low surrogate\n                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n            }\n            else {\n                // unmatched surrogate; only append this code unit, in case the next\n                // code unit is the high surrogate of a surrogate pair\n                output.push(value);\n                counter--;\n            }\n        }\n        else {\n            output.push(value);\n        }\n    }\n    return output;\n}\n// Taken from https://mths.be/punycode\nfunction ucs2encode(array) {\n    var length = array.length;\n    var index = -1;\n    var value;\n    var output = '';\n    while (++index < length) {\n        value = array[index];\n        if (value > 0xFFFF) {\n            value -= 0x10000;\n            output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n            value = 0xDC00 | value & 0x3FF;\n        }\n        output += stringFromCharCode(value);\n    }\n    return output;\n}\nfunction checkScalarValue(codePoint, strict) {\n    if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {\n        if (strict) {\n            throw Error('Lone surrogate U+' + codePoint.toString(16).toUpperCase() +\n                ' is not a scalar value');\n        }\n        return false;\n    }\n    return true;\n}\n/*--------------------------------------------------------------------------*/\nfunction createByte(codePoint, shift) {\n    return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);\n}\nfunction encodeCodePoint(codePoint, strict) {\n    if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence\n        return stringFromCharCode(codePoint);\n    }\n    var symbol = '';\n    if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence\n        symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);\n    }\n    else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence\n        if (!checkScalarValue(codePoint, strict)) {\n            codePoint = 0xFFFD;\n        }\n        symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);\n        symbol += createByte(codePoint, 6);\n    }\n    else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence\n        symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);\n        symbol += createByte(codePoint, 12);\n        symbol += createByte(codePoint, 6);\n    }\n    symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);\n    return symbol;\n}\nfunction utf8encode(string, opts) {\n    opts = opts || {};\n    var strict = false !== opts.strict;\n    var codePoints = ucs2decode(string);\n    var length = codePoints.length;\n    var index = -1;\n    var codePoint;\n    var byteString = '';\n    while (++index < length) {\n        codePoint = codePoints[index];\n        byteString += encodeCodePoint(codePoint, strict);\n    }\n    return byteString;\n}\n/*--------------------------------------------------------------------------*/\nfunction readContinuationByte() {\n    if (byteIndex >= byteCount) {\n        throw Error('Invalid byte index');\n    }\n    var continuationByte = byteArray[byteIndex] & 0xFF;\n    byteIndex++;\n    if ((continuationByte & 0xC0) == 0x80) {\n        return continuationByte & 0x3F;\n    }\n    // If we end up here, itâ€™s not a continuation byte\n    throw Error('Invalid continuation byte');\n}\nfunction decodeSymbol(strict) {\n    var byte1;\n    var byte2;\n    var byte3;\n    var byte4;\n    var codePoint;\n    if (byteIndex > byteCount) {\n        throw Error('Invalid byte index');\n    }\n    if (byteIndex == byteCount) {\n        return false;\n    }\n    // Read first byte\n    byte1 = byteArray[byteIndex] & 0xFF;\n    byteIndex++;\n    // 1-byte sequence (no continuation bytes)\n    if ((byte1 & 0x80) == 0) {\n        return byte1;\n    }\n    // 2-byte sequence\n    if ((byte1 & 0xE0) == 0xC0) {\n        byte2 = readContinuationByte();\n        codePoint = ((byte1 & 0x1F) << 6) | byte2;\n        if (codePoint >= 0x80) {\n            return codePoint;\n        }\n        else {\n            throw Error('Invalid continuation byte');\n        }\n    }\n    // 3-byte sequence (may include unpaired surrogates)\n    if ((byte1 & 0xF0) == 0xE0) {\n        byte2 = readContinuationByte();\n        byte3 = readContinuationByte();\n        codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;\n        if (codePoint >= 0x0800) {\n            return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;\n        }\n        else {\n            throw Error('Invalid continuation byte');\n        }\n    }\n    // 4-byte sequence\n    if ((byte1 & 0xF8) == 0xF0) {\n        byte2 = readContinuationByte();\n        byte3 = readContinuationByte();\n        byte4 = readContinuationByte();\n        codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |\n            (byte3 << 0x06) | byte4;\n        if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {\n            return codePoint;\n        }\n    }\n    throw Error('Invalid UTF-8 detected');\n}\nvar byteArray;\nvar byteCount;\nvar byteIndex;\nfunction utf8decode(byteString, opts) {\n    opts = opts || {};\n    var strict = false !== opts.strict;\n    byteArray = ucs2decode(byteString);\n    byteCount = byteArray.length;\n    byteIndex = 0;\n    var codePoints = [];\n    var tmp;\n    while ((tmp = decodeSymbol(strict)) !== false) {\n        codePoints.push(tmp);\n    }\n    return ucs2encode(codePoints);\n}\nmodule.exports = {\n    version: '2.1.2',\n    encode: utf8encode,\n    decode: utf8decode\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC9wYXJzZXItdjMvdXRmOC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhbC9yZWRpcy1wcm9qZWN0L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vYnVpbGQvcGFyc2VyLXYzL3V0ZjguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIGh0dHBzOi8vbXRocy5iZS91dGY4anMgdjIuMS4yIGJ5IEBtYXRoaWFzICovXG52YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbi8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5mdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICB2YXIgY291bnRlciA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlO1xuICAgIHZhciBleHRyYTtcbiAgICB3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG4gICAgICAgIGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuICAgICAgICAgICAgZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuICAgICAgICAgICAgaWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcbiAgICAgICAgICAgICAgICAvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgY291bnRlci0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG4vLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgdmFyIGluZGV4ID0gLTE7XG4gICAgdmFyIHZhbHVlO1xuICAgIHZhciBvdXRwdXQgPSAnJztcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlID4gMHhGRkZGKSB7XG4gICAgICAgICAgICB2YWx1ZSAtPSAweDEwMDAwO1xuICAgICAgICAgICAgb3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG4gICAgICAgICAgICB2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG5mdW5jdGlvbiBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSB7XG4gICAgaWYgKGNvZGVQb2ludCA+PSAweEQ4MDAgJiYgY29kZVBvaW50IDw9IDB4REZGRikge1xuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignTG9uZSBzdXJyb2dhdGUgVSsnICsgY29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICtcbiAgICAgICAgICAgICAgICAnIGlzIG5vdCBhIHNjYWxhciB2YWx1ZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ5dGUoY29kZVBvaW50LCBzaGlmdCkge1xuICAgIHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gc2hpZnQpICYgMHgzRikgfCAweDgwKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQsIHN0cmljdCkge1xuICAgIGlmICgoY29kZVBvaW50ICYgMHhGRkZGRkY4MCkgPT0gMCkgeyAvLyAxLWJ5dGUgc2VxdWVuY2VcbiAgICAgICAgcmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgIH1cbiAgICB2YXIgc3ltYm9sID0gJyc7XG4gICAgaWYgKChjb2RlUG9pbnQgJiAweEZGRkZGODAwKSA9PSAwKSB7IC8vIDItYnl0ZSBzZXF1ZW5jZVxuICAgICAgICBzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gNikgJiAweDFGKSB8IDB4QzApO1xuICAgIH1cbiAgICBlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkZGMDAwMCkgPT0gMCkgeyAvLyAzLWJ5dGUgc2VxdWVuY2VcbiAgICAgICAgaWYgKCFjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gMHhGRkZEO1xuICAgICAgICB9XG4gICAgICAgIHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxMikgJiAweDBGKSB8IDB4RTApO1xuICAgICAgICBzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkUwMDAwMCkgPT0gMCkgeyAvLyA0LWJ5dGUgc2VxdWVuY2VcbiAgICAgICAgc3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDE4KSAmIDB4MDcpIHwgMHhGMCk7XG4gICAgICAgIHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgMTIpO1xuICAgICAgICBzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuICAgIH1cbiAgICBzeW1ib2wgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKChjb2RlUG9pbnQgJiAweDNGKSB8IDB4ODApO1xuICAgIHJldHVybiBzeW1ib2w7XG59XG5mdW5jdGlvbiB1dGY4ZW5jb2RlKHN0cmluZywgb3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHZhciBzdHJpY3QgPSBmYWxzZSAhPT0gb3B0cy5zdHJpY3Q7XG4gICAgdmFyIGNvZGVQb2ludHMgPSB1Y3MyZGVjb2RlKHN0cmluZyk7XG4gICAgdmFyIGxlbmd0aCA9IGNvZGVQb2ludHMubGVuZ3RoO1xuICAgIHZhciBpbmRleCA9IC0xO1xuICAgIHZhciBjb2RlUG9pbnQ7XG4gICAgdmFyIGJ5dGVTdHJpbmcgPSAnJztcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBjb2RlUG9pbnQgPSBjb2RlUG9pbnRzW2luZGV4XTtcbiAgICAgICAgYnl0ZVN0cmluZyArPSBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50LCBzdHJpY3QpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZVN0cmluZztcbn1cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKSB7XG4gICAgaWYgKGJ5dGVJbmRleCA+PSBieXRlQ291bnQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuICAgIH1cbiAgICB2YXIgY29udGludWF0aW9uQnl0ZSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcbiAgICBieXRlSW5kZXgrKztcbiAgICBpZiAoKGNvbnRpbnVhdGlvbkJ5dGUgJiAweEMwKSA9PSAweDgwKSB7XG4gICAgICAgIHJldHVybiBjb250aW51YXRpb25CeXRlICYgMHgzRjtcbiAgICB9XG4gICAgLy8gSWYgd2UgZW5kIHVwIGhlcmUsIGl04oCZcyBub3QgYSBjb250aW51YXRpb24gYnl0ZVxuICAgIHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG59XG5mdW5jdGlvbiBkZWNvZGVTeW1ib2woc3RyaWN0KSB7XG4gICAgdmFyIGJ5dGUxO1xuICAgIHZhciBieXRlMjtcbiAgICB2YXIgYnl0ZTM7XG4gICAgdmFyIGJ5dGU0O1xuICAgIHZhciBjb2RlUG9pbnQ7XG4gICAgaWYgKGJ5dGVJbmRleCA+IGJ5dGVDb3VudCkge1xuICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG4gICAgfVxuICAgIGlmIChieXRlSW5kZXggPT0gYnl0ZUNvdW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gUmVhZCBmaXJzdCBieXRlXG4gICAgYnl0ZTEgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG4gICAgYnl0ZUluZGV4Kys7XG4gICAgLy8gMS1ieXRlIHNlcXVlbmNlIChubyBjb250aW51YXRpb24gYnl0ZXMpXG4gICAgaWYgKChieXRlMSAmIDB4ODApID09IDApIHtcbiAgICAgICAgcmV0dXJuIGJ5dGUxO1xuICAgIH1cbiAgICAvLyAyLWJ5dGUgc2VxdWVuY2VcbiAgICBpZiAoKGJ5dGUxICYgMHhFMCkgPT0gMHhDMCkge1xuICAgICAgICBieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG4gICAgICAgIGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDFGKSA8PCA2KSB8IGJ5dGUyO1xuICAgICAgICBpZiAoY29kZVBvaW50ID49IDB4ODApIHtcbiAgICAgICAgICAgIHJldHVybiBjb2RlUG9pbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIDMtYnl0ZSBzZXF1ZW5jZSAobWF5IGluY2x1ZGUgdW5wYWlyZWQgc3Vycm9nYXRlcylcbiAgICBpZiAoKGJ5dGUxICYgMHhGMCkgPT0gMHhFMCkge1xuICAgICAgICBieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG4gICAgICAgIGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcbiAgICAgICAgY29kZVBvaW50ID0gKChieXRlMSAmIDB4MEYpIDw8IDEyKSB8IChieXRlMiA8PCA2KSB8IGJ5dGUzO1xuICAgICAgICBpZiAoY29kZVBvaW50ID49IDB4MDgwMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50LCBzdHJpY3QpID8gY29kZVBvaW50IDogMHhGRkZEO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyA0LWJ5dGUgc2VxdWVuY2VcbiAgICBpZiAoKGJ5dGUxICYgMHhGOCkgPT0gMHhGMCkge1xuICAgICAgICBieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG4gICAgICAgIGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcbiAgICAgICAgYnl0ZTQgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuICAgICAgICBjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwNykgPDwgMHgxMikgfCAoYnl0ZTIgPDwgMHgwQykgfFxuICAgICAgICAgICAgKGJ5dGUzIDw8IDB4MDYpIHwgYnl0ZTQ7XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPj0gMHgwMTAwMDAgJiYgY29kZVBvaW50IDw9IDB4MTBGRkZGKSB7XG4gICAgICAgICAgICByZXR1cm4gY29kZVBvaW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IEVycm9yKCdJbnZhbGlkIFVURi04IGRldGVjdGVkJyk7XG59XG52YXIgYnl0ZUFycmF5O1xudmFyIGJ5dGVDb3VudDtcbnZhciBieXRlSW5kZXg7XG5mdW5jdGlvbiB1dGY4ZGVjb2RlKGJ5dGVTdHJpbmcsIG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICB2YXIgc3RyaWN0ID0gZmFsc2UgIT09IG9wdHMuc3RyaWN0O1xuICAgIGJ5dGVBcnJheSA9IHVjczJkZWNvZGUoYnl0ZVN0cmluZyk7XG4gICAgYnl0ZUNvdW50ID0gYnl0ZUFycmF5Lmxlbmd0aDtcbiAgICBieXRlSW5kZXggPSAwO1xuICAgIHZhciBjb2RlUG9pbnRzID0gW107XG4gICAgdmFyIHRtcDtcbiAgICB3aGlsZSAoKHRtcCA9IGRlY29kZVN5bWJvbChzdHJpY3QpKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgY29kZVBvaW50cy5wdXNoKHRtcCk7XG4gICAgfVxuICAgIHJldHVybiB1Y3MyZW5jb2RlKGNvZGVQb2ludHMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgdmVyc2lvbjogJzIuMS4yJyxcbiAgICBlbmNvZGU6IHV0ZjhlbmNvZGUsXG4gICAgZGVjb2RlOiB1dGY4ZGVjb2RlXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/engine.io/build/parser-v3/utf8.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/engine.io/build/server.js":
/*!*************************************************!*\
  !*** ../node_modules/engine.io/build/server.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Server = exports.BaseServer = void 0;\nconst qs = __webpack_require__(/*! querystring */ \"querystring\");\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst base64id = __webpack_require__(/*! base64id */ \"(rsc)/../node_modules/base64id/lib/base64id.js\");\nconst transports_1 = __webpack_require__(/*! ./transports */ \"(rsc)/../node_modules/engine.io/build/transports/index.js\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst socket_1 = __webpack_require__(/*! ./socket */ \"(rsc)/../node_modules/engine.io/build/socket.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/../node_modules/engine.io/node_modules/debug/src/index.js\");\nconst cookie_1 = __webpack_require__(/*! cookie */ \"(rsc)/../node_modules/cookie/index.js\");\nconst ws_1 = __webpack_require__(/*! ws */ \"ws\");\nconst webtransport_1 = __webpack_require__(/*! ./transports/webtransport */ \"(rsc)/../node_modules/engine.io/build/transports/webtransport.js\");\nconst engine_io_parser_1 = __webpack_require__(/*! engine.io-parser */ \"(rsc)/../node_modules/engine.io-parser/build/cjs/index.js\");\nconst debug = (0, debug_1.default)(\"engine\");\nconst kResponseHeaders = Symbol(\"responseHeaders\");\nfunction parseSessionId(data) {\n    try {\n        const parsed = JSON.parse(data);\n        if (typeof parsed.sid === \"string\") {\n            return parsed.sid;\n        }\n    }\n    catch (e) { }\n}\nclass BaseServer extends events_1.EventEmitter {\n    /**\n     * Server constructor.\n     *\n     * @param {Object} opts - options\n     */\n    constructor(opts = {}) {\n        super();\n        this.middlewares = [];\n        this.clients = {};\n        this.clientsCount = 0;\n        this.opts = Object.assign({\n            wsEngine: ws_1.Server,\n            pingTimeout: 20000,\n            pingInterval: 25000,\n            upgradeTimeout: 10000,\n            maxHttpBufferSize: 1e6,\n            transports: [\"polling\", \"websocket\"], // WebTransport is disabled by default\n            allowUpgrades: true,\n            httpCompression: {\n                threshold: 1024,\n            },\n            cors: false,\n            allowEIO3: false,\n        }, opts);\n        if (opts.cookie) {\n            this.opts.cookie = Object.assign({\n                name: \"io\",\n                path: \"/\",\n                // @ts-ignore\n                httpOnly: opts.cookie.path !== false,\n                sameSite: \"lax\",\n            }, opts.cookie);\n        }\n        if (this.opts.cors) {\n            this.use(__webpack_require__(/*! cors */ \"(rsc)/../node_modules/cors/lib/index.js\")(this.opts.cors));\n        }\n        if (opts.perMessageDeflate) {\n            this.opts.perMessageDeflate = Object.assign({\n                threshold: 1024,\n            }, opts.perMessageDeflate);\n        }\n        this.init();\n    }\n    /**\n     * Compute the pathname of the requests that are handled by the server\n     * @param options\n     * @protected\n     */\n    _computePath(options) {\n        let path = (options.path || \"/engine.io\").replace(/\\/$/, \"\");\n        if (options.addTrailingSlash !== false) {\n            // normalize path\n            path += \"/\";\n        }\n        return path;\n    }\n    /**\n     * Returns a list of available transports for upgrade given a certain transport.\n     *\n     * @return {Array}\n     */\n    upgrades(transport) {\n        if (!this.opts.allowUpgrades)\n            return [];\n        return transports_1.default[transport].upgradesTo || [];\n    }\n    /**\n     * Verifies a request.\n     *\n     * @param {EngineRequest} req\n     * @param upgrade - whether it's an upgrade request\n     * @param fn\n     * @protected\n     */\n    verify(req, upgrade, fn) {\n        // transport check\n        const transport = req._query.transport;\n        // WebTransport does not go through the verify() method, see the onWebTransportSession() method\n        if (!~this.opts.transports.indexOf(transport) ||\n            transport === \"webtransport\") {\n            debug('unknown transport \"%s\"', transport);\n            return fn(Server.errors.UNKNOWN_TRANSPORT, { transport });\n        }\n        // 'Origin' header check\n        const isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);\n        if (isOriginInvalid) {\n            const origin = req.headers.origin;\n            req.headers.origin = null;\n            debug(\"origin header invalid\");\n            return fn(Server.errors.BAD_REQUEST, {\n                name: \"INVALID_ORIGIN\",\n                origin,\n            });\n        }\n        // sid check\n        const sid = req._query.sid;\n        if (sid) {\n            if (!this.clients.hasOwnProperty(sid)) {\n                debug('unknown sid \"%s\"', sid);\n                return fn(Server.errors.UNKNOWN_SID, {\n                    sid,\n                });\n            }\n            const previousTransport = this.clients[sid].transport.name;\n            if (!upgrade && previousTransport !== transport) {\n                debug(\"bad request: unexpected transport without upgrade\");\n                return fn(Server.errors.BAD_REQUEST, {\n                    name: \"TRANSPORT_MISMATCH\",\n                    transport,\n                    previousTransport,\n                });\n            }\n        }\n        else {\n            // handshake is GET only\n            if (\"GET\" !== req.method) {\n                return fn(Server.errors.BAD_HANDSHAKE_METHOD, {\n                    method: req.method,\n                });\n            }\n            if (transport === \"websocket\" && !upgrade) {\n                debug(\"invalid transport upgrade\");\n                return fn(Server.errors.BAD_REQUEST, {\n                    name: \"TRANSPORT_HANDSHAKE_ERROR\",\n                });\n            }\n            if (!this.opts.allowRequest)\n                return fn();\n            return this.opts.allowRequest(req, (message, success) => {\n                if (!success) {\n                    return fn(Server.errors.FORBIDDEN, {\n                        message,\n                    });\n                }\n                fn();\n            });\n        }\n        fn();\n    }\n    /**\n     * Adds a new middleware.\n     *\n     * @example\n     * import helmet from \"helmet\";\n     *\n     * engine.use(helmet());\n     *\n     * @param fn\n     */\n    use(fn) {\n        this.middlewares.push(fn);\n    }\n    /**\n     * Apply the middlewares to the request.\n     *\n     * @param req\n     * @param res\n     * @param callback\n     * @protected\n     */\n    _applyMiddlewares(req, res, callback) {\n        if (this.middlewares.length === 0) {\n            debug(\"no middleware to apply, skipping\");\n            return callback();\n        }\n        const apply = (i) => {\n            debug(\"applying middleware nÂ°%d\", i + 1);\n            this.middlewares[i](req, res, (err) => {\n                if (err) {\n                    return callback(err);\n                }\n                if (i + 1 < this.middlewares.length) {\n                    apply(i + 1);\n                }\n                else {\n                    callback();\n                }\n            });\n        };\n        apply(0);\n    }\n    /**\n     * Closes all clients.\n     */\n    close() {\n        debug(\"closing all open clients\");\n        for (let i in this.clients) {\n            if (this.clients.hasOwnProperty(i)) {\n                this.clients[i].close(true);\n            }\n        }\n        this.cleanup();\n        return this;\n    }\n    /**\n     * generate a socket id.\n     * Overwrite this method to generate your custom socket id\n     *\n     * @param {IncomingMessage} req - the request object\n     */\n    generateId(req) {\n        return base64id.generateId();\n    }\n    /**\n     * Handshakes a new client.\n     *\n     * @param {String} transportName\n     * @param {Object} req - the request object\n     * @param {Function} closeConnection\n     *\n     * @protected\n     */\n    async handshake(transportName, req, closeConnection) {\n        const protocol = req._query.EIO === \"4\" ? 4 : 3; // 3rd revision by default\n        if (protocol === 3 && !this.opts.allowEIO3) {\n            debug(\"unsupported protocol version\");\n            this.emit(\"connection_error\", {\n                req,\n                code: Server.errors.UNSUPPORTED_PROTOCOL_VERSION,\n                message: Server.errorMessages[Server.errors.UNSUPPORTED_PROTOCOL_VERSION],\n                context: {\n                    protocol,\n                },\n            });\n            closeConnection(Server.errors.UNSUPPORTED_PROTOCOL_VERSION);\n            return;\n        }\n        let id;\n        try {\n            id = await this.generateId(req);\n        }\n        catch (e) {\n            debug(\"error while generating an id\");\n            this.emit(\"connection_error\", {\n                req,\n                code: Server.errors.BAD_REQUEST,\n                message: Server.errorMessages[Server.errors.BAD_REQUEST],\n                context: {\n                    name: \"ID_GENERATION_ERROR\",\n                    error: e,\n                },\n            });\n            closeConnection(Server.errors.BAD_REQUEST);\n            return;\n        }\n        debug('handshaking client \"%s\"', id);\n        try {\n            var transport = this.createTransport(transportName, req);\n            if (\"polling\" === transportName) {\n                transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;\n                transport.httpCompression = this.opts.httpCompression;\n            }\n            else if (\"websocket\" === transportName) {\n                transport.perMessageDeflate = this.opts.perMessageDeflate;\n            }\n        }\n        catch (e) {\n            debug('error handshaking to transport \"%s\"', transportName);\n            this.emit(\"connection_error\", {\n                req,\n                code: Server.errors.BAD_REQUEST,\n                message: Server.errorMessages[Server.errors.BAD_REQUEST],\n                context: {\n                    name: \"TRANSPORT_HANDSHAKE_ERROR\",\n                    error: e,\n                },\n            });\n            closeConnection(Server.errors.BAD_REQUEST);\n            return;\n        }\n        const socket = new socket_1.Socket(id, this, transport, req, protocol);\n        transport.on(\"headers\", (headers, req) => {\n            const isInitialRequest = !req._query.sid;\n            if (isInitialRequest) {\n                if (this.opts.cookie) {\n                    headers[\"Set-Cookie\"] = [\n                        // @ts-ignore\n                        (0, cookie_1.serialize)(this.opts.cookie.name, id, this.opts.cookie),\n                    ];\n                }\n                this.emit(\"initial_headers\", headers, req);\n            }\n            this.emit(\"headers\", headers, req);\n        });\n        transport.onRequest(req);\n        this.clients[id] = socket;\n        this.clientsCount++;\n        socket.once(\"close\", () => {\n            delete this.clients[id];\n            this.clientsCount--;\n        });\n        this.emit(\"connection\", socket);\n        return transport;\n    }\n    async onWebTransportSession(session) {\n        const timeout = setTimeout(() => {\n            debug(\"the client failed to establish a bidirectional stream in the given period\");\n            session.close();\n        }, this.opts.upgradeTimeout);\n        const streamReader = session.incomingBidirectionalStreams.getReader();\n        const result = await streamReader.read();\n        if (result.done) {\n            debug(\"session is closed\");\n            return;\n        }\n        const stream = result.value;\n        const transformStream = (0, engine_io_parser_1.createPacketDecoderStream)(this.opts.maxHttpBufferSize, \"nodebuffer\");\n        const reader = stream.readable.pipeThrough(transformStream).getReader();\n        // reading the first packet of the stream\n        const { value, done } = await reader.read();\n        if (done) {\n            debug(\"stream is closed\");\n            return;\n        }\n        clearTimeout(timeout);\n        if (value.type !== \"open\") {\n            debug(\"invalid WebTransport handshake\");\n            return session.close();\n        }\n        if (value.data === undefined) {\n            const transport = new webtransport_1.WebTransport(session, stream, reader);\n            // note: we cannot use \"this.generateId()\", because there is no \"req\" argument\n            const id = base64id.generateId();\n            debug('handshaking client \"%s\" (WebTransport)', id);\n            const socket = new socket_1.Socket(id, this, transport, null, 4);\n            this.clients[id] = socket;\n            this.clientsCount++;\n            socket.once(\"close\", () => {\n                delete this.clients[id];\n                this.clientsCount--;\n            });\n            this.emit(\"connection\", socket);\n            return;\n        }\n        const sid = parseSessionId(value.data);\n        if (!sid) {\n            debug(\"invalid WebTransport handshake\");\n            return session.close();\n        }\n        const client = this.clients[sid];\n        if (!client) {\n            debug(\"upgrade attempt for closed client\");\n            session.close();\n        }\n        else if (client.upgrading) {\n            debug(\"transport has already been trying to upgrade\");\n            session.close();\n        }\n        else if (client.upgraded) {\n            debug(\"transport had already been upgraded\");\n            session.close();\n        }\n        else {\n            debug(\"upgrading existing transport\");\n            const transport = new webtransport_1.WebTransport(session, stream, reader);\n            client._maybeUpgrade(transport);\n        }\n    }\n}\nexports.BaseServer = BaseServer;\n/**\n * Protocol errors mappings.\n */\nBaseServer.errors = {\n    UNKNOWN_TRANSPORT: 0,\n    UNKNOWN_SID: 1,\n    BAD_HANDSHAKE_METHOD: 2,\n    BAD_REQUEST: 3,\n    FORBIDDEN: 4,\n    UNSUPPORTED_PROTOCOL_VERSION: 5,\n};\nBaseServer.errorMessages = {\n    0: \"Transport unknown\",\n    1: \"Session ID unknown\",\n    2: \"Bad handshake method\",\n    3: \"Bad request\",\n    4: \"Forbidden\",\n    5: \"Unsupported protocol version\",\n};\n/**\n * Exposes a subset of the http.ServerResponse interface, in order to be able to apply the middlewares to an upgrade\n * request.\n *\n * @see https://nodejs.org/api/http.html#class-httpserverresponse\n */\nclass WebSocketResponse {\n    constructor(req, socket) {\n        this.req = req;\n        this.socket = socket;\n        // temporarily store the response headers on the req object (see the \"headers\" event)\n        req[kResponseHeaders] = {};\n    }\n    setHeader(name, value) {\n        this.req[kResponseHeaders][name] = value;\n    }\n    getHeader(name) {\n        return this.req[kResponseHeaders][name];\n    }\n    removeHeader(name) {\n        delete this.req[kResponseHeaders][name];\n    }\n    write() { }\n    writeHead() { }\n    end() {\n        // we could return a proper error code, but the WebSocket client will emit an \"error\" event anyway.\n        this.socket.destroy();\n    }\n}\n/**\n * An Engine.IO server based on Node.js built-in HTTP server and the `ws` package for WebSocket connections.\n */\nclass Server extends BaseServer {\n    /**\n     * Initialize websocket server\n     *\n     * @protected\n     */\n    init() {\n        if (!~this.opts.transports.indexOf(\"websocket\"))\n            return;\n        if (this.ws)\n            this.ws.close();\n        this.ws = new this.opts.wsEngine({\n            noServer: true,\n            clientTracking: false,\n            perMessageDeflate: this.opts.perMessageDeflate,\n            maxPayload: this.opts.maxHttpBufferSize,\n        });\n        if (typeof this.ws.on === \"function\") {\n            this.ws.on(\"headers\", (headersArray, req) => {\n                // note: 'ws' uses an array of headers, while Engine.IO uses an object (response.writeHead() accepts both formats)\n                // we could also try to parse the array and then sync the values, but that will be error-prone\n                const additionalHeaders = req[kResponseHeaders] || {};\n                delete req[kResponseHeaders];\n                const isInitialRequest = !req._query.sid;\n                if (isInitialRequest) {\n                    this.emit(\"initial_headers\", additionalHeaders, req);\n                }\n                this.emit(\"headers\", additionalHeaders, req);\n                debug(\"writing headers: %j\", additionalHeaders);\n                Object.keys(additionalHeaders).forEach((key) => {\n                    headersArray.push(`${key}: ${additionalHeaders[key]}`);\n                });\n            });\n        }\n    }\n    cleanup() {\n        if (this.ws) {\n            debug(\"closing webSocketServer\");\n            this.ws.close();\n            // don't delete this.ws because it can be used again if the http server starts listening again\n        }\n    }\n    /**\n     * Prepares a request by processing the query string.\n     *\n     * @private\n     */\n    prepare(req) {\n        // try to leverage pre-existing `req._query` (e.g: from connect)\n        if (!req._query) {\n            req._query = (~req.url.indexOf(\"?\") ? qs.parse((0, url_1.parse)(req.url).query) : {});\n        }\n    }\n    createTransport(transportName, req) {\n        return new transports_1.default[transportName](req);\n    }\n    /**\n     * Handles an Engine.IO HTTP request.\n     *\n     * @param {EngineRequest} req\n     * @param {ServerResponse} res\n     */\n    handleRequest(req, res) {\n        debug('handling \"%s\" http request \"%s\"', req.method, req.url);\n        this.prepare(req);\n        req.res = res;\n        const callback = (errorCode, errorContext) => {\n            if (errorCode !== undefined) {\n                this.emit(\"connection_error\", {\n                    req,\n                    code: errorCode,\n                    message: Server.errorMessages[errorCode],\n                    context: errorContext,\n                });\n                abortRequest(res, errorCode, errorContext);\n                return;\n            }\n            if (req._query.sid) {\n                debug(\"setting new request for existing client\");\n                this.clients[req._query.sid].transport.onRequest(req);\n            }\n            else {\n                const closeConnection = (errorCode, errorContext) => abortRequest(res, errorCode, errorContext);\n                this.handshake(req._query.transport, req, closeConnection);\n            }\n        };\n        this._applyMiddlewares(req, res, (err) => {\n            if (err) {\n                callback(Server.errors.BAD_REQUEST, { name: \"MIDDLEWARE_FAILURE\" });\n            }\n            else {\n                this.verify(req, false, callback);\n            }\n        });\n    }\n    /**\n     * Handles an Engine.IO HTTP Upgrade.\n     */\n    handleUpgrade(req, socket, upgradeHead) {\n        this.prepare(req);\n        const res = new WebSocketResponse(req, socket);\n        const callback = (errorCode, errorContext) => {\n            if (errorCode !== undefined) {\n                this.emit(\"connection_error\", {\n                    req,\n                    code: errorCode,\n                    message: Server.errorMessages[errorCode],\n                    context: errorContext,\n                });\n                abortUpgrade(socket, errorCode, errorContext);\n                return;\n            }\n            const head = Buffer.from(upgradeHead);\n            upgradeHead = null;\n            // some middlewares (like express-session) wait for the writeHead() call to flush their headers\n            // see https://github.com/expressjs/session/blob/1010fadc2f071ddf2add94235d72224cf65159c6/index.js#L220-L244\n            res.writeHead();\n            // delegate to ws\n            this.ws.handleUpgrade(req, socket, head, (websocket) => {\n                this.onWebSocket(req, socket, websocket);\n            });\n        };\n        this._applyMiddlewares(req, res, (err) => {\n            if (err) {\n                callback(Server.errors.BAD_REQUEST, { name: \"MIDDLEWARE_FAILURE\" });\n            }\n            else {\n                this.verify(req, true, callback);\n            }\n        });\n    }\n    /**\n     * Called upon a ws.io connection.\n     *\n     * @param {ws.Socket} websocket\n     * @private\n     */\n    onWebSocket(req, socket, websocket) {\n        websocket.on(\"error\", onUpgradeError);\n        if (transports_1.default[req._query.transport] !== undefined &&\n            !transports_1.default[req._query.transport].prototype.handlesUpgrades) {\n            debug(\"transport doesnt handle upgraded requests\");\n            websocket.close();\n            return;\n        }\n        // get client id\n        const id = req._query.sid;\n        // keep a reference to the ws.Socket\n        req.websocket = websocket;\n        if (id) {\n            const client = this.clients[id];\n            if (!client) {\n                debug(\"upgrade attempt for closed client\");\n                websocket.close();\n            }\n            else if (client.upgrading) {\n                debug(\"transport has already been trying to upgrade\");\n                websocket.close();\n            }\n            else if (client.upgraded) {\n                debug(\"transport had already been upgraded\");\n                websocket.close();\n            }\n            else {\n                debug(\"upgrading existing transport\");\n                // transport error handling takes over\n                websocket.removeListener(\"error\", onUpgradeError);\n                const transport = this.createTransport(req._query.transport, req);\n                transport.perMessageDeflate = this.opts.perMessageDeflate;\n                client._maybeUpgrade(transport);\n            }\n        }\n        else {\n            const closeConnection = (errorCode, errorContext) => abortUpgrade(socket, errorCode, errorContext);\n            this.handshake(req._query.transport, req, closeConnection);\n        }\n        function onUpgradeError() {\n            debug(\"websocket error before upgrade\");\n            // websocket.close() not needed\n        }\n    }\n    /**\n     * Captures upgrade requests for a http.Server.\n     *\n     * @param {http.Server} server\n     * @param {Object} options\n     */\n    attach(server, options = {}) {\n        const path = this._computePath(options);\n        const destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000;\n        function check(req) {\n            // TODO use `path === new URL(...).pathname` in the next major release (ref: https://nodejs.org/api/url.html)\n            return path === req.url.slice(0, path.length);\n        }\n        // cache and clean up listeners\n        const listeners = server.listeners(\"request\").slice(0);\n        server.removeAllListeners(\"request\");\n        server.on(\"close\", this.close.bind(this));\n        server.on(\"listening\", this.init.bind(this));\n        // add request handler\n        server.on(\"request\", (req, res) => {\n            if (check(req)) {\n                debug('intercepting request for path \"%s\"', path);\n                this.handleRequest(req, res);\n            }\n            else {\n                let i = 0;\n                const l = listeners.length;\n                for (; i < l; i++) {\n                    listeners[i].call(server, req, res);\n                }\n            }\n        });\n        if (~this.opts.transports.indexOf(\"websocket\")) {\n            server.on(\"upgrade\", (req, socket, head) => {\n                if (check(req)) {\n                    this.handleUpgrade(req, socket, head);\n                }\n                else if (false !== options.destroyUpgrade) {\n                    // default node behavior is to disconnect when no handlers\n                    // but by adding a handler, we prevent that\n                    // and if no eio thing handles the upgrade\n                    // then the socket needs to die!\n                    setTimeout(function () {\n                        // @ts-ignore\n                        if (socket.writable && socket.bytesWritten <= 0) {\n                            socket.on(\"error\", (e) => {\n                                debug(\"error while destroying upgrade: %s\", e.message);\n                            });\n                            return socket.end();\n                        }\n                    }, destroyUpgradeTimeout);\n                }\n            });\n        }\n    }\n}\nexports.Server = Server;\n/**\n * Close the HTTP long-polling request\n *\n * @param res - the response object\n * @param errorCode - the error code\n * @param errorContext - additional error context\n *\n * @private\n */\nfunction abortRequest(res, errorCode, errorContext) {\n    const statusCode = errorCode === Server.errors.FORBIDDEN ? 403 : 400;\n    const message = errorContext && errorContext.message\n        ? errorContext.message\n        : Server.errorMessages[errorCode];\n    res.writeHead(statusCode, { \"Content-Type\": \"application/json\" });\n    res.end(JSON.stringify({\n        code: errorCode,\n        message,\n    }));\n}\n/**\n * Close the WebSocket connection\n *\n * @param {net.Socket} socket\n * @param {string} errorCode - the error code\n * @param {object} errorContext - additional error context\n */\nfunction abortUpgrade(socket, errorCode, errorContext = {}) {\n    socket.on(\"error\", () => {\n        debug(\"ignoring error from closed connection\");\n    });\n    if (socket.writable) {\n        const message = errorContext.message || Server.errorMessages[errorCode];\n        const length = Buffer.byteLength(message);\n        socket.write(\"HTTP/1.1 400 Bad Request\\r\\n\" +\n            \"Connection: close\\r\\n\" +\n            \"Content-type: text/html\\r\\n\" +\n            \"Content-Length: \" +\n            length +\n            \"\\r\\n\" +\n            \"\\r\\n\" +\n            message);\n    }\n    socket.destroy();\n}\n/* eslint-disable */\n/**\n * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354\n *\n * True if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n *\n * checkInvalidHeaderChar() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/\n// prettier-ignore\nconst validHdrChars = [\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, // 0 - 15\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 32 - 47\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 48 - 63\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 80 - 95\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, // 112 - 127\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 128 ...\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // ... 255\n];\nfunction checkInvalidHeaderChar(val) {\n    val += \"\";\n    if (val.length < 1)\n        return false;\n    if (!validHdrChars[val.charCodeAt(0)]) {\n        debug('invalid header, index 0, char \"%s\"', val.charCodeAt(0));\n        return true;\n    }\n    if (val.length < 2)\n        return false;\n    if (!validHdrChars[val.charCodeAt(1)]) {\n        debug('invalid header, index 1, char \"%s\"', val.charCodeAt(1));\n        return true;\n    }\n    if (val.length < 3)\n        return false;\n    if (!validHdrChars[val.charCodeAt(2)]) {\n        debug('invalid header, index 2, char \"%s\"', val.charCodeAt(2));\n        return true;\n    }\n    if (val.length < 4)\n        return false;\n    if (!validHdrChars[val.charCodeAt(3)]) {\n        debug('invalid header, index 3, char \"%s\"', val.charCodeAt(3));\n        return true;\n    }\n    for (let i = 4; i < val.length; ++i) {\n        if (!validHdrChars[val.charCodeAt(i)]) {\n            debug('invalid header, index \"%i\", char \"%s\"', i, val.charCodeAt(i));\n            return true;\n        }\n    }\n    return false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC9zZXJ2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLGtCQUFrQjtBQUNuQyxXQUFXLG1CQUFPLENBQUMsZ0NBQWE7QUFDaEMsY0FBYyxtQkFBTyxDQUFDLGdCQUFLO0FBQzNCLGlCQUFpQixtQkFBTyxDQUFDLGdFQUFVO0FBQ25DLHFCQUFxQixtQkFBTyxDQUFDLCtFQUFjO0FBQzNDLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLGlFQUFVO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLDhFQUFPO0FBQy9CLGlCQUFpQixtQkFBTyxDQUFDLHFEQUFRO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxjQUFJO0FBQ3pCLHVCQUF1QixtQkFBTyxDQUFDLG1HQUEyQjtBQUMxRCwyQkFBMkIsbUJBQU8sQ0FBQyxtRkFBa0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMscURBQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsV0FBVztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsSUFBSSxJQUFJLHVCQUF1QjtBQUN4RSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCw0QkFBNEI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCw0QkFBNEI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0NBQW9DO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhbC9yZWRpcy1wcm9qZWN0L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vYnVpbGQvc2VydmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZXJ2ZXIgPSBleHBvcnRzLkJhc2VTZXJ2ZXIgPSB2b2lkIDA7XG5jb25zdCBxcyA9IHJlcXVpcmUoXCJxdWVyeXN0cmluZ1wiKTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcInVybFwiKTtcbmNvbnN0IGJhc2U2NGlkID0gcmVxdWlyZShcImJhc2U2NGlkXCIpO1xuY29uc3QgdHJhbnNwb3J0c18xID0gcmVxdWlyZShcIi4vdHJhbnNwb3J0c1wiKTtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IHNvY2tldF8xID0gcmVxdWlyZShcIi4vc29ja2V0XCIpO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IGNvb2tpZV8xID0gcmVxdWlyZShcImNvb2tpZVwiKTtcbmNvbnN0IHdzXzEgPSByZXF1aXJlKFwid3NcIik7XG5jb25zdCB3ZWJ0cmFuc3BvcnRfMSA9IHJlcXVpcmUoXCIuL3RyYW5zcG9ydHMvd2VidHJhbnNwb3J0XCIpO1xuY29uc3QgZW5naW5lX2lvX3BhcnNlcl8xID0gcmVxdWlyZShcImVuZ2luZS5pby1wYXJzZXJcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwiZW5naW5lXCIpO1xuY29uc3Qga1Jlc3BvbnNlSGVhZGVycyA9IFN5bWJvbChcInJlc3BvbnNlSGVhZGVyc1wiKTtcbmZ1bmN0aW9uIHBhcnNlU2Vzc2lvbklkKGRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICBpZiAodHlwZW9mIHBhcnNlZC5zaWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWQuc2lkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7IH1cbn1cbmNsYXNzIEJhc2VTZXJ2ZXIgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIFNlcnZlciBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1pZGRsZXdhcmVzID0gW107XG4gICAgICAgIHRoaXMuY2xpZW50cyA9IHt9O1xuICAgICAgICB0aGlzLmNsaWVudHNDb3VudCA9IDA7XG4gICAgICAgIHRoaXMub3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgd3NFbmdpbmU6IHdzXzEuU2VydmVyLFxuICAgICAgICAgICAgcGluZ1RpbWVvdXQ6IDIwMDAwLFxuICAgICAgICAgICAgcGluZ0ludGVydmFsOiAyNTAwMCxcbiAgICAgICAgICAgIHVwZ3JhZGVUaW1lb3V0OiAxMDAwMCxcbiAgICAgICAgICAgIG1heEh0dHBCdWZmZXJTaXplOiAxZTYsXG4gICAgICAgICAgICB0cmFuc3BvcnRzOiBbXCJwb2xsaW5nXCIsIFwid2Vic29ja2V0XCJdLCAvLyBXZWJUcmFuc3BvcnQgaXMgZGlzYWJsZWQgYnkgZGVmYXVsdFxuICAgICAgICAgICAgYWxsb3dVcGdyYWRlczogdHJ1ZSxcbiAgICAgICAgICAgIGh0dHBDb21wcmVzc2lvbjoge1xuICAgICAgICAgICAgICAgIHRocmVzaG9sZDogMTAyNCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb3JzOiBmYWxzZSxcbiAgICAgICAgICAgIGFsbG93RUlPMzogZmFsc2UsXG4gICAgICAgIH0sIG9wdHMpO1xuICAgICAgICBpZiAob3B0cy5jb29raWUpIHtcbiAgICAgICAgICAgIHRoaXMub3B0cy5jb29raWUgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImlvXCIsXG4gICAgICAgICAgICAgICAgcGF0aDogXCIvXCIsXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGh0dHBPbmx5OiBvcHRzLmNvb2tpZS5wYXRoICE9PSBmYWxzZSxcbiAgICAgICAgICAgICAgICBzYW1lU2l0ZTogXCJsYXhcIixcbiAgICAgICAgICAgIH0sIG9wdHMuY29va2llKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRzLmNvcnMpIHtcbiAgICAgICAgICAgIHRoaXMudXNlKHJlcXVpcmUoXCJjb3JzXCIpKHRoaXMub3B0cy5jb3JzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMucGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMub3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIHRocmVzaG9sZDogMTAyNCxcbiAgICAgICAgICAgIH0sIG9wdHMucGVyTWVzc2FnZURlZmxhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBwYXRobmFtZSBvZiB0aGUgcmVxdWVzdHMgdGhhdCBhcmUgaGFuZGxlZCBieSB0aGUgc2VydmVyXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NvbXB1dGVQYXRoKG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHBhdGggPSAob3B0aW9ucy5wYXRoIHx8IFwiL2VuZ2luZS5pb1wiKS5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG4gICAgICAgIGlmIChvcHRpb25zLmFkZFRyYWlsaW5nU2xhc2ggIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBub3JtYWxpemUgcGF0aFxuICAgICAgICAgICAgcGF0aCArPSBcIi9cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgYXZhaWxhYmxlIHRyYW5zcG9ydHMgZm9yIHVwZ3JhZGUgZ2l2ZW4gYSBjZXJ0YWluIHRyYW5zcG9ydC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIHVwZ3JhZGVzKHRyYW5zcG9ydCkge1xuICAgICAgICBpZiAoIXRoaXMub3B0cy5hbGxvd1VwZ3JhZGVzKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICByZXR1cm4gdHJhbnNwb3J0c18xLmRlZmF1bHRbdHJhbnNwb3J0XS51cGdyYWRlc1RvIHx8IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VuZ2luZVJlcXVlc3R9IHJlcVxuICAgICAqIEBwYXJhbSB1cGdyYWRlIC0gd2hldGhlciBpdCdzIGFuIHVwZ3JhZGUgcmVxdWVzdFxuICAgICAqIEBwYXJhbSBmblxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB2ZXJpZnkocmVxLCB1cGdyYWRlLCBmbikge1xuICAgICAgICAvLyB0cmFuc3BvcnQgY2hlY2tcbiAgICAgICAgY29uc3QgdHJhbnNwb3J0ID0gcmVxLl9xdWVyeS50cmFuc3BvcnQ7XG4gICAgICAgIC8vIFdlYlRyYW5zcG9ydCBkb2VzIG5vdCBnbyB0aHJvdWdoIHRoZSB2ZXJpZnkoKSBtZXRob2QsIHNlZSB0aGUgb25XZWJUcmFuc3BvcnRTZXNzaW9uKCkgbWV0aG9kXG4gICAgICAgIGlmICghfnRoaXMub3B0cy50cmFuc3BvcnRzLmluZGV4T2YodHJhbnNwb3J0KSB8fFxuICAgICAgICAgICAgdHJhbnNwb3J0ID09PSBcIndlYnRyYW5zcG9ydFwiKSB7XG4gICAgICAgICAgICBkZWJ1ZygndW5rbm93biB0cmFuc3BvcnQgXCIlc1wiJywgdHJhbnNwb3J0KTtcbiAgICAgICAgICAgIHJldHVybiBmbihTZXJ2ZXIuZXJyb3JzLlVOS05PV05fVFJBTlNQT1JULCB7IHRyYW5zcG9ydCB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyAnT3JpZ2luJyBoZWFkZXIgY2hlY2tcbiAgICAgICAgY29uc3QgaXNPcmlnaW5JbnZhbGlkID0gY2hlY2tJbnZhbGlkSGVhZGVyQ2hhcihyZXEuaGVhZGVycy5vcmlnaW4pO1xuICAgICAgICBpZiAoaXNPcmlnaW5JbnZhbGlkKSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW4gPSByZXEuaGVhZGVycy5vcmlnaW47XG4gICAgICAgICAgICByZXEuaGVhZGVycy5vcmlnaW4gPSBudWxsO1xuICAgICAgICAgICAgZGVidWcoXCJvcmlnaW4gaGVhZGVyIGludmFsaWRcIik7XG4gICAgICAgICAgICByZXR1cm4gZm4oU2VydmVyLmVycm9ycy5CQURfUkVRVUVTVCwge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiSU5WQUxJRF9PUklHSU5cIixcbiAgICAgICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzaWQgY2hlY2tcbiAgICAgICAgY29uc3Qgc2lkID0gcmVxLl9xdWVyeS5zaWQ7XG4gICAgICAgIGlmIChzaWQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jbGllbnRzLmhhc093blByb3BlcnR5KHNpZCkpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZygndW5rbm93biBzaWQgXCIlc1wiJywgc2lkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oU2VydmVyLmVycm9ycy5VTktOT1dOX1NJRCwge1xuICAgICAgICAgICAgICAgICAgICBzaWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c1RyYW5zcG9ydCA9IHRoaXMuY2xpZW50c1tzaWRdLnRyYW5zcG9ydC5uYW1lO1xuICAgICAgICAgICAgaWYgKCF1cGdyYWRlICYmIHByZXZpb3VzVHJhbnNwb3J0ICE9PSB0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImJhZCByZXF1ZXN0OiB1bmV4cGVjdGVkIHRyYW5zcG9ydCB3aXRob3V0IHVwZ3JhZGVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKFNlcnZlci5lcnJvcnMuQkFEX1JFUVVFU1QsIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJUUkFOU1BPUlRfTUlTTUFUQ0hcIixcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LFxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1RyYW5zcG9ydCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGhhbmRzaGFrZSBpcyBHRVQgb25seVxuICAgICAgICAgICAgaWYgKFwiR0VUXCIgIT09IHJlcS5tZXRob2QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oU2VydmVyLmVycm9ycy5CQURfSEFORFNIQUtFX01FVEhPRCwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHJlcS5tZXRob2QsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhbnNwb3J0ID09PSBcIndlYnNvY2tldFwiICYmICF1cGdyYWRlKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJpbnZhbGlkIHRyYW5zcG9ydCB1cGdyYWRlXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmbihTZXJ2ZXIuZXJyb3JzLkJBRF9SRVFVRVNULCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiVFJBTlNQT1JUX0hBTkRTSEFLRV9FUlJPUlwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdHMuYWxsb3dSZXF1ZXN0KVxuICAgICAgICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0cy5hbGxvd1JlcXVlc3QocmVxLCAobWVzc2FnZSwgc3VjY2VzcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4oU2VydmVyLmVycm9ycy5GT1JCSURERU4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm4oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBtaWRkbGV3YXJlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpbXBvcnQgaGVsbWV0IGZyb20gXCJoZWxtZXRcIjtcbiAgICAgKlxuICAgICAqIGVuZ2luZS51c2UoaGVsbWV0KCkpO1xuICAgICAqXG4gICAgICogQHBhcmFtIGZuXG4gICAgICovXG4gICAgdXNlKGZuKSB7XG4gICAgICAgIHRoaXMubWlkZGxld2FyZXMucHVzaChmbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBtaWRkbGV3YXJlcyB0byB0aGUgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZXFcbiAgICAgKiBAcGFyYW0gcmVzXG4gICAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9hcHBseU1pZGRsZXdhcmVzKHJlcSwgcmVzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5taWRkbGV3YXJlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRlYnVnKFwibm8gbWlkZGxld2FyZSB0byBhcHBseSwgc2tpcHBpbmdcIik7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcHBseSA9IChpKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyhcImFwcGx5aW5nIG1pZGRsZXdhcmUgbsKwJWRcIiwgaSArIDEpO1xuICAgICAgICAgICAgdGhpcy5taWRkbGV3YXJlc1tpXShyZXEsIHJlcywgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IHRoaXMubWlkZGxld2FyZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGx5KGkgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGFwcGx5KDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgYWxsIGNsaWVudHMuXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGRlYnVnKFwiY2xvc2luZyBhbGwgb3BlbiBjbGllbnRzXCIpO1xuICAgICAgICBmb3IgKGxldCBpIGluIHRoaXMuY2xpZW50cykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2xpZW50cy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50c1tpXS5jbG9zZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdlbmVyYXRlIGEgc29ja2V0IGlkLlxuICAgICAqIE92ZXJ3cml0ZSB0aGlzIG1ldGhvZCB0byBnZW5lcmF0ZSB5b3VyIGN1c3RvbSBzb2NrZXQgaWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SW5jb21pbmdNZXNzYWdlfSByZXEgLSB0aGUgcmVxdWVzdCBvYmplY3RcbiAgICAgKi9cbiAgICBnZW5lcmF0ZUlkKHJlcSkge1xuICAgICAgICByZXR1cm4gYmFzZTY0aWQuZ2VuZXJhdGVJZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kc2hha2VzIGEgbmV3IGNsaWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnROYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlcSAtIHRoZSByZXF1ZXN0IG9iamVjdFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNsb3NlQ29ubmVjdGlvblxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIGhhbmRzaGFrZSh0cmFuc3BvcnROYW1lLCByZXEsIGNsb3NlQ29ubmVjdGlvbikge1xuICAgICAgICBjb25zdCBwcm90b2NvbCA9IHJlcS5fcXVlcnkuRUlPID09PSBcIjRcIiA/IDQgOiAzOyAvLyAzcmQgcmV2aXNpb24gYnkgZGVmYXVsdFxuICAgICAgICBpZiAocHJvdG9jb2wgPT09IDMgJiYgIXRoaXMub3B0cy5hbGxvd0VJTzMpIHtcbiAgICAgICAgICAgIGRlYnVnKFwidW5zdXBwb3J0ZWQgcHJvdG9jb2wgdmVyc2lvblwiKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3Rpb25fZXJyb3JcIiwge1xuICAgICAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgICAgICBjb2RlOiBTZXJ2ZXIuZXJyb3JzLlVOU1VQUE9SVEVEX1BST1RPQ09MX1ZFUlNJT04sXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogU2VydmVyLmVycm9yTWVzc2FnZXNbU2VydmVyLmVycm9ycy5VTlNVUFBPUlRFRF9QUk9UT0NPTF9WRVJTSU9OXSxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNsb3NlQ29ubmVjdGlvbihTZXJ2ZXIuZXJyb3JzLlVOU1VQUE9SVEVEX1BST1RPQ09MX1ZFUlNJT04pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlkID0gYXdhaXQgdGhpcy5nZW5lcmF0ZUlkKHJlcSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiZXJyb3Igd2hpbGUgZ2VuZXJhdGluZyBhbiBpZFwiKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3Rpb25fZXJyb3JcIiwge1xuICAgICAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgICAgICBjb2RlOiBTZXJ2ZXIuZXJyb3JzLkJBRF9SRVFVRVNULFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFNlcnZlci5lcnJvck1lc3NhZ2VzW1NlcnZlci5lcnJvcnMuQkFEX1JFUVVFU1RdLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJJRF9HRU5FUkFUSU9OX0VSUk9SXCIsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNsb3NlQ29ubmVjdGlvbihTZXJ2ZXIuZXJyb3JzLkJBRF9SRVFVRVNUKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZygnaGFuZHNoYWtpbmcgY2xpZW50IFwiJXNcIicsIGlkKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydCh0cmFuc3BvcnROYW1lLCByZXEpO1xuICAgICAgICAgICAgaWYgKFwicG9sbGluZ1wiID09PSB0cmFuc3BvcnROYW1lKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0Lm1heEh0dHBCdWZmZXJTaXplID0gdGhpcy5vcHRzLm1heEh0dHBCdWZmZXJTaXplO1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5odHRwQ29tcHJlc3Npb24gPSB0aGlzLm9wdHMuaHR0cENvbXByZXNzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoXCJ3ZWJzb2NrZXRcIiA9PT0gdHJhbnNwb3J0TmFtZSkge1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5wZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMub3B0cy5wZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZGVidWcoJ2Vycm9yIGhhbmRzaGFraW5nIHRvIHRyYW5zcG9ydCBcIiVzXCInLCB0cmFuc3BvcnROYW1lKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3Rpb25fZXJyb3JcIiwge1xuICAgICAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgICAgICBjb2RlOiBTZXJ2ZXIuZXJyb3JzLkJBRF9SRVFVRVNULFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFNlcnZlci5lcnJvck1lc3NhZ2VzW1NlcnZlci5lcnJvcnMuQkFEX1JFUVVFU1RdLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJUUkFOU1BPUlRfSEFORFNIQUtFX0VSUk9SXCIsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNsb3NlQ29ubmVjdGlvbihTZXJ2ZXIuZXJyb3JzLkJBRF9SRVFVRVNUKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb2NrZXQgPSBuZXcgc29ja2V0XzEuU29ja2V0KGlkLCB0aGlzLCB0cmFuc3BvcnQsIHJlcSwgcHJvdG9jb2wpO1xuICAgICAgICB0cmFuc3BvcnQub24oXCJoZWFkZXJzXCIsIChoZWFkZXJzLCByZXEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlzSW5pdGlhbFJlcXVlc3QgPSAhcmVxLl9xdWVyeS5zaWQ7XG4gICAgICAgICAgICBpZiAoaXNJbml0aWFsUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuY29va2llKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbXCJTZXQtQ29va2llXCJdID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGNvb2tpZV8xLnNlcmlhbGl6ZSkodGhpcy5vcHRzLmNvb2tpZS5uYW1lLCBpZCwgdGhpcy5vcHRzLmNvb2tpZSksXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImluaXRpYWxfaGVhZGVyc1wiLCBoZWFkZXJzLCByZXEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KFwiaGVhZGVyc1wiLCBoZWFkZXJzLCByZXEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdHJhbnNwb3J0Lm9uUmVxdWVzdChyZXEpO1xuICAgICAgICB0aGlzLmNsaWVudHNbaWRdID0gc29ja2V0O1xuICAgICAgICB0aGlzLmNsaWVudHNDb3VudCsrO1xuICAgICAgICBzb2NrZXQub25jZShcImNsb3NlXCIsICgpID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNsaWVudHNbaWRdO1xuICAgICAgICAgICAgdGhpcy5jbGllbnRzQ291bnQtLTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3Rpb25cIiwgc29ja2V0KTtcbiAgICAgICAgcmV0dXJuIHRyYW5zcG9ydDtcbiAgICB9XG4gICAgYXN5bmMgb25XZWJUcmFuc3BvcnRTZXNzaW9uKHNlc3Npb24pIHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZGVidWcoXCJ0aGUgY2xpZW50IGZhaWxlZCB0byBlc3RhYmxpc2ggYSBiaWRpcmVjdGlvbmFsIHN0cmVhbSBpbiB0aGUgZ2l2ZW4gcGVyaW9kXCIpO1xuICAgICAgICAgICAgc2Vzc2lvbi5jbG9zZSgpO1xuICAgICAgICB9LCB0aGlzLm9wdHMudXBncmFkZVRpbWVvdXQpO1xuICAgICAgICBjb25zdCBzdHJlYW1SZWFkZXIgPSBzZXNzaW9uLmluY29taW5nQmlkaXJlY3Rpb25hbFN0cmVhbXMuZ2V0UmVhZGVyKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN0cmVhbVJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgZGVidWcoXCJzZXNzaW9uIGlzIGNsb3NlZFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJlYW0gPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybVN0cmVhbSA9ICgwLCBlbmdpbmVfaW9fcGFyc2VyXzEuY3JlYXRlUGFja2V0RGVjb2RlclN0cmVhbSkodGhpcy5vcHRzLm1heEh0dHBCdWZmZXJTaXplLCBcIm5vZGVidWZmZXJcIik7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5yZWFkYWJsZS5waXBlVGhyb3VnaCh0cmFuc2Zvcm1TdHJlYW0pLmdldFJlYWRlcigpO1xuICAgICAgICAvLyByZWFkaW5nIHRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHN0cmVhbVxuICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgZGVidWcoXCJzdHJlYW0gaXMgY2xvc2VkXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IFwib3BlblwiKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImludmFsaWQgV2ViVHJhbnNwb3J0IGhhbmRzaGFrZVwiKTtcbiAgICAgICAgICAgIHJldHVybiBzZXNzaW9uLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLmRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNwb3J0ID0gbmV3IHdlYnRyYW5zcG9ydF8xLldlYlRyYW5zcG9ydChzZXNzaW9uLCBzdHJlYW0sIHJlYWRlcik7XG4gICAgICAgICAgICAvLyBub3RlOiB3ZSBjYW5ub3QgdXNlIFwidGhpcy5nZW5lcmF0ZUlkKClcIiwgYmVjYXVzZSB0aGVyZSBpcyBubyBcInJlcVwiIGFyZ3VtZW50XG4gICAgICAgICAgICBjb25zdCBpZCA9IGJhc2U2NGlkLmdlbmVyYXRlSWQoKTtcbiAgICAgICAgICAgIGRlYnVnKCdoYW5kc2hha2luZyBjbGllbnQgXCIlc1wiIChXZWJUcmFuc3BvcnQpJywgaWQpO1xuICAgICAgICAgICAgY29uc3Qgc29ja2V0ID0gbmV3IHNvY2tldF8xLlNvY2tldChpZCwgdGhpcywgdHJhbnNwb3J0LCBudWxsLCA0KTtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50c1tpZF0gPSBzb2NrZXQ7XG4gICAgICAgICAgICB0aGlzLmNsaWVudHNDb3VudCsrO1xuICAgICAgICAgICAgc29ja2V0Lm9uY2UoXCJjbG9zZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2xpZW50c1tpZF07XG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnRzQ291bnQtLTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdGlvblwiLCBzb2NrZXQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZCA9IHBhcnNlU2Vzc2lvbklkKHZhbHVlLmRhdGEpO1xuICAgICAgICBpZiAoIXNpZCkge1xuICAgICAgICAgICAgZGVidWcoXCJpbnZhbGlkIFdlYlRyYW5zcG9ydCBoYW5kc2hha2VcIik7XG4gICAgICAgICAgICByZXR1cm4gc2Vzc2lvbi5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50c1tzaWRdO1xuICAgICAgICBpZiAoIWNsaWVudCkge1xuICAgICAgICAgICAgZGVidWcoXCJ1cGdyYWRlIGF0dGVtcHQgZm9yIGNsb3NlZCBjbGllbnRcIik7XG4gICAgICAgICAgICBzZXNzaW9uLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2xpZW50LnVwZ3JhZGluZykge1xuICAgICAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgaGFzIGFscmVhZHkgYmVlbiB0cnlpbmcgdG8gdXBncmFkZVwiKTtcbiAgICAgICAgICAgIHNlc3Npb24uY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbGllbnQudXBncmFkZWQpIHtcbiAgICAgICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IGhhZCBhbHJlYWR5IGJlZW4gdXBncmFkZWRcIik7XG4gICAgICAgICAgICBzZXNzaW9uLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInVwZ3JhZGluZyBleGlzdGluZyB0cmFuc3BvcnRcIik7XG4gICAgICAgICAgICBjb25zdCB0cmFuc3BvcnQgPSBuZXcgd2VidHJhbnNwb3J0XzEuV2ViVHJhbnNwb3J0KHNlc3Npb24sIHN0cmVhbSwgcmVhZGVyKTtcbiAgICAgICAgICAgIGNsaWVudC5fbWF5YmVVcGdyYWRlKHRyYW5zcG9ydCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkJhc2VTZXJ2ZXIgPSBCYXNlU2VydmVyO1xuLyoqXG4gKiBQcm90b2NvbCBlcnJvcnMgbWFwcGluZ3MuXG4gKi9cbkJhc2VTZXJ2ZXIuZXJyb3JzID0ge1xuICAgIFVOS05PV05fVFJBTlNQT1JUOiAwLFxuICAgIFVOS05PV05fU0lEOiAxLFxuICAgIEJBRF9IQU5EU0hBS0VfTUVUSE9EOiAyLFxuICAgIEJBRF9SRVFVRVNUOiAzLFxuICAgIEZPUkJJRERFTjogNCxcbiAgICBVTlNVUFBPUlRFRF9QUk9UT0NPTF9WRVJTSU9OOiA1LFxufTtcbkJhc2VTZXJ2ZXIuZXJyb3JNZXNzYWdlcyA9IHtcbiAgICAwOiBcIlRyYW5zcG9ydCB1bmtub3duXCIsXG4gICAgMTogXCJTZXNzaW9uIElEIHVua25vd25cIixcbiAgICAyOiBcIkJhZCBoYW5kc2hha2UgbWV0aG9kXCIsXG4gICAgMzogXCJCYWQgcmVxdWVzdFwiLFxuICAgIDQ6IFwiRm9yYmlkZGVuXCIsXG4gICAgNTogXCJVbnN1cHBvcnRlZCBwcm90b2NvbCB2ZXJzaW9uXCIsXG59O1xuLyoqXG4gKiBFeHBvc2VzIGEgc3Vic2V0IG9mIHRoZSBodHRwLlNlcnZlclJlc3BvbnNlIGludGVyZmFjZSwgaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBhcHBseSB0aGUgbWlkZGxld2FyZXMgdG8gYW4gdXBncmFkZVxuICogcmVxdWVzdC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2NsYXNzLWh0dHBzZXJ2ZXJyZXNwb25zZVxuICovXG5jbGFzcyBXZWJTb2NrZXRSZXNwb25zZSB7XG4gICAgY29uc3RydWN0b3IocmVxLCBzb2NrZXQpIHtcbiAgICAgICAgdGhpcy5yZXEgPSByZXE7XG4gICAgICAgIHRoaXMuc29ja2V0ID0gc29ja2V0O1xuICAgICAgICAvLyB0ZW1wb3JhcmlseSBzdG9yZSB0aGUgcmVzcG9uc2UgaGVhZGVycyBvbiB0aGUgcmVxIG9iamVjdCAoc2VlIHRoZSBcImhlYWRlcnNcIiBldmVudClcbiAgICAgICAgcmVxW2tSZXNwb25zZUhlYWRlcnNdID0ge307XG4gICAgfVxuICAgIHNldEhlYWRlcihuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnJlcVtrUmVzcG9uc2VIZWFkZXJzXVtuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXRIZWFkZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXFba1Jlc3BvbnNlSGVhZGVyc11bbmFtZV07XG4gICAgfVxuICAgIHJlbW92ZUhlYWRlcihuYW1lKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnJlcVtrUmVzcG9uc2VIZWFkZXJzXVtuYW1lXTtcbiAgICB9XG4gICAgd3JpdGUoKSB7IH1cbiAgICB3cml0ZUhlYWQoKSB7IH1cbiAgICBlbmQoKSB7XG4gICAgICAgIC8vIHdlIGNvdWxkIHJldHVybiBhIHByb3BlciBlcnJvciBjb2RlLCBidXQgdGhlIFdlYlNvY2tldCBjbGllbnQgd2lsbCBlbWl0IGFuIFwiZXJyb3JcIiBldmVudCBhbnl3YXkuXG4gICAgICAgIHRoaXMuc29ja2V0LmRlc3Ryb3koKTtcbiAgICB9XG59XG4vKipcbiAqIEFuIEVuZ2luZS5JTyBzZXJ2ZXIgYmFzZWQgb24gTm9kZS5qcyBidWlsdC1pbiBIVFRQIHNlcnZlciBhbmQgdGhlIGB3c2AgcGFja2FnZSBmb3IgV2ViU29ja2V0IGNvbm5lY3Rpb25zLlxuICovXG5jbGFzcyBTZXJ2ZXIgZXh0ZW5kcyBCYXNlU2VydmVyIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHdlYnNvY2tldCBzZXJ2ZXJcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpbml0KCkge1xuICAgICAgICBpZiAoIX50aGlzLm9wdHMudHJhbnNwb3J0cy5pbmRleE9mKFwid2Vic29ja2V0XCIpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy53cylcbiAgICAgICAgICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgICAgICAgdGhpcy53cyA9IG5ldyB0aGlzLm9wdHMud3NFbmdpbmUoe1xuICAgICAgICAgICAgbm9TZXJ2ZXI6IHRydWUsXG4gICAgICAgICAgICBjbGllbnRUcmFja2luZzogZmFsc2UsXG4gICAgICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZTogdGhpcy5vcHRzLnBlck1lc3NhZ2VEZWZsYXRlLFxuICAgICAgICAgICAgbWF4UGF5bG9hZDogdGhpcy5vcHRzLm1heEh0dHBCdWZmZXJTaXplLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLndzLm9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMud3Mub24oXCJoZWFkZXJzXCIsIChoZWFkZXJzQXJyYXksIHJlcSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIG5vdGU6ICd3cycgdXNlcyBhbiBhcnJheSBvZiBoZWFkZXJzLCB3aGlsZSBFbmdpbmUuSU8gdXNlcyBhbiBvYmplY3QgKHJlc3BvbnNlLndyaXRlSGVhZCgpIGFjY2VwdHMgYm90aCBmb3JtYXRzKVxuICAgICAgICAgICAgICAgIC8vIHdlIGNvdWxkIGFsc28gdHJ5IHRvIHBhcnNlIHRoZSBhcnJheSBhbmQgdGhlbiBzeW5jIHRoZSB2YWx1ZXMsIGJ1dCB0aGF0IHdpbGwgYmUgZXJyb3ItcHJvbmVcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRpdGlvbmFsSGVhZGVycyA9IHJlcVtrUmVzcG9uc2VIZWFkZXJzXSB8fCB7fTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVxW2tSZXNwb25zZUhlYWRlcnNdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzSW5pdGlhbFJlcXVlc3QgPSAhcmVxLl9xdWVyeS5zaWQ7XG4gICAgICAgICAgICAgICAgaWYgKGlzSW5pdGlhbFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiaW5pdGlhbF9oZWFkZXJzXCIsIGFkZGl0aW9uYWxIZWFkZXJzLCByZXEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJoZWFkZXJzXCIsIGFkZGl0aW9uYWxIZWFkZXJzLCByZXEpO1xuICAgICAgICAgICAgICAgIGRlYnVnKFwid3JpdGluZyBoZWFkZXJzOiAlalwiLCBhZGRpdGlvbmFsSGVhZGVycyk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoYWRkaXRpb25hbEhlYWRlcnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzQXJyYXkucHVzaChgJHtrZXl9OiAke2FkZGl0aW9uYWxIZWFkZXJzW2tleV19YCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhbnVwKCkge1xuICAgICAgICBpZiAodGhpcy53cykge1xuICAgICAgICAgICAgZGVidWcoXCJjbG9zaW5nIHdlYlNvY2tldFNlcnZlclwiKTtcbiAgICAgICAgICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgICAgICAgICAgIC8vIGRvbid0IGRlbGV0ZSB0aGlzLndzIGJlY2F1c2UgaXQgY2FuIGJlIHVzZWQgYWdhaW4gaWYgdGhlIGh0dHAgc2VydmVyIHN0YXJ0cyBsaXN0ZW5pbmcgYWdhaW5cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlcyBhIHJlcXVlc3QgYnkgcHJvY2Vzc2luZyB0aGUgcXVlcnkgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwcmVwYXJlKHJlcSkge1xuICAgICAgICAvLyB0cnkgdG8gbGV2ZXJhZ2UgcHJlLWV4aXN0aW5nIGByZXEuX3F1ZXJ5YCAoZS5nOiBmcm9tIGNvbm5lY3QpXG4gICAgICAgIGlmICghcmVxLl9xdWVyeSkge1xuICAgICAgICAgICAgcmVxLl9xdWVyeSA9ICh+cmVxLnVybC5pbmRleE9mKFwiP1wiKSA/IHFzLnBhcnNlKCgwLCB1cmxfMS5wYXJzZSkocmVxLnVybCkucXVlcnkpIDoge30pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZVRyYW5zcG9ydCh0cmFuc3BvcnROYW1lLCByZXEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0cmFuc3BvcnRzXzEuZGVmYXVsdFt0cmFuc3BvcnROYW1lXShyZXEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGFuIEVuZ2luZS5JTyBIVFRQIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VuZ2luZVJlcXVlc3R9IHJlcVxuICAgICAqIEBwYXJhbSB7U2VydmVyUmVzcG9uc2V9IHJlc1xuICAgICAqL1xuICAgIGhhbmRsZVJlcXVlc3QocmVxLCByZXMpIHtcbiAgICAgICAgZGVidWcoJ2hhbmRsaW5nIFwiJXNcIiBodHRwIHJlcXVlc3QgXCIlc1wiJywgcmVxLm1ldGhvZCwgcmVxLnVybCk7XG4gICAgICAgIHRoaXMucHJlcGFyZShyZXEpO1xuICAgICAgICByZXEucmVzID0gcmVzO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IChlcnJvckNvZGUsIGVycm9yQ29udGV4dCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycm9yQ29kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdGlvbl9lcnJvclwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogZXJyb3JDb2RlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBTZXJ2ZXIuZXJyb3JNZXNzYWdlc1tlcnJvckNvZGVdLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBlcnJvckNvbnRleHQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYWJvcnRSZXF1ZXN0KHJlcywgZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXEuX3F1ZXJ5LnNpZCkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwic2V0dGluZyBuZXcgcmVxdWVzdCBmb3IgZXhpc3RpbmcgY2xpZW50XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50c1tyZXEuX3F1ZXJ5LnNpZF0udHJhbnNwb3J0Lm9uUmVxdWVzdChyZXEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xvc2VDb25uZWN0aW9uID0gKGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KSA9PiBhYm9ydFJlcXVlc3QocmVzLCBlcnJvckNvZGUsIGVycm9yQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kc2hha2UocmVxLl9xdWVyeS50cmFuc3BvcnQsIHJlcSwgY2xvc2VDb25uZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fYXBwbHlNaWRkbGV3YXJlcyhyZXEsIHJlcywgKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKFNlcnZlci5lcnJvcnMuQkFEX1JFUVVFU1QsIHsgbmFtZTogXCJNSURETEVXQVJFX0ZBSUxVUkVcIiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudmVyaWZ5KHJlcSwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgYW4gRW5naW5lLklPIEhUVFAgVXBncmFkZS5cbiAgICAgKi9cbiAgICBoYW5kbGVVcGdyYWRlKHJlcSwgc29ja2V0LCB1cGdyYWRlSGVhZCkge1xuICAgICAgICB0aGlzLnByZXBhcmUocmVxKTtcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFdlYlNvY2tldFJlc3BvbnNlKHJlcSwgc29ja2V0KTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAoZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvckNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3Rpb25fZXJyb3JcIiwge1xuICAgICAgICAgICAgICAgICAgICByZXEsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGVycm9yQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogU2VydmVyLmVycm9yTWVzc2FnZXNbZXJyb3JDb2RlXSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogZXJyb3JDb250ZXh0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFib3J0VXBncmFkZShzb2NrZXQsIGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkID0gQnVmZmVyLmZyb20odXBncmFkZUhlYWQpO1xuICAgICAgICAgICAgdXBncmFkZUhlYWQgPSBudWxsO1xuICAgICAgICAgICAgLy8gc29tZSBtaWRkbGV3YXJlcyAobGlrZSBleHByZXNzLXNlc3Npb24pIHdhaXQgZm9yIHRoZSB3cml0ZUhlYWQoKSBjYWxsIHRvIGZsdXNoIHRoZWlyIGhlYWRlcnNcbiAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXhwcmVzc2pzL3Nlc3Npb24vYmxvYi8xMDEwZmFkYzJmMDcxZGRmMmFkZDk0MjM1ZDcyMjI0Y2Y2NTE1OWM2L2luZGV4LmpzI0wyMjAtTDI0NFxuICAgICAgICAgICAgcmVzLndyaXRlSGVhZCgpO1xuICAgICAgICAgICAgLy8gZGVsZWdhdGUgdG8gd3NcbiAgICAgICAgICAgIHRoaXMud3MuaGFuZGxlVXBncmFkZShyZXEsIHNvY2tldCwgaGVhZCwgKHdlYnNvY2tldCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25XZWJTb2NrZXQocmVxLCBzb2NrZXQsIHdlYnNvY2tldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fYXBwbHlNaWRkbGV3YXJlcyhyZXEsIHJlcywgKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKFNlcnZlci5lcnJvcnMuQkFEX1JFUVVFU1QsIHsgbmFtZTogXCJNSURETEVXQVJFX0ZBSUxVUkVcIiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudmVyaWZ5KHJlcSwgdHJ1ZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gYSB3cy5pbyBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt3cy5Tb2NrZXR9IHdlYnNvY2tldFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25XZWJTb2NrZXQocmVxLCBzb2NrZXQsIHdlYnNvY2tldCkge1xuICAgICAgICB3ZWJzb2NrZXQub24oXCJlcnJvclwiLCBvblVwZ3JhZGVFcnJvcik7XG4gICAgICAgIGlmICh0cmFuc3BvcnRzXzEuZGVmYXVsdFtyZXEuX3F1ZXJ5LnRyYW5zcG9ydF0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgIXRyYW5zcG9ydHNfMS5kZWZhdWx0W3JlcS5fcXVlcnkudHJhbnNwb3J0XS5wcm90b3R5cGUuaGFuZGxlc1VwZ3JhZGVzKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInRyYW5zcG9ydCBkb2VzbnQgaGFuZGxlIHVwZ3JhZGVkIHJlcXVlc3RzXCIpO1xuICAgICAgICAgICAgd2Vic29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ2V0IGNsaWVudCBpZFxuICAgICAgICBjb25zdCBpZCA9IHJlcS5fcXVlcnkuc2lkO1xuICAgICAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSB3cy5Tb2NrZXRcbiAgICAgICAgcmVxLndlYnNvY2tldCA9IHdlYnNvY2tldDtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudHNbaWRdO1xuICAgICAgICAgICAgaWYgKCFjbGllbnQpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInVwZ3JhZGUgYXR0ZW1wdCBmb3IgY2xvc2VkIGNsaWVudFwiKTtcbiAgICAgICAgICAgICAgICB3ZWJzb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNsaWVudC51cGdyYWRpbmcpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInRyYW5zcG9ydCBoYXMgYWxyZWFkeSBiZWVuIHRyeWluZyB0byB1cGdyYWRlXCIpO1xuICAgICAgICAgICAgICAgIHdlYnNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2xpZW50LnVwZ3JhZGVkKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgaGFkIGFscmVhZHkgYmVlbiB1cGdyYWRlZFwiKTtcbiAgICAgICAgICAgICAgICB3ZWJzb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwidXBncmFkaW5nIGV4aXN0aW5nIHRyYW5zcG9ydFwiKTtcbiAgICAgICAgICAgICAgICAvLyB0cmFuc3BvcnQgZXJyb3IgaGFuZGxpbmcgdGFrZXMgb3ZlclxuICAgICAgICAgICAgICAgIHdlYnNvY2tldC5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIG9uVXBncmFkZUVycm9yKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydChyZXEuX3F1ZXJ5LnRyYW5zcG9ydCwgcmVxKTtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQucGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLm9wdHMucGVyTWVzc2FnZURlZmxhdGU7XG4gICAgICAgICAgICAgICAgY2xpZW50Ll9tYXliZVVwZ3JhZGUodHJhbnNwb3J0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNsb3NlQ29ubmVjdGlvbiA9IChlcnJvckNvZGUsIGVycm9yQ29udGV4dCkgPT4gYWJvcnRVcGdyYWRlKHNvY2tldCwgZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpO1xuICAgICAgICAgICAgdGhpcy5oYW5kc2hha2UocmVxLl9xdWVyeS50cmFuc3BvcnQsIHJlcSwgY2xvc2VDb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvblVwZ3JhZGVFcnJvcigpIHtcbiAgICAgICAgICAgIGRlYnVnKFwid2Vic29ja2V0IGVycm9yIGJlZm9yZSB1cGdyYWRlXCIpO1xuICAgICAgICAgICAgLy8gd2Vic29ja2V0LmNsb3NlKCkgbm90IG5lZWRlZFxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhcHR1cmVzIHVwZ3JhZGUgcmVxdWVzdHMgZm9yIGEgaHR0cC5TZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2h0dHAuU2VydmVyfSBzZXJ2ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICAgIGF0dGFjaChzZXJ2ZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5fY29tcHV0ZVBhdGgob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRlc3Ryb3lVcGdyYWRlVGltZW91dCA9IG9wdGlvbnMuZGVzdHJveVVwZ3JhZGVUaW1lb3V0IHx8IDEwMDA7XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrKHJlcSkge1xuICAgICAgICAgICAgLy8gVE9ETyB1c2UgYHBhdGggPT09IG5ldyBVUkwoLi4uKS5wYXRobmFtZWAgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZSAocmVmOiBodHRwczovL25vZGVqcy5vcmcvYXBpL3VybC5odG1sKVxuICAgICAgICAgICAgcmV0dXJuIHBhdGggPT09IHJlcS51cmwuc2xpY2UoMCwgcGF0aC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhY2hlIGFuZCBjbGVhbiB1cCBsaXN0ZW5lcnNcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gc2VydmVyLmxpc3RlbmVycyhcInJlcXVlc3RcIikuc2xpY2UoMCk7XG4gICAgICAgIHNlcnZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJyZXF1ZXN0XCIpO1xuICAgICAgICBzZXJ2ZXIub24oXCJjbG9zZVwiLCB0aGlzLmNsb3NlLmJpbmQodGhpcykpO1xuICAgICAgICBzZXJ2ZXIub24oXCJsaXN0ZW5pbmdcIiwgdGhpcy5pbml0LmJpbmQodGhpcykpO1xuICAgICAgICAvLyBhZGQgcmVxdWVzdCBoYW5kbGVyXG4gICAgICAgIHNlcnZlci5vbihcInJlcXVlc3RcIiwgKHJlcSwgcmVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hlY2socmVxKSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdpbnRlcmNlcHRpbmcgcmVxdWVzdCBmb3IgcGF0aCBcIiVzXCInLCBwYXRoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJlcXVlc3QocmVxLCByZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGwgPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlcnZlciwgcmVxLCByZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh+dGhpcy5vcHRzLnRyYW5zcG9ydHMuaW5kZXhPZihcIndlYnNvY2tldFwiKSkge1xuICAgICAgICAgICAgc2VydmVyLm9uKFwidXBncmFkZVwiLCAocmVxLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2socmVxKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVVwZ3JhZGUocmVxLCBzb2NrZXQsIGhlYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmYWxzZSAhPT0gb3B0aW9ucy5kZXN0cm95VXBncmFkZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IG5vZGUgYmVoYXZpb3IgaXMgdG8gZGlzY29ubmVjdCB3aGVuIG5vIGhhbmRsZXJzXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBieSBhZGRpbmcgYSBoYW5kbGVyLCB3ZSBwcmV2ZW50IHRoYXRcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGlmIG5vIGVpbyB0aGluZyBoYW5kbGVzIHRoZSB1cGdyYWRlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gdGhlIHNvY2tldCBuZWVkcyB0byBkaWUhXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvY2tldC53cml0YWJsZSAmJiBzb2NrZXQuYnl0ZXNXcml0dGVuIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQub24oXCJlcnJvclwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcImVycm9yIHdoaWxlIGRlc3Ryb3lpbmcgdXBncmFkZTogJXNcIiwgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29ja2V0LmVuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBkZXN0cm95VXBncmFkZVRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2ZXIgPSBTZXJ2ZXI7XG4vKipcbiAqIENsb3NlIHRoZSBIVFRQIGxvbmctcG9sbGluZyByZXF1ZXN0XG4gKlxuICogQHBhcmFtIHJlcyAtIHRoZSByZXNwb25zZSBvYmplY3RcbiAqIEBwYXJhbSBlcnJvckNvZGUgLSB0aGUgZXJyb3IgY29kZVxuICogQHBhcmFtIGVycm9yQ29udGV4dCAtIGFkZGl0aW9uYWwgZXJyb3IgY29udGV4dFxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0UmVxdWVzdChyZXMsIGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KSB7XG4gICAgY29uc3Qgc3RhdHVzQ29kZSA9IGVycm9yQ29kZSA9PT0gU2VydmVyLmVycm9ycy5GT1JCSURERU4gPyA0MDMgOiA0MDA7XG4gICAgY29uc3QgbWVzc2FnZSA9IGVycm9yQ29udGV4dCAmJiBlcnJvckNvbnRleHQubWVzc2FnZVxuICAgICAgICA/IGVycm9yQ29udGV4dC5tZXNzYWdlXG4gICAgICAgIDogU2VydmVyLmVycm9yTWVzc2FnZXNbZXJyb3JDb2RlXTtcbiAgICByZXMud3JpdGVIZWFkKHN0YXR1c0NvZGUsIHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSk7XG4gICAgcmVzLmVuZChKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGNvZGU6IGVycm9yQ29kZSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICB9KSk7XG59XG4vKipcbiAqIENsb3NlIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvblxuICpcbiAqIEBwYXJhbSB7bmV0LlNvY2tldH0gc29ja2V0XG4gKiBAcGFyYW0ge3N0cmluZ30gZXJyb3JDb2RlIC0gdGhlIGVycm9yIGNvZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBlcnJvckNvbnRleHQgLSBhZGRpdGlvbmFsIGVycm9yIGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gYWJvcnRVcGdyYWRlKHNvY2tldCwgZXJyb3JDb2RlLCBlcnJvckNvbnRleHQgPSB7fSkge1xuICAgIHNvY2tldC5vbihcImVycm9yXCIsICgpID0+IHtcbiAgICAgICAgZGVidWcoXCJpZ25vcmluZyBlcnJvciBmcm9tIGNsb3NlZCBjb25uZWN0aW9uXCIpO1xuICAgIH0pO1xuICAgIGlmIChzb2NrZXQud3JpdGFibGUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGVycm9yQ29udGV4dC5tZXNzYWdlIHx8IFNlcnZlci5lcnJvck1lc3NhZ2VzW2Vycm9yQ29kZV07XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKG1lc3NhZ2UpO1xuICAgICAgICBzb2NrZXQud3JpdGUoXCJIVFRQLzEuMSA0MDAgQmFkIFJlcXVlc3RcXHJcXG5cIiArXG4gICAgICAgICAgICBcIkNvbm5lY3Rpb246IGNsb3NlXFxyXFxuXCIgK1xuICAgICAgICAgICAgXCJDb250ZW50LXR5cGU6IHRleHQvaHRtbFxcclxcblwiICtcbiAgICAgICAgICAgIFwiQ29udGVudC1MZW5ndGg6IFwiICtcbiAgICAgICAgICAgIGxlbmd0aCArXG4gICAgICAgICAgICBcIlxcclxcblwiICtcbiAgICAgICAgICAgIFwiXFxyXFxuXCIgK1xuICAgICAgICAgICAgbWVzc2FnZSk7XG4gICAgfVxuICAgIHNvY2tldC5kZXN0cm95KCk7XG59XG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3Y4LjQuMC9saWIvX2h0dHBfY29tbW9uLmpzI0wzMDMtTDM1NFxuICpcbiAqIFRydWUgaWYgdmFsIGNvbnRhaW5zIGFuIGludmFsaWQgZmllbGQtdmNoYXJcbiAqICBmaWVsZC12YWx1ZSAgICA9ICooIGZpZWxkLWNvbnRlbnQgLyBvYnMtZm9sZCApXG4gKiAgZmllbGQtY29udGVudCAgPSBmaWVsZC12Y2hhciBbIDEqKCBTUCAvIEhUQUIgKSBmaWVsZC12Y2hhciBdXG4gKiAgZmllbGQtdmNoYXIgICAgPSBWQ0hBUiAvIG9icy10ZXh0XG4gKlxuICogY2hlY2tJbnZhbGlkSGVhZGVyQ2hhcigpIGlzIGN1cnJlbnRseSBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUgYnkgdjgsXG4gKiBzbyB0YWtlIGNhcmUgd2hlbiBtYWtpbmcgY2hhbmdlcyB0byB0aGUgaW1wbGVtZW50YXRpb24gc28gdGhhdCB0aGUgc291cmNlXG4gKiBjb2RlIHNpemUgZG9lcyBub3QgZXhjZWVkIHY4J3MgZGVmYXVsdCBtYXhfaW5saW5lZF9zb3VyY2Vfc2l6ZSBzZXR0aW5nLlxuICoqL1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB2YWxpZEhkckNoYXJzID0gW1xuICAgIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDAgLSAxNVxuICAgIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDE2IC0gMzFcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyAzMiAtIDQ3XG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gNDggLSA2M1xuICAgIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIC8vIDY0IC0gNzlcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyA4MCAtIDk1XG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gOTYgLSAxMTFcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAvLyAxMTIgLSAxMjdcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyAxMjggLi4uXG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuICAgIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsXG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuICAgIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsXG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSAvLyAuLi4gMjU1XG5dO1xuZnVuY3Rpb24gY2hlY2tJbnZhbGlkSGVhZGVyQ2hhcih2YWwpIHtcbiAgICB2YWwgKz0gXCJcIjtcbiAgICBpZiAodmFsLmxlbmd0aCA8IDEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIXZhbGlkSGRyQ2hhcnNbdmFsLmNoYXJDb2RlQXQoMCldKSB7XG4gICAgICAgIGRlYnVnKCdpbnZhbGlkIGhlYWRlciwgaW5kZXggMCwgY2hhciBcIiVzXCInLCB2YWwuY2hhckNvZGVBdCgwKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA8IDIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIXZhbGlkSGRyQ2hhcnNbdmFsLmNoYXJDb2RlQXQoMSldKSB7XG4gICAgICAgIGRlYnVnKCdpbnZhbGlkIGhlYWRlciwgaW5kZXggMSwgY2hhciBcIiVzXCInLCB2YWwuY2hhckNvZGVBdCgxKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA8IDMpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIXZhbGlkSGRyQ2hhcnNbdmFsLmNoYXJDb2RlQXQoMildKSB7XG4gICAgICAgIGRlYnVnKCdpbnZhbGlkIGhlYWRlciwgaW5kZXggMiwgY2hhciBcIiVzXCInLCB2YWwuY2hhckNvZGVBdCgyKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA8IDQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIXZhbGlkSGRyQ2hhcnNbdmFsLmNoYXJDb2RlQXQoMyldKSB7XG4gICAgICAgIGRlYnVnKCdpbnZhbGlkIGhlYWRlciwgaW5kZXggMywgY2hhciBcIiVzXCInLCB2YWwuY2hhckNvZGVBdCgzKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gNDsgaSA8IHZhbC5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoIXZhbGlkSGRyQ2hhcnNbdmFsLmNoYXJDb2RlQXQoaSldKSB7XG4gICAgICAgICAgICBkZWJ1ZygnaW52YWxpZCBoZWFkZXIsIGluZGV4IFwiJWlcIiwgY2hhciBcIiVzXCInLCBpLCB2YWwuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/engine.io/build/server.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/engine.io/build/socket.js":
/*!*************************************************!*\
  !*** ../node_modules/engine.io/build/socket.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Socket = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/../node_modules/engine.io/node_modules/debug/src/index.js\");\nconst timers_1 = __webpack_require__(/*! timers */ \"timers\");\nconst debug = (0, debug_1.default)(\"engine:socket\");\nclass Socket extends events_1.EventEmitter {\n    get readyState() {\n        return this._readyState;\n    }\n    set readyState(state) {\n        debug(\"readyState updated from %s to %s\", this._readyState, state);\n        this._readyState = state;\n    }\n    constructor(id, server, transport, req, protocol) {\n        super();\n        /**\n         * The current state of the socket.\n         */\n        this._readyState = \"opening\";\n        /* private */ this.upgrading = false;\n        /* private */ this.upgraded = false;\n        this.writeBuffer = [];\n        this.packetsFn = [];\n        this.sentCallbackFn = [];\n        this.cleanupFn = [];\n        this.id = id;\n        this.server = server;\n        this.request = req;\n        this.protocol = protocol;\n        // Cache IP since it might not be in the req later\n        if (req) {\n            if (req.websocket && req.websocket._socket) {\n                this.remoteAddress = req.websocket._socket.remoteAddress;\n            }\n            else {\n                this.remoteAddress = req.connection.remoteAddress;\n            }\n        }\n        else {\n            // TODO there is currently no way to get the IP address of the client when it connects with WebTransport\n            //  see https://github.com/fails-components/webtransport/issues/114\n        }\n        this.pingTimeoutTimer = null;\n        this.pingIntervalTimer = null;\n        this.setTransport(transport);\n        this.onOpen();\n    }\n    /**\n     * Called upon transport considered open.\n     *\n     * @private\n     */\n    onOpen() {\n        this.readyState = \"open\";\n        // sends an `open` packet\n        this.transport.sid = this.id;\n        this.sendPacket(\"open\", JSON.stringify({\n            sid: this.id,\n            upgrades: this.getAvailableUpgrades(),\n            pingInterval: this.server.opts.pingInterval,\n            pingTimeout: this.server.opts.pingTimeout,\n            maxPayload: this.server.opts.maxHttpBufferSize,\n        }));\n        if (this.server.opts.initialPacket) {\n            this.sendPacket(\"message\", this.server.opts.initialPacket);\n        }\n        this.emit(\"open\");\n        if (this.protocol === 3) {\n            // in protocol v3, the client sends a ping, and the server answers with a pong\n            this.resetPingTimeout();\n        }\n        else {\n            // in protocol v4, the server sends a ping, and the client answers with a pong\n            this.schedulePing();\n        }\n    }\n    /**\n     * Called upon transport packet.\n     *\n     * @param {Object} packet\n     * @private\n     */\n    onPacket(packet) {\n        if (\"open\" !== this.readyState) {\n            return debug(\"packet received with closed socket\");\n        }\n        // export packet event\n        debug(`received packet ${packet.type}`);\n        this.emit(\"packet\", packet);\n        switch (packet.type) {\n            case \"ping\":\n                if (this.transport.protocol !== 3) {\n                    this.onError(new Error(\"invalid heartbeat direction\"));\n                    return;\n                }\n                debug(\"got ping\");\n                this.pingTimeoutTimer.refresh();\n                this.sendPacket(\"pong\");\n                this.emit(\"heartbeat\");\n                break;\n            case \"pong\":\n                if (this.transport.protocol === 3) {\n                    this.onError(new Error(\"invalid heartbeat direction\"));\n                    return;\n                }\n                debug(\"got pong\");\n                (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n                this.pingIntervalTimer.refresh();\n                this.emit(\"heartbeat\");\n                break;\n            case \"error\":\n                this.onClose(\"parse error\");\n                break;\n            case \"message\":\n                this.emit(\"data\", packet.data);\n                this.emit(\"message\", packet.data);\n                break;\n        }\n    }\n    /**\n     * Called upon transport error.\n     *\n     * @param {Error} err - error object\n     * @private\n     */\n    onError(err) {\n        debug(\"transport error\");\n        this.onClose(\"transport error\", err);\n    }\n    /**\n     * Pings client every `this.pingInterval` and expects response\n     * within `this.pingTimeout` or closes connection.\n     *\n     * @private\n     */\n    schedulePing() {\n        this.pingIntervalTimer = (0, timers_1.setTimeout)(() => {\n            debug(\"writing ping packet - expecting pong within %sms\", this.server.opts.pingTimeout);\n            this.sendPacket(\"ping\");\n            this.resetPingTimeout();\n        }, this.server.opts.pingInterval);\n    }\n    /**\n     * Resets ping timeout.\n     *\n     * @private\n     */\n    resetPingTimeout() {\n        (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n        this.pingTimeoutTimer = (0, timers_1.setTimeout)(() => {\n            if (this.readyState === \"closed\")\n                return;\n            this.onClose(\"ping timeout\");\n        }, this.protocol === 3\n            ? this.server.opts.pingInterval + this.server.opts.pingTimeout\n            : this.server.opts.pingTimeout);\n    }\n    /**\n     * Attaches handlers for the given transport.\n     *\n     * @param {Transport} transport\n     * @private\n     */\n    setTransport(transport) {\n        const onError = this.onError.bind(this);\n        const onReady = () => this.flush();\n        const onPacket = this.onPacket.bind(this);\n        const onDrain = this.onDrain.bind(this);\n        const onClose = this.onClose.bind(this, \"transport close\");\n        this.transport = transport;\n        this.transport.once(\"error\", onError);\n        this.transport.on(\"ready\", onReady);\n        this.transport.on(\"packet\", onPacket);\n        this.transport.on(\"drain\", onDrain);\n        this.transport.once(\"close\", onClose);\n        this.cleanupFn.push(function () {\n            transport.removeListener(\"error\", onError);\n            transport.removeListener(\"ready\", onReady);\n            transport.removeListener(\"packet\", onPacket);\n            transport.removeListener(\"drain\", onDrain);\n            transport.removeListener(\"close\", onClose);\n        });\n    }\n    /**\n     * Upon transport \"drain\" event\n     *\n     * @private\n     */\n    onDrain() {\n        if (this.sentCallbackFn.length > 0) {\n            debug(\"executing batch send callback\");\n            const seqFn = this.sentCallbackFn.shift();\n            if (seqFn) {\n                for (let i = 0; i < seqFn.length; i++) {\n                    seqFn[i](this.transport);\n                }\n            }\n        }\n    }\n    /**\n     * Upgrades socket to the given transport\n     *\n     * @param {Transport} transport\n     * @private\n     */\n    /* private */ _maybeUpgrade(transport) {\n        debug('might upgrade socket transport from \"%s\" to \"%s\"', this.transport.name, transport.name);\n        this.upgrading = true;\n        // set transport upgrade timer\n        const upgradeTimeoutTimer = (0, timers_1.setTimeout)(() => {\n            debug(\"client did not complete upgrade - closing transport\");\n            cleanup();\n            if (\"open\" === transport.readyState) {\n                transport.close();\n            }\n        }, this.server.opts.upgradeTimeout);\n        let checkIntervalTimer;\n        const onPacket = (packet) => {\n            if (\"ping\" === packet.type && \"probe\" === packet.data) {\n                debug(\"got probe ping packet, sending pong\");\n                transport.send([{ type: \"pong\", data: \"probe\" }]);\n                this.emit(\"upgrading\", transport);\n                clearInterval(checkIntervalTimer);\n                checkIntervalTimer = setInterval(check, 100);\n            }\n            else if (\"upgrade\" === packet.type && this.readyState !== \"closed\") {\n                debug(\"got upgrade packet - upgrading\");\n                cleanup();\n                this.transport.discard();\n                this.upgraded = true;\n                this.clearTransport();\n                this.setTransport(transport);\n                this.emit(\"upgrade\", transport);\n                this.flush();\n                if (this.readyState === \"closing\") {\n                    transport.close(() => {\n                        this.onClose(\"forced close\");\n                    });\n                }\n            }\n            else {\n                cleanup();\n                transport.close();\n            }\n        };\n        // we force a polling cycle to ensure a fast upgrade\n        const check = () => {\n            if (\"polling\" === this.transport.name && this.transport.writable) {\n                debug(\"writing a noop packet to polling for fast upgrade\");\n                this.transport.send([{ type: \"noop\" }]);\n            }\n        };\n        const cleanup = () => {\n            this.upgrading = false;\n            clearInterval(checkIntervalTimer);\n            (0, timers_1.clearTimeout)(upgradeTimeoutTimer);\n            transport.removeListener(\"packet\", onPacket);\n            transport.removeListener(\"close\", onTransportClose);\n            transport.removeListener(\"error\", onError);\n            this.removeListener(\"close\", onClose);\n        };\n        const onError = (err) => {\n            debug(\"client did not complete upgrade - %s\", err);\n            cleanup();\n            transport.close();\n            transport = null;\n        };\n        const onTransportClose = () => {\n            onError(\"transport closed\");\n        };\n        const onClose = () => {\n            onError(\"socket closed\");\n        };\n        transport.on(\"packet\", onPacket);\n        transport.once(\"close\", onTransportClose);\n        transport.once(\"error\", onError);\n        this.once(\"close\", onClose);\n    }\n    /**\n     * Clears listeners and timers associated with current transport.\n     *\n     * @private\n     */\n    clearTransport() {\n        let cleanup;\n        const toCleanUp = this.cleanupFn.length;\n        for (let i = 0; i < toCleanUp; i++) {\n            cleanup = this.cleanupFn.shift();\n            cleanup();\n        }\n        // silence further transport errors and prevent uncaught exceptions\n        this.transport.on(\"error\", function () {\n            debug(\"error triggered by discarded transport\");\n        });\n        // ensure transport won't stay open\n        this.transport.close();\n        (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n    }\n    /**\n     * Called upon transport considered closed.\n     * Possible reasons: `ping timeout`, `client error`, `parse error`,\n     * `transport error`, `server close`, `transport close`\n     */\n    onClose(reason, description) {\n        if (\"closed\" !== this.readyState) {\n            this.readyState = \"closed\";\n            // clear timers\n            (0, timers_1.clearTimeout)(this.pingIntervalTimer);\n            (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n            // clean writeBuffer in next tick, so developers can still\n            // grab the writeBuffer on 'close' event\n            process.nextTick(() => {\n                this.writeBuffer = [];\n            });\n            this.packetsFn = [];\n            this.sentCallbackFn = [];\n            this.clearTransport();\n            this.emit(\"close\", reason, description);\n        }\n    }\n    /**\n     * Sends a message packet.\n     *\n     * @param {Object} data\n     * @param {Object} options\n     * @param {Function} callback\n     * @return {Socket} for chaining\n     */\n    send(data, options, callback) {\n        this.sendPacket(\"message\", data, options, callback);\n        return this;\n    }\n    /**\n     * Alias of {@link send}.\n     *\n     * @param data\n     * @param options\n     * @param callback\n     */\n    write(data, options, callback) {\n        this.sendPacket(\"message\", data, options, callback);\n        return this;\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param {String} type - packet type\n     * @param {String} data\n     * @param {Object} options\n     * @param {Function} callback\n     *\n     * @private\n     */\n    sendPacket(type, data, options = {}, callback) {\n        if (\"function\" === typeof options) {\n            callback = options;\n            options = {};\n        }\n        if (\"closing\" !== this.readyState && \"closed\" !== this.readyState) {\n            debug('sending packet \"%s\" (%s)', type, data);\n            // compression is enabled by default\n            options.compress = options.compress !== false;\n            const packet = {\n                type,\n                options: options,\n            };\n            if (data)\n                packet.data = data;\n            // exports packetCreate event\n            this.emit(\"packetCreate\", packet);\n            this.writeBuffer.push(packet);\n            // add send callback to object, if defined\n            if (\"function\" === typeof callback)\n                this.packetsFn.push(callback);\n            this.flush();\n        }\n    }\n    /**\n     * Attempts to flush the packets buffer.\n     *\n     * @private\n     */\n    flush() {\n        if (\"closed\" !== this.readyState &&\n            this.transport.writable &&\n            this.writeBuffer.length) {\n            debug(\"flushing buffer to transport\");\n            this.emit(\"flush\", this.writeBuffer);\n            this.server.emit(\"flush\", this, this.writeBuffer);\n            const wbuf = this.writeBuffer;\n            this.writeBuffer = [];\n            if (this.packetsFn.length) {\n                this.sentCallbackFn.push(this.packetsFn);\n                this.packetsFn = [];\n            }\n            else {\n                this.sentCallbackFn.push(null);\n            }\n            this.transport.send(wbuf);\n            this.emit(\"drain\");\n            this.server.emit(\"drain\", this);\n        }\n    }\n    /**\n     * Get available upgrades for this socket.\n     *\n     * @private\n     */\n    getAvailableUpgrades() {\n        const availableUpgrades = [];\n        const allUpgrades = this.server.upgrades(this.transport.name);\n        for (let i = 0; i < allUpgrades.length; ++i) {\n            const upg = allUpgrades[i];\n            if (this.server.opts.transports.indexOf(upg) !== -1) {\n                availableUpgrades.push(upg);\n            }\n        }\n        return availableUpgrades;\n    }\n    /**\n     * Closes the socket and underlying transport.\n     *\n     * @param {Boolean} discard - optional, discard the transport\n     * @return {Socket} for chaining\n     */\n    close(discard) {\n        if (discard &&\n            (this.readyState === \"open\" || this.readyState === \"closing\")) {\n            return this.closeTransport(discard);\n        }\n        if (\"open\" !== this.readyState)\n            return;\n        this.readyState = \"closing\";\n        if (this.writeBuffer.length) {\n            debug(\"there are %d remaining packets in the buffer, waiting for the 'drain' event\", this.writeBuffer.length);\n            this.once(\"drain\", () => {\n                debug(\"all packets have been sent, closing the transport\");\n                this.closeTransport(discard);\n            });\n            return;\n        }\n        debug(\"the buffer is empty, closing the transport right away\");\n        this.closeTransport(discard);\n    }\n    /**\n     * Closes the underlying transport.\n     *\n     * @param {Boolean} discard\n     * @private\n     */\n    closeTransport(discard) {\n        debug(\"closing the transport (discard? %s)\", !!discard);\n        if (discard)\n            this.transport.discard();\n        this.transport.close(this.onClose.bind(this, \"forced close\"));\n    }\n}\nexports.Socket = Socket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC9zb2NrZXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLDhFQUFPO0FBQy9CLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFlBQVk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNkJBQTZCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsY0FBYztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjIiwic291cmNlcyI6WyIvVXNlcnMvc2FsL3JlZGlzLXByb2plY3Qvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC9zb2NrZXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNvY2tldCA9IHZvaWQgMDtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCB0aW1lcnNfMSA9IHJlcXVpcmUoXCJ0aW1lcnNcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwiZW5naW5lOnNvY2tldFwiKTtcbmNsYXNzIFNvY2tldCBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgZ2V0IHJlYWR5U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkeVN0YXRlO1xuICAgIH1cbiAgICBzZXQgcmVhZHlTdGF0ZShzdGF0ZSkge1xuICAgICAgICBkZWJ1ZyhcInJlYWR5U3RhdGUgdXBkYXRlZCBmcm9tICVzIHRvICVzXCIsIHRoaXMuX3JlYWR5U3RhdGUsIHN0YXRlKTtcbiAgICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IHN0YXRlO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihpZCwgc2VydmVyLCB0cmFuc3BvcnQsIHJlcSwgcHJvdG9jb2wpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBzb2NrZXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9yZWFkeVN0YXRlID0gXCJvcGVuaW5nXCI7XG4gICAgICAgIC8qIHByaXZhdGUgKi8gdGhpcy51cGdyYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgLyogcHJpdmF0ZSAqLyB0aGlzLnVwZ3JhZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5wYWNrZXRzRm4gPSBbXTtcbiAgICAgICAgdGhpcy5zZW50Q2FsbGJhY2tGbiA9IFtdO1xuICAgICAgICB0aGlzLmNsZWFudXBGbiA9IFtdO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuc2VydmVyID0gc2VydmVyO1xuICAgICAgICB0aGlzLnJlcXVlc3QgPSByZXE7XG4gICAgICAgIHRoaXMucHJvdG9jb2wgPSBwcm90b2NvbDtcbiAgICAgICAgLy8gQ2FjaGUgSVAgc2luY2UgaXQgbWlnaHQgbm90IGJlIGluIHRoZSByZXEgbGF0ZXJcbiAgICAgICAgaWYgKHJlcSkge1xuICAgICAgICAgICAgaWYgKHJlcS53ZWJzb2NrZXQgJiYgcmVxLndlYnNvY2tldC5fc29ja2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdGVBZGRyZXNzID0gcmVxLndlYnNvY2tldC5fc29ja2V0LnJlbW90ZUFkZHJlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW90ZUFkZHJlc3MgPSByZXEuY29ubmVjdGlvbi5yZW1vdGVBZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVE9ETyB0aGVyZSBpcyBjdXJyZW50bHkgbm8gd2F5IHRvIGdldCB0aGUgSVAgYWRkcmVzcyBvZiB0aGUgY2xpZW50IHdoZW4gaXQgY29ubmVjdHMgd2l0aCBXZWJUcmFuc3BvcnRcbiAgICAgICAgICAgIC8vICBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhaWxzLWNvbXBvbmVudHMvd2VidHJhbnNwb3J0L2lzc3Vlcy8xMTRcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBpbmdUaW1lb3V0VGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnBpbmdJbnRlcnZhbFRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgICAgICAgdGhpcy5vbk9wZW4oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGNvbnNpZGVyZWQgb3Blbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25PcGVuKCkge1xuICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBcIm9wZW5cIjtcbiAgICAgICAgLy8gc2VuZHMgYW4gYG9wZW5gIHBhY2tldFxuICAgICAgICB0aGlzLnRyYW5zcG9ydC5zaWQgPSB0aGlzLmlkO1xuICAgICAgICB0aGlzLnNlbmRQYWNrZXQoXCJvcGVuXCIsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHNpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIHVwZ3JhZGVzOiB0aGlzLmdldEF2YWlsYWJsZVVwZ3JhZGVzKCksXG4gICAgICAgICAgICBwaW5nSW50ZXJ2YWw6IHRoaXMuc2VydmVyLm9wdHMucGluZ0ludGVydmFsLFxuICAgICAgICAgICAgcGluZ1RpbWVvdXQ6IHRoaXMuc2VydmVyLm9wdHMucGluZ1RpbWVvdXQsXG4gICAgICAgICAgICBtYXhQYXlsb2FkOiB0aGlzLnNlcnZlci5vcHRzLm1heEh0dHBCdWZmZXJTaXplLFxuICAgICAgICB9KSk7XG4gICAgICAgIGlmICh0aGlzLnNlcnZlci5vcHRzLmluaXRpYWxQYWNrZXQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZFBhY2tldChcIm1lc3NhZ2VcIiwgdGhpcy5zZXJ2ZXIub3B0cy5pbml0aWFsUGFja2V0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoXCJvcGVuXCIpO1xuICAgICAgICBpZiAodGhpcy5wcm90b2NvbCA9PT0gMykge1xuICAgICAgICAgICAgLy8gaW4gcHJvdG9jb2wgdjMsIHRoZSBjbGllbnQgc2VuZHMgYSBwaW5nLCBhbmQgdGhlIHNlcnZlciBhbnN3ZXJzIHdpdGggYSBwb25nXG4gICAgICAgICAgICB0aGlzLnJlc2V0UGluZ1RpbWVvdXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGluIHByb3RvY29sIHY0LCB0aGUgc2VydmVyIHNlbmRzIGEgcGluZywgYW5kIHRoZSBjbGllbnQgYW5zd2VycyB3aXRoIGEgcG9uZ1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVBpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgcGFja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25QYWNrZXQocGFja2V0KSB7XG4gICAgICAgIGlmIChcIm9wZW5cIiAhPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVidWcoXCJwYWNrZXQgcmVjZWl2ZWQgd2l0aCBjbG9zZWQgc29ja2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGV4cG9ydCBwYWNrZXQgZXZlbnRcbiAgICAgICAgZGVidWcoYHJlY2VpdmVkIHBhY2tldCAke3BhY2tldC50eXBlfWApO1xuICAgICAgICB0aGlzLmVtaXQoXCJwYWNrZXRcIiwgcGFja2V0KTtcbiAgICAgICAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInBpbmdcIjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFuc3BvcnQucHJvdG9jb2wgIT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKG5ldyBFcnJvcihcImludmFsaWQgaGVhcnRiZWF0IGRpcmVjdGlvblwiKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVidWcoXCJnb3QgcGluZ1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBpbmdUaW1lb3V0VGltZXIucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFBhY2tldChcInBvbmdcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiaGVhcnRiZWF0XCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInBvbmdcIjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFuc3BvcnQucHJvdG9jb2wgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKG5ldyBFcnJvcihcImludmFsaWQgaGVhcnRiZWF0IGRpcmVjdGlvblwiKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVidWcoXCJnb3QgcG9uZ1wiKTtcbiAgICAgICAgICAgICAgICAoMCwgdGltZXJzXzEuY2xlYXJUaW1lb3V0KSh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMucGluZ0ludGVydmFsVGltZXIucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImhlYXJ0YmVhdFwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgIHRoaXMub25DbG9zZShcInBhcnNlIGVycm9yXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkYXRhXCIsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJtZXNzYWdlXCIsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Vycm9yfSBlcnIgLSBlcnJvciBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uRXJyb3IoZXJyKSB7XG4gICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IGVycm9yXCIpO1xuICAgICAgICB0aGlzLm9uQ2xvc2UoXCJ0cmFuc3BvcnQgZXJyb3JcIiwgZXJyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGluZ3MgY2xpZW50IGV2ZXJ5IGB0aGlzLnBpbmdJbnRlcnZhbGAgYW5kIGV4cGVjdHMgcmVzcG9uc2VcbiAgICAgKiB3aXRoaW4gYHRoaXMucGluZ1RpbWVvdXRgIG9yIGNsb3NlcyBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzY2hlZHVsZVBpbmcoKSB7XG4gICAgICAgIHRoaXMucGluZ0ludGVydmFsVGltZXIgPSAoMCwgdGltZXJzXzEuc2V0VGltZW91dCkoKCkgPT4ge1xuICAgICAgICAgICAgZGVidWcoXCJ3cml0aW5nIHBpbmcgcGFja2V0IC0gZXhwZWN0aW5nIHBvbmcgd2l0aGluICVzbXNcIiwgdGhpcy5zZXJ2ZXIub3B0cy5waW5nVGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLnNlbmRQYWNrZXQoXCJwaW5nXCIpO1xuICAgICAgICAgICAgdGhpcy5yZXNldFBpbmdUaW1lb3V0KCk7XG4gICAgICAgIH0sIHRoaXMuc2VydmVyLm9wdHMucGluZ0ludGVydmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHBpbmcgdGltZW91dC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcmVzZXRQaW5nVGltZW91dCgpIHtcbiAgICAgICAgKDAsIHRpbWVyc18xLmNsZWFyVGltZW91dCkodGhpcy5waW5nVGltZW91dFRpbWVyKTtcbiAgICAgICAgdGhpcy5waW5nVGltZW91dFRpbWVyID0gKDAsIHRpbWVyc18xLnNldFRpbWVvdXQpKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFwiY2xvc2VkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5vbkNsb3NlKFwicGluZyB0aW1lb3V0XCIpO1xuICAgICAgICB9LCB0aGlzLnByb3RvY29sID09PSAzXG4gICAgICAgICAgICA/IHRoaXMuc2VydmVyLm9wdHMucGluZ0ludGVydmFsICsgdGhpcy5zZXJ2ZXIub3B0cy5waW5nVGltZW91dFxuICAgICAgICAgICAgOiB0aGlzLnNlcnZlci5vcHRzLnBpbmdUaW1lb3V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgaGFuZGxlcnMgZm9yIHRoZSBnaXZlbiB0cmFuc3BvcnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1RyYW5zcG9ydH0gdHJhbnNwb3J0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzZXRUcmFuc3BvcnQodHJhbnNwb3J0KSB7XG4gICAgICAgIGNvbnN0IG9uRXJyb3IgPSB0aGlzLm9uRXJyb3IuYmluZCh0aGlzKTtcbiAgICAgICAgY29uc3Qgb25SZWFkeSA9ICgpID0+IHRoaXMuZmx1c2goKTtcbiAgICAgICAgY29uc3Qgb25QYWNrZXQgPSB0aGlzLm9uUGFja2V0LmJpbmQodGhpcyk7XG4gICAgICAgIGNvbnN0IG9uRHJhaW4gPSB0aGlzLm9uRHJhaW4uYmluZCh0aGlzKTtcbiAgICAgICAgY29uc3Qgb25DbG9zZSA9IHRoaXMub25DbG9zZS5iaW5kKHRoaXMsIFwidHJhbnNwb3J0IGNsb3NlXCIpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQub25jZShcImVycm9yXCIsIG9uRXJyb3IpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5vbihcInJlYWR5XCIsIG9uUmVhZHkpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5vbihcInBhY2tldFwiLCBvblBhY2tldCk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0Lm9uKFwiZHJhaW5cIiwgb25EcmFpbik7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0Lm9uY2UoXCJjbG9zZVwiLCBvbkNsb3NlKTtcbiAgICAgICAgdGhpcy5jbGVhbnVwRm4ucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLCBvbkVycm9yKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcihcInJlYWR5XCIsIG9uUmVhZHkpO1xuICAgICAgICAgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKFwicGFja2V0XCIsIG9uUGFja2V0KTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcihcImRyYWluXCIsIG9uRHJhaW4pO1xuICAgICAgICAgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIiwgb25DbG9zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcG9uIHRyYW5zcG9ydCBcImRyYWluXCIgZXZlbnRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25EcmFpbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VudENhbGxiYWNrRm4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZGVidWcoXCJleGVjdXRpbmcgYmF0Y2ggc2VuZCBjYWxsYmFja1wiKTtcbiAgICAgICAgICAgIGNvbnN0IHNlcUZuID0gdGhpcy5zZW50Q2FsbGJhY2tGbi5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKHNlcUZuKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXFGbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBzZXFGbltpXSh0aGlzLnRyYW5zcG9ydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZ3JhZGVzIHNvY2tldCB0byB0aGUgZ2l2ZW4gdHJhbnNwb3J0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1RyYW5zcG9ydH0gdHJhbnNwb3J0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICAvKiBwcml2YXRlICovIF9tYXliZVVwZ3JhZGUodHJhbnNwb3J0KSB7XG4gICAgICAgIGRlYnVnKCdtaWdodCB1cGdyYWRlIHNvY2tldCB0cmFuc3BvcnQgZnJvbSBcIiVzXCIgdG8gXCIlc1wiJywgdGhpcy50cmFuc3BvcnQubmFtZSwgdHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgICB0aGlzLnVwZ3JhZGluZyA9IHRydWU7XG4gICAgICAgIC8vIHNldCB0cmFuc3BvcnQgdXBncmFkZSB0aW1lclxuICAgICAgICBjb25zdCB1cGdyYWRlVGltZW91dFRpbWVyID0gKDAsIHRpbWVyc18xLnNldFRpbWVvdXQpKCgpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKFwiY2xpZW50IGRpZCBub3QgY29tcGxldGUgdXBncmFkZSAtIGNsb3NpbmcgdHJhbnNwb3J0XCIpO1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgaWYgKFwib3BlblwiID09PSB0cmFuc3BvcnQucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLnNlcnZlci5vcHRzLnVwZ3JhZGVUaW1lb3V0KTtcbiAgICAgICAgbGV0IGNoZWNrSW50ZXJ2YWxUaW1lcjtcbiAgICAgICAgY29uc3Qgb25QYWNrZXQgPSAocGFja2V0KSA9PiB7XG4gICAgICAgICAgICBpZiAoXCJwaW5nXCIgPT09IHBhY2tldC50eXBlICYmIFwicHJvYmVcIiA9PT0gcGFja2V0LmRhdGEpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImdvdCBwcm9iZSBwaW5nIHBhY2tldCwgc2VuZGluZyBwb25nXCIpO1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6IFwicG9uZ1wiLCBkYXRhOiBcInByb2JlXCIgfV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcInVwZ3JhZGluZ1wiLCB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoY2hlY2tJbnRlcnZhbFRpbWVyKTtcbiAgICAgICAgICAgICAgICBjaGVja0ludGVydmFsVGltZXIgPSBzZXRJbnRlcnZhbChjaGVjaywgMTAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKFwidXBncmFkZVwiID09PSBwYWNrZXQudHlwZSAmJiB0aGlzLnJlYWR5U3RhdGUgIT09IFwiY2xvc2VkXCIpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImdvdCB1cGdyYWRlIHBhY2tldCAtIHVwZ3JhZGluZ1wiKTtcbiAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuZGlzY2FyZCgpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBncmFkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJUcmFuc3BvcnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcInVwZ3JhZGVcIiwgdHJhbnNwb3J0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gXCJjbG9zaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LmNsb3NlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25DbG9zZShcImZvcmNlZCBjbG9zZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyB3ZSBmb3JjZSBhIHBvbGxpbmcgY3ljbGUgdG8gZW5zdXJlIGEgZmFzdCB1cGdyYWRlXG4gICAgICAgIGNvbnN0IGNoZWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKFwicG9sbGluZ1wiID09PSB0aGlzLnRyYW5zcG9ydC5uYW1lICYmIHRoaXMudHJhbnNwb3J0LndyaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJ3cml0aW5nIGEgbm9vcCBwYWNrZXQgdG8gcG9sbGluZyBmb3IgZmFzdCB1cGdyYWRlXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogXCJub29wXCIgfV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGdyYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoY2hlY2tJbnRlcnZhbFRpbWVyKTtcbiAgICAgICAgICAgICgwLCB0aW1lcnNfMS5jbGVhclRpbWVvdXQpKHVwZ3JhZGVUaW1lb3V0VGltZXIpO1xuICAgICAgICAgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKFwicGFja2V0XCIsIG9uUGFja2V0KTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuICAgICAgICAgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgb25FcnJvcik7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIiwgb25DbG9zZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyhcImNsaWVudCBkaWQgbm90IGNvbXBsZXRlIHVwZ3JhZGUgLSAlc1wiLCBlcnIpO1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgICAgICB0cmFuc3BvcnQgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvblRyYW5zcG9ydENsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgb25FcnJvcihcInRyYW5zcG9ydCBjbG9zZWRcIik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBvbkVycm9yKFwic29ja2V0IGNsb3NlZFwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJhbnNwb3J0Lm9uKFwicGFja2V0XCIsIG9uUGFja2V0KTtcbiAgICAgICAgdHJhbnNwb3J0Lm9uY2UoXCJjbG9zZVwiLCBvblRyYW5zcG9ydENsb3NlKTtcbiAgICAgICAgdHJhbnNwb3J0Lm9uY2UoXCJlcnJvclwiLCBvbkVycm9yKTtcbiAgICAgICAgdGhpcy5vbmNlKFwiY2xvc2VcIiwgb25DbG9zZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyBsaXN0ZW5lcnMgYW5kIHRpbWVycyBhc3NvY2lhdGVkIHdpdGggY3VycmVudCB0cmFuc3BvcnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNsZWFyVHJhbnNwb3J0KCkge1xuICAgICAgICBsZXQgY2xlYW51cDtcbiAgICAgICAgY29uc3QgdG9DbGVhblVwID0gdGhpcy5jbGVhbnVwRm4ubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvQ2xlYW5VcDsgaSsrKSB7XG4gICAgICAgICAgICBjbGVhbnVwID0gdGhpcy5jbGVhbnVwRm4uc2hpZnQoKTtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzaWxlbmNlIGZ1cnRoZXIgdHJhbnNwb3J0IGVycm9ycyBhbmQgcHJldmVudCB1bmNhdWdodCBleGNlcHRpb25zXG4gICAgICAgIHRoaXMudHJhbnNwb3J0Lm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGVidWcoXCJlcnJvciB0cmlnZ2VyZWQgYnkgZGlzY2FyZGVkIHRyYW5zcG9ydFwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVuc3VyZSB0cmFuc3BvcnQgd29uJ3Qgc3RheSBvcGVuXG4gICAgICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgICgwLCB0aW1lcnNfMS5jbGVhclRpbWVvdXQpKHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBjb25zaWRlcmVkIGNsb3NlZC5cbiAgICAgKiBQb3NzaWJsZSByZWFzb25zOiBgcGluZyB0aW1lb3V0YCwgYGNsaWVudCBlcnJvcmAsIGBwYXJzZSBlcnJvcmAsXG4gICAgICogYHRyYW5zcG9ydCBlcnJvcmAsIGBzZXJ2ZXIgY2xvc2VgLCBgdHJhbnNwb3J0IGNsb3NlYFxuICAgICAqL1xuICAgIG9uQ2xvc2UocmVhc29uLCBkZXNjcmlwdGlvbikge1xuICAgICAgICBpZiAoXCJjbG9zZWRcIiAhPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBcImNsb3NlZFwiO1xuICAgICAgICAgICAgLy8gY2xlYXIgdGltZXJzXG4gICAgICAgICAgICAoMCwgdGltZXJzXzEuY2xlYXJUaW1lb3V0KSh0aGlzLnBpbmdJbnRlcnZhbFRpbWVyKTtcbiAgICAgICAgICAgICgwLCB0aW1lcnNfMS5jbGVhclRpbWVvdXQpKHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG4gICAgICAgICAgICAvLyBjbGVhbiB3cml0ZUJ1ZmZlciBpbiBuZXh0IHRpY2ssIHNvIGRldmVsb3BlcnMgY2FuIHN0aWxsXG4gICAgICAgICAgICAvLyBncmFiIHRoZSB3cml0ZUJ1ZmZlciBvbiAnY2xvc2UnIGV2ZW50XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyID0gW107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucGFja2V0c0ZuID0gW107XG4gICAgICAgICAgICB0aGlzLnNlbnRDYWxsYmFja0ZuID0gW107XG4gICAgICAgICAgICB0aGlzLmNsZWFyVHJhbnNwb3J0KCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJjbG9zZVwiLCByZWFzb24sIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIG1lc3NhZ2UgcGFja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7U29ja2V0fSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBzZW5kKGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuc2VuZFBhY2tldChcIm1lc3NhZ2VcIiwgZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxpYXMgb2Yge0BsaW5rIHNlbmR9LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSBjYWxsYmFja1xuICAgICAqL1xuICAgIHdyaXRlKGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuc2VuZFBhY2tldChcIm1lc3NhZ2VcIiwgZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIHBhY2tldCB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHNlbmRQYWNrZXQodHlwZSwgZGF0YSwgb3B0aW9ucyA9IHt9LCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygb3B0aW9ucykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChcImNsb3NpbmdcIiAhPT0gdGhpcy5yZWFkeVN0YXRlICYmIFwiY2xvc2VkXCIgIT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgZGVidWcoJ3NlbmRpbmcgcGFja2V0IFwiJXNcIiAoJXMpJywgdHlwZSwgZGF0YSk7XG4gICAgICAgICAgICAvLyBjb21wcmVzc2lvbiBpcyBlbmFibGVkIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIG9wdGlvbnMuY29tcHJlc3MgPSBvcHRpb25zLmNvbXByZXNzICE9PSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHBhY2tldCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGRhdGEpXG4gICAgICAgICAgICAgICAgcGFja2V0LmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgLy8gZXhwb3J0cyBwYWNrZXRDcmVhdGUgZXZlbnRcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInBhY2tldENyZWF0ZVwiLCBwYWNrZXQpO1xuICAgICAgICAgICAgdGhpcy53cml0ZUJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gICAgICAgICAgICAvLyBhZGQgc2VuZCBjYWxsYmFjayB0byBvYmplY3QsIGlmIGRlZmluZWRcbiAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjYWxsYmFjaylcbiAgICAgICAgICAgICAgICB0aGlzLnBhY2tldHNGbi5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBmbHVzaCB0aGUgcGFja2V0cyBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZsdXNoKCkge1xuICAgICAgICBpZiAoXCJjbG9zZWRcIiAhPT0gdGhpcy5yZWFkeVN0YXRlICYmXG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC53cml0YWJsZSAmJlxuICAgICAgICAgICAgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiZmx1c2hpbmcgYnVmZmVyIHRvIHRyYW5zcG9ydFwiKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImZsdXNoXCIsIHRoaXMud3JpdGVCdWZmZXIpO1xuICAgICAgICAgICAgdGhpcy5zZXJ2ZXIuZW1pdChcImZsdXNoXCIsIHRoaXMsIHRoaXMud3JpdGVCdWZmZXIpO1xuICAgICAgICAgICAgY29uc3Qgd2J1ZiA9IHRoaXMud3JpdGVCdWZmZXI7XG4gICAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyID0gW107XG4gICAgICAgICAgICBpZiAodGhpcy5wYWNrZXRzRm4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW50Q2FsbGJhY2tGbi5wdXNoKHRoaXMucGFja2V0c0ZuKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhY2tldHNGbiA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW50Q2FsbGJhY2tGbi5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuc2VuZCh3YnVmKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRyYWluXCIpO1xuICAgICAgICAgICAgdGhpcy5zZXJ2ZXIuZW1pdChcImRyYWluXCIsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhdmFpbGFibGUgdXBncmFkZXMgZm9yIHRoaXMgc29ja2V0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRBdmFpbGFibGVVcGdyYWRlcygpIHtcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlVXBncmFkZXMgPSBbXTtcbiAgICAgICAgY29uc3QgYWxsVXBncmFkZXMgPSB0aGlzLnNlcnZlci51cGdyYWRlcyh0aGlzLnRyYW5zcG9ydC5uYW1lKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGxVcGdyYWRlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgdXBnID0gYWxsVXBncmFkZXNbaV07XG4gICAgICAgICAgICBpZiAodGhpcy5zZXJ2ZXIub3B0cy50cmFuc3BvcnRzLmluZGV4T2YodXBnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVVcGdyYWRlcy5wdXNoKHVwZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF2YWlsYWJsZVVwZ3JhZGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIHNvY2tldCBhbmQgdW5kZXJseWluZyB0cmFuc3BvcnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2NhcmQgLSBvcHRpb25hbCwgZGlzY2FyZCB0aGUgdHJhbnNwb3J0XG4gICAgICogQHJldHVybiB7U29ja2V0fSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBjbG9zZShkaXNjYXJkKSB7XG4gICAgICAgIGlmIChkaXNjYXJkICYmXG4gICAgICAgICAgICAodGhpcy5yZWFkeVN0YXRlID09PSBcIm9wZW5cIiB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFwiY2xvc2luZ1wiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2VUcmFuc3BvcnQoZGlzY2FyZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwib3BlblwiICE9PSB0aGlzLnJlYWR5U3RhdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwiY2xvc2luZ1wiO1xuICAgICAgICBpZiAodGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRlYnVnKFwidGhlcmUgYXJlICVkIHJlbWFpbmluZyBwYWNrZXRzIGluIHRoZSBidWZmZXIsIHdhaXRpbmcgZm9yIHRoZSAnZHJhaW4nIGV2ZW50XCIsIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMub25jZShcImRyYWluXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImFsbCBwYWNrZXRzIGhhdmUgYmVlbiBzZW50LCBjbG9zaW5nIHRoZSB0cmFuc3BvcnRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZVRyYW5zcG9ydChkaXNjYXJkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKFwidGhlIGJ1ZmZlciBpcyBlbXB0eSwgY2xvc2luZyB0aGUgdHJhbnNwb3J0IHJpZ2h0IGF3YXlcIik7XG4gICAgICAgIHRoaXMuY2xvc2VUcmFuc3BvcnQoZGlzY2FyZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgdW5kZXJseWluZyB0cmFuc3BvcnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2NhcmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNsb3NlVHJhbnNwb3J0KGRpc2NhcmQpIHtcbiAgICAgICAgZGVidWcoXCJjbG9zaW5nIHRoZSB0cmFuc3BvcnQgKGRpc2NhcmQ/ICVzKVwiLCAhIWRpc2NhcmQpO1xuICAgICAgICBpZiAoZGlzY2FyZClcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmRpc2NhcmQoKTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQuY2xvc2UodGhpcy5vbkNsb3NlLmJpbmQodGhpcywgXCJmb3JjZWQgY2xvc2VcIikpO1xuICAgIH1cbn1cbmV4cG9ydHMuU29ja2V0ID0gU29ja2V0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/engine.io/build/socket.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/engine.io/build/transport.js":
/*!****************************************************!*\
  !*** ../node_modules/engine.io/build/transport.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Transport = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst parser_v4 = __webpack_require__(/*! engine.io-parser */ \"(rsc)/../node_modules/engine.io-parser/build/cjs/index.js\");\nconst parser_v3 = __webpack_require__(/*! ./parser-v3/index */ \"(rsc)/../node_modules/engine.io/build/parser-v3/index.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/../node_modules/engine.io/node_modules/debug/src/index.js\");\nconst debug = (0, debug_1.default)(\"engine:transport\");\nfunction noop() { }\nclass Transport extends events_1.EventEmitter {\n    get readyState() {\n        return this._readyState;\n    }\n    set readyState(state) {\n        debug(\"readyState updated from %s to %s (%s)\", this._readyState, state, this.name);\n        this._readyState = state;\n    }\n    /**\n     * Transport constructor.\n     *\n     * @param {EngineRequest} req\n     */\n    constructor(req) {\n        super();\n        /**\n         * Whether the transport is currently ready to send packets.\n         */\n        this.writable = false;\n        /**\n         * The current state of the transport.\n         * @protected\n         */\n        this._readyState = \"open\";\n        /**\n         * Whether the transport is discarded and can be safely closed (used during upgrade).\n         * @protected\n         */\n        this.discarded = false;\n        this.protocol = req._query.EIO === \"4\" ? 4 : 3; // 3rd revision by default\n        this.parser = this.protocol === 4 ? parser_v4 : parser_v3;\n        this.supportsBinary = !(req._query && req._query.b64);\n    }\n    /**\n     * Flags the transport as discarded.\n     *\n     * @package\n     */\n    discard() {\n        this.discarded = true;\n    }\n    /**\n     * Called with an incoming HTTP request.\n     *\n     * @param req\n     * @package\n     */\n    onRequest(req) { }\n    /**\n     * Closes the transport.\n     *\n     * @package\n     */\n    close(fn) {\n        if (\"closed\" === this.readyState || \"closing\" === this.readyState)\n            return;\n        this.readyState = \"closing\";\n        this.doClose(fn || noop);\n    }\n    /**\n     * Called with a transport error.\n     *\n     * @param {String} msg - message error\n     * @param {Object} desc - error description\n     * @protected\n     */\n    onError(msg, desc) {\n        if (this.listeners(\"error\").length) {\n            const err = new Error(msg);\n            // @ts-ignore\n            err.type = \"TransportError\";\n            // @ts-ignore\n            err.description = desc;\n            this.emit(\"error\", err);\n        }\n        else {\n            debug(\"ignored transport error %s (%s)\", msg, desc);\n        }\n    }\n    /**\n     * Called with parsed out a packets from the data stream.\n     *\n     * @param {Object} packet\n     * @protected\n     */\n    onPacket(packet) {\n        this.emit(\"packet\", packet);\n    }\n    /**\n     * Called with the encoded packet data.\n     *\n     * @param {String} data\n     * @protected\n     */\n    onData(data) {\n        this.onPacket(this.parser.decodePacket(data));\n    }\n    /**\n     * Called upon transport close.\n     *\n     * @protected\n     */\n    onClose() {\n        this.readyState = \"closed\";\n        this.emit(\"close\");\n    }\n}\nexports.Transport = Transport;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC90cmFuc3BvcnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLGtCQUFrQixtQkFBTyxDQUFDLG1GQUFrQjtBQUM1QyxrQkFBa0IsbUJBQU8sQ0FBQyxtRkFBbUI7QUFDN0MsZ0JBQWdCLG1CQUFPLENBQUMsOEVBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWwvcmVkaXMtcHJvamVjdC9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHJhbnNwb3J0ID0gdm9pZCAwO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgcGFyc2VyX3Y0ID0gcmVxdWlyZShcImVuZ2luZS5pby1wYXJzZXJcIik7XG5jb25zdCBwYXJzZXJfdjMgPSByZXF1aXJlKFwiLi9wYXJzZXItdjMvaW5kZXhcIik7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcImVuZ2luZTp0cmFuc3BvcnRcIik7XG5mdW5jdGlvbiBub29wKCkgeyB9XG5jbGFzcyBUcmFuc3BvcnQgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGdldCByZWFkeVN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZHlTdGF0ZTtcbiAgICB9XG4gICAgc2V0IHJlYWR5U3RhdGUoc3RhdGUpIHtcbiAgICAgICAgZGVidWcoXCJyZWFkeVN0YXRlIHVwZGF0ZWQgZnJvbSAlcyB0byAlcyAoJXMpXCIsIHRoaXMuX3JlYWR5U3RhdGUsIHN0YXRlLCB0aGlzLm5hbWUpO1xuICAgICAgICB0aGlzLl9yZWFkeVN0YXRlID0gc3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zcG9ydCBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RW5naW5lUmVxdWVzdH0gcmVxXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVxKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSB0cmFuc3BvcnQgaXMgY3VycmVudGx5IHJlYWR5IHRvIHNlbmQgcGFja2V0cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSB0cmFuc3BvcnQuXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBcIm9wZW5cIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHRyYW5zcG9ydCBpcyBkaXNjYXJkZWQgYW5kIGNhbiBiZSBzYWZlbHkgY2xvc2VkICh1c2VkIGR1cmluZyB1cGdyYWRlKS5cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNjYXJkZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcm90b2NvbCA9IHJlcS5fcXVlcnkuRUlPID09PSBcIjRcIiA/IDQgOiAzOyAvLyAzcmQgcmV2aXNpb24gYnkgZGVmYXVsdFxuICAgICAgICB0aGlzLnBhcnNlciA9IHRoaXMucHJvdG9jb2wgPT09IDQgPyBwYXJzZXJfdjQgOiBwYXJzZXJfdjM7XG4gICAgICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSAhKHJlcS5fcXVlcnkgJiYgcmVxLl9xdWVyeS5iNjQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGbGFncyB0aGUgdHJhbnNwb3J0IGFzIGRpc2NhcmRlZC5cbiAgICAgKlxuICAgICAqIEBwYWNrYWdlXG4gICAgICovXG4gICAgZGlzY2FyZCgpIHtcbiAgICAgICAgdGhpcy5kaXNjYXJkZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2l0aCBhbiBpbmNvbWluZyBIVFRQIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVxXG4gICAgICogQHBhY2thZ2VcbiAgICAgKi9cbiAgICBvblJlcXVlc3QocmVxKSB7IH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIHRyYW5zcG9ydC5cbiAgICAgKlxuICAgICAqIEBwYWNrYWdlXG4gICAgICovXG4gICAgY2xvc2UoZm4pIHtcbiAgICAgICAgaWYgKFwiY2xvc2VkXCIgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCBcImNsb3NpbmdcIiA9PT0gdGhpcy5yZWFkeVN0YXRlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBcImNsb3NpbmdcIjtcbiAgICAgICAgdGhpcy5kb0Nsb3NlKGZuIHx8IG5vb3ApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2l0aCBhIHRyYW5zcG9ydCBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSBtZXNzYWdlIGVycm9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlc2MgLSBlcnJvciBkZXNjcmlwdGlvblxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkVycm9yKG1zZywgZGVzYykge1xuICAgICAgICBpZiAodGhpcy5saXN0ZW5lcnMoXCJlcnJvclwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgZXJyLnR5cGUgPSBcIlRyYW5zcG9ydEVycm9yXCI7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBlcnIuZGVzY3JpcHRpb24gPSBkZXNjO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnKFwiaWdub3JlZCB0cmFuc3BvcnQgZXJyb3IgJXMgKCVzKVwiLCBtc2csIGRlc2MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aXRoIHBhcnNlZCBvdXQgYSBwYWNrZXRzIGZyb20gdGhlIGRhdGEgc3RyZWFtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvblBhY2tldChwYWNrZXQpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwicGFja2V0XCIsIHBhY2tldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aXRoIHRoZSBlbmNvZGVkIHBhY2tldCBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25EYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5vblBhY2tldCh0aGlzLnBhcnNlci5kZWNvZGVQYWNrZXQoZGF0YSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgY2xvc2UuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25DbG9zZSgpIHtcbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJjbG9zZWRcIjtcbiAgICAgICAgdGhpcy5lbWl0KFwiY2xvc2VcIik7XG4gICAgfVxufVxuZXhwb3J0cy5UcmFuc3BvcnQgPSBUcmFuc3BvcnQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/engine.io/build/transport.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/engine.io/build/transports-uws/index.js":
/*!***************************************************************!*\
  !*** ../node_modules/engine.io/build/transports-uws/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst polling_1 = __webpack_require__(/*! ./polling */ \"(rsc)/../node_modules/engine.io/build/transports-uws/polling.js\");\nconst websocket_1 = __webpack_require__(/*! ./websocket */ \"(rsc)/../node_modules/engine.io/build/transports-uws/websocket.js\");\nexports[\"default\"] = {\n    polling: polling_1.Polling,\n    websocket: websocket_1.WebSocket,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC90cmFuc3BvcnRzLXV3cy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsbUJBQU8sQ0FBQyxrRkFBVztBQUNyQyxvQkFBb0IsbUJBQU8sQ0FBQyxzRkFBYTtBQUN6QyxrQkFBZTtBQUNmO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhbC9yZWRpcy1wcm9qZWN0L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vYnVpbGQvdHJhbnNwb3J0cy11d3MvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBwb2xsaW5nXzEgPSByZXF1aXJlKFwiLi9wb2xsaW5nXCIpO1xuY29uc3Qgd2Vic29ja2V0XzEgPSByZXF1aXJlKFwiLi93ZWJzb2NrZXRcIik7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgcG9sbGluZzogcG9sbGluZ18xLlBvbGxpbmcsXG4gICAgd2Vic29ja2V0OiB3ZWJzb2NrZXRfMS5XZWJTb2NrZXQsXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/engine.io/build/transports-uws/index.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/engine.io/build/transports-uws/polling.js":
/*!*****************************************************************!*\
  !*** ../node_modules/engine.io/build/transports-uws/polling.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Polling = void 0;\nconst transport_1 = __webpack_require__(/*! ../transport */ \"(rsc)/../node_modules/engine.io/build/transport.js\");\nconst zlib_1 = __webpack_require__(/*! zlib */ \"zlib\");\nconst accepts = __webpack_require__(/*! accepts */ \"(rsc)/../node_modules/accepts/index.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/../node_modules/engine.io/node_modules/debug/src/index.js\");\nconst debug = (0, debug_1.default)(\"engine:polling\");\nconst compressionMethods = {\n    gzip: zlib_1.createGzip,\n    deflate: zlib_1.createDeflate,\n};\nclass Polling extends transport_1.Transport {\n    /**\n     * HTTP polling constructor.\n     */\n    constructor(req) {\n        super(req);\n        this.closeTimeout = 30 * 1000;\n    }\n    /**\n     * Transport name\n     */\n    get name() {\n        return \"polling\";\n    }\n    /**\n     * Overrides onRequest.\n     *\n     * @param req\n     *\n     * @private\n     */\n    onRequest(req) {\n        const res = req.res;\n        // remove the reference to the ServerResponse object (as the first request of the session is kept in memory by default)\n        req.res = null;\n        if (req.getMethod() === \"get\") {\n            this.onPollRequest(req, res);\n        }\n        else if (req.getMethod() === \"post\") {\n            this.onDataRequest(req, res);\n        }\n        else {\n            res.writeStatus(\"500 Internal Server Error\");\n            res.end();\n        }\n    }\n    /**\n     * The client sends a request awaiting for us to send data.\n     *\n     * @private\n     */\n    onPollRequest(req, res) {\n        if (this.req) {\n            debug(\"request overlap\");\n            // assert: this.res, '.req and .res should be (un)set together'\n            this.onError(\"overlap from client\");\n            res.writeStatus(\"500 Internal Server Error\");\n            res.end();\n            return;\n        }\n        debug(\"setting request\");\n        this.req = req;\n        this.res = res;\n        const onClose = () => {\n            this.writable = false;\n            this.onError(\"poll connection closed prematurely\");\n        };\n        const cleanup = () => {\n            this.req = this.res = null;\n        };\n        req.cleanup = cleanup;\n        res.onAborted(onClose);\n        this.writable = true;\n        this.emit(\"ready\");\n        // if we're still writable but had a pending close, trigger an empty send\n        if (this.writable && this.shouldClose) {\n            debug(\"triggering empty send to append close packet\");\n            this.send([{ type: \"noop\" }]);\n        }\n    }\n    /**\n     * The client sends a request with data.\n     *\n     * @private\n     */\n    onDataRequest(req, res) {\n        if (this.dataReq) {\n            // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'\n            this.onError(\"data request overlap from client\");\n            res.writeStatus(\"500 Internal Server Error\");\n            res.end();\n            return;\n        }\n        const expectedContentLength = Number(req.headers[\"content-length\"]);\n        if (!expectedContentLength) {\n            this.onError(\"content-length header required\");\n            res.writeStatus(\"411 Length Required\").end();\n            return;\n        }\n        if (expectedContentLength > this.maxHttpBufferSize) {\n            this.onError(\"payload too large\");\n            res.writeStatus(\"413 Payload Too Large\").end();\n            return;\n        }\n        const isBinary = \"application/octet-stream\" === req.headers[\"content-type\"];\n        if (isBinary && this.protocol === 4) {\n            return this.onError(\"invalid content\");\n        }\n        this.dataReq = req;\n        this.dataRes = res;\n        let buffer;\n        let offset = 0;\n        const headers = {\n            // text/html is required instead of text/plain to avoid an\n            // unwanted download dialog on certain user-agents (GH-43)\n            \"Content-Type\": \"text/html\",\n        };\n        this.headers(req, headers);\n        for (let key in headers) {\n            res.writeHeader(key, String(headers[key]));\n        }\n        const onEnd = (buffer) => {\n            this.onData(buffer.toString());\n            this.onDataRequestCleanup();\n            res.cork(() => {\n                res.end(\"ok\");\n            });\n        };\n        res.onAborted(() => {\n            this.onDataRequestCleanup();\n            this.onError(\"data request connection closed prematurely\");\n        });\n        res.onData((arrayBuffer, isLast) => {\n            const totalLength = offset + arrayBuffer.byteLength;\n            if (totalLength > expectedContentLength) {\n                this.onError(\"content-length mismatch\");\n                res.close(); // calls onAborted\n                return;\n            }\n            if (!buffer) {\n                if (isLast) {\n                    onEnd(Buffer.from(arrayBuffer));\n                    return;\n                }\n                buffer = Buffer.allocUnsafe(expectedContentLength);\n            }\n            Buffer.from(arrayBuffer).copy(buffer, offset);\n            if (isLast) {\n                if (totalLength != expectedContentLength) {\n                    this.onError(\"content-length mismatch\");\n                    res.writeStatus(\"400 Content-Length Mismatch\").end();\n                    this.onDataRequestCleanup();\n                    return;\n                }\n                onEnd(buffer);\n                return;\n            }\n            offset = totalLength;\n        });\n    }\n    /**\n     * Cleanup request.\n     *\n     * @private\n     */\n    onDataRequestCleanup() {\n        this.dataReq = this.dataRes = null;\n    }\n    /**\n     * Processes the incoming data payload.\n     *\n     * @param {String} encoded payload\n     * @private\n     */\n    onData(data) {\n        debug('received \"%s\"', data);\n        const callback = (packet) => {\n            if (\"close\" === packet.type) {\n                debug(\"got xhr close packet\");\n                this.onClose();\n                return false;\n            }\n            this.onPacket(packet);\n        };\n        if (this.protocol === 3) {\n            this.parser.decodePayload(data, callback);\n        }\n        else {\n            this.parser.decodePayload(data).forEach(callback);\n        }\n    }\n    /**\n     * Overrides onClose.\n     *\n     * @private\n     */\n    onClose() {\n        if (this.writable) {\n            // close pending poll request\n            this.send([{ type: \"noop\" }]);\n        }\n        super.onClose();\n    }\n    /**\n     * Writes a packet payload.\n     *\n     * @param {Object} packet\n     * @private\n     */\n    send(packets) {\n        this.writable = false;\n        if (this.shouldClose) {\n            debug(\"appending close packet to payload\");\n            packets.push({ type: \"close\" });\n            this.shouldClose();\n            this.shouldClose = null;\n        }\n        const doWrite = (data) => {\n            const compress = packets.some((packet) => {\n                return packet.options && packet.options.compress;\n            });\n            this.write(data, { compress });\n        };\n        if (this.protocol === 3) {\n            this.parser.encodePayload(packets, this.supportsBinary, doWrite);\n        }\n        else {\n            this.parser.encodePayload(packets, doWrite);\n        }\n    }\n    /**\n     * Writes data as response to poll request.\n     *\n     * @param {String} data\n     * @param {Object} options\n     * @private\n     */\n    write(data, options) {\n        debug('writing \"%s\"', data);\n        this.doWrite(data, options, () => {\n            this.req.cleanup();\n            this.emit(\"drain\");\n        });\n    }\n    /**\n     * Performs the write.\n     *\n     * @private\n     */\n    doWrite(data, options, callback) {\n        // explicit UTF-8 is required for pages not served under utf\n        const isString = typeof data === \"string\";\n        const contentType = isString\n            ? \"text/plain; charset=UTF-8\"\n            : \"application/octet-stream\";\n        const headers = {\n            \"Content-Type\": contentType,\n        };\n        const respond = (data) => {\n            this.headers(this.req, headers);\n            this.res.cork(() => {\n                Object.keys(headers).forEach((key) => {\n                    this.res.writeHeader(key, String(headers[key]));\n                });\n                this.res.end(data);\n            });\n            callback();\n        };\n        if (!this.httpCompression || !options.compress) {\n            respond(data);\n            return;\n        }\n        const len = isString ? Buffer.byteLength(data) : data.length;\n        if (len < this.httpCompression.threshold) {\n            respond(data);\n            return;\n        }\n        const encoding = accepts(this.req).encodings([\"gzip\", \"deflate\"]);\n        if (!encoding) {\n            respond(data);\n            return;\n        }\n        this.compress(data, encoding, (err, data) => {\n            if (err) {\n                this.res.writeStatus(\"500 Internal Server Error\");\n                this.res.end();\n                callback(err);\n                return;\n            }\n            headers[\"Content-Encoding\"] = encoding;\n            respond(data);\n        });\n    }\n    /**\n     * Compresses data.\n     *\n     * @private\n     */\n    compress(data, encoding, callback) {\n        debug(\"compressing\");\n        const buffers = [];\n        let nread = 0;\n        compressionMethods[encoding](this.httpCompression)\n            .on(\"error\", callback)\n            .on(\"data\", function (chunk) {\n            buffers.push(chunk);\n            nread += chunk.length;\n        })\n            .on(\"end\", function () {\n            callback(null, Buffer.concat(buffers, nread));\n        })\n            .end(data);\n    }\n    /**\n     * Closes the transport.\n     *\n     * @private\n     */\n    doClose(fn) {\n        debug(\"closing\");\n        let closeTimeoutTimer;\n        const onClose = () => {\n            clearTimeout(closeTimeoutTimer);\n            fn();\n            this.onClose();\n        };\n        if (this.writable) {\n            debug(\"transport writable - closing right away\");\n            this.send([{ type: \"close\" }]);\n            onClose();\n        }\n        else if (this.discarded) {\n            debug(\"transport discarded - closing right away\");\n            onClose();\n        }\n        else {\n            debug(\"transport not writable - buffering orderly close\");\n            this.shouldClose = onClose;\n            closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);\n        }\n    }\n    /**\n     * Returns headers for a response.\n     *\n     * @param req - request\n     * @param {Object} extra headers\n     * @private\n     */\n    headers(req, headers) {\n        headers = headers || {};\n        // prevent XSS warnings on IE\n        // https://github.com/LearnBoost/socket.io/pull/1333\n        const ua = req.headers[\"user-agent\"];\n        if (ua && (~ua.indexOf(\";MSIE\") || ~ua.indexOf(\"Trident/\"))) {\n            headers[\"X-XSS-Protection\"] = \"0\";\n        }\n        headers[\"cache-control\"] = \"no-store\";\n        this.emit(\"headers\", headers, req);\n        return headers;\n    }\n}\nexports.Polling = Polling;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC90cmFuc3BvcnRzLXV3cy9wb2xsaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixvQkFBb0IsbUJBQU8sQ0FBQyx3RUFBYztBQUMxQyxlQUFlLG1CQUFPLENBQUMsa0JBQU07QUFDN0IsZ0JBQWdCLG1CQUFPLENBQUMsdURBQVM7QUFDakMsZ0JBQWdCLG1CQUFPLENBQUMsOEVBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGNBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGNBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiwrQkFBK0IsVUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhbC9yZWRpcy1wcm9qZWN0L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vYnVpbGQvdHJhbnNwb3J0cy11d3MvcG9sbGluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUG9sbGluZyA9IHZvaWQgMDtcbmNvbnN0IHRyYW5zcG9ydF8xID0gcmVxdWlyZShcIi4uL3RyYW5zcG9ydFwiKTtcbmNvbnN0IHpsaWJfMSA9IHJlcXVpcmUoXCJ6bGliXCIpO1xuY29uc3QgYWNjZXB0cyA9IHJlcXVpcmUoXCJhY2NlcHRzXCIpO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoXCJlbmdpbmU6cG9sbGluZ1wiKTtcbmNvbnN0IGNvbXByZXNzaW9uTWV0aG9kcyA9IHtcbiAgICBnemlwOiB6bGliXzEuY3JlYXRlR3ppcCxcbiAgICBkZWZsYXRlOiB6bGliXzEuY3JlYXRlRGVmbGF0ZSxcbn07XG5jbGFzcyBQb2xsaW5nIGV4dGVuZHMgdHJhbnNwb3J0XzEuVHJhbnNwb3J0IHtcbiAgICAvKipcbiAgICAgKiBIVFRQIHBvbGxpbmcgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVxKSB7XG4gICAgICAgIHN1cGVyKHJlcSk7XG4gICAgICAgIHRoaXMuY2xvc2VUaW1lb3V0ID0gMzAgKiAxMDAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc3BvcnQgbmFtZVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJwb2xsaW5nXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBvblJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVxXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uUmVxdWVzdChyZXEpIHtcbiAgICAgICAgY29uc3QgcmVzID0gcmVxLnJlcztcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSByZWZlcmVuY2UgdG8gdGhlIFNlcnZlclJlc3BvbnNlIG9iamVjdCAoYXMgdGhlIGZpcnN0IHJlcXVlc3Qgb2YgdGhlIHNlc3Npb24gaXMga2VwdCBpbiBtZW1vcnkgYnkgZGVmYXVsdClcbiAgICAgICAgcmVxLnJlcyA9IG51bGw7XG4gICAgICAgIGlmIChyZXEuZ2V0TWV0aG9kKCkgPT09IFwiZ2V0XCIpIHtcbiAgICAgICAgICAgIHRoaXMub25Qb2xsUmVxdWVzdChyZXEsIHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVxLmdldE1ldGhvZCgpID09PSBcInBvc3RcIikge1xuICAgICAgICAgICAgdGhpcy5vbkRhdGFSZXF1ZXN0KHJlcSwgcmVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcy53cml0ZVN0YXR1cyhcIjUwMCBJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIik7XG4gICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNsaWVudCBzZW5kcyBhIHJlcXVlc3QgYXdhaXRpbmcgZm9yIHVzIHRvIHNlbmQgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25Qb2xsUmVxdWVzdChyZXEsIHJlcykge1xuICAgICAgICBpZiAodGhpcy5yZXEpIHtcbiAgICAgICAgICAgIGRlYnVnKFwicmVxdWVzdCBvdmVybGFwXCIpO1xuICAgICAgICAgICAgLy8gYXNzZXJ0OiB0aGlzLnJlcywgJy5yZXEgYW5kIC5yZXMgc2hvdWxkIGJlICh1bilzZXQgdG9nZXRoZXInXG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJvdmVybGFwIGZyb20gY2xpZW50XCIpO1xuICAgICAgICAgICAgcmVzLndyaXRlU3RhdHVzKFwiNTAwIEludGVybmFsIFNlcnZlciBFcnJvclwiKTtcbiAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyhcInNldHRpbmcgcmVxdWVzdFwiKTtcbiAgICAgICAgdGhpcy5yZXEgPSByZXE7XG4gICAgICAgIHRoaXMucmVzID0gcmVzO1xuICAgICAgICBjb25zdCBvbkNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwicG9sbCBjb25uZWN0aW9uIGNsb3NlZCBwcmVtYXR1cmVseVwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVxID0gdGhpcy5yZXMgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICByZXEuY2xlYW51cCA9IGNsZWFudXA7XG4gICAgICAgIHJlcy5vbkFib3J0ZWQob25DbG9zZSk7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoXCJyZWFkeVwiKTtcbiAgICAgICAgLy8gaWYgd2UncmUgc3RpbGwgd3JpdGFibGUgYnV0IGhhZCBhIHBlbmRpbmcgY2xvc2UsIHRyaWdnZXIgYW4gZW1wdHkgc2VuZFxuICAgICAgICBpZiAodGhpcy53cml0YWJsZSAmJiB0aGlzLnNob3VsZENsb3NlKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInRyaWdnZXJpbmcgZW1wdHkgc2VuZCB0byBhcHBlbmQgY2xvc2UgcGFja2V0XCIpO1xuICAgICAgICAgICAgdGhpcy5zZW5kKFt7IHR5cGU6IFwibm9vcFwiIH1dKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY2xpZW50IHNlbmRzIGEgcmVxdWVzdCB3aXRoIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uRGF0YVJlcXVlc3QocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVJlcSkge1xuICAgICAgICAgICAgLy8gYXNzZXJ0OiB0aGlzLmRhdGFSZXMsICcuZGF0YVJlcSBhbmQgLmRhdGFSZXMgc2hvdWxkIGJlICh1bilzZXQgdG9nZXRoZXInXG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJkYXRhIHJlcXVlc3Qgb3ZlcmxhcCBmcm9tIGNsaWVudFwiKTtcbiAgICAgICAgICAgIHJlcy53cml0ZVN0YXR1cyhcIjUwMCBJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIik7XG4gICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhwZWN0ZWRDb250ZW50TGVuZ3RoID0gTnVtYmVyKHJlcS5oZWFkZXJzW1wiY29udGVudC1sZW5ndGhcIl0pO1xuICAgICAgICBpZiAoIWV4cGVjdGVkQ29udGVudExlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwiY29udGVudC1sZW5ndGggaGVhZGVyIHJlcXVpcmVkXCIpO1xuICAgICAgICAgICAgcmVzLndyaXRlU3RhdHVzKFwiNDExIExlbmd0aCBSZXF1aXJlZFwiKS5lbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwZWN0ZWRDb250ZW50TGVuZ3RoID4gdGhpcy5tYXhIdHRwQnVmZmVyU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwicGF5bG9hZCB0b28gbGFyZ2VcIik7XG4gICAgICAgICAgICByZXMud3JpdGVTdGF0dXMoXCI0MTMgUGF5bG9hZCBUb28gTGFyZ2VcIikuZW5kKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNCaW5hcnkgPSBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiID09PSByZXEuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXTtcbiAgICAgICAgaWYgKGlzQmluYXJ5ICYmIHRoaXMucHJvdG9jb2wgPT09IDQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uRXJyb3IoXCJpbnZhbGlkIGNvbnRlbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhUmVxID0gcmVxO1xuICAgICAgICB0aGlzLmRhdGFSZXMgPSByZXM7XG4gICAgICAgIGxldCBidWZmZXI7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgLy8gdGV4dC9odG1sIGlzIHJlcXVpcmVkIGluc3RlYWQgb2YgdGV4dC9wbGFpbiB0byBhdm9pZCBhblxuICAgICAgICAgICAgLy8gdW53YW50ZWQgZG93bmxvYWQgZGlhbG9nIG9uIGNlcnRhaW4gdXNlci1hZ2VudHMgKEdILTQzKVxuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L2h0bWxcIixcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oZWFkZXJzKHJlcSwgaGVhZGVycyk7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgICByZXMud3JpdGVIZWFkZXIoa2V5LCBTdHJpbmcoaGVhZGVyc1trZXldKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb25FbmQgPSAoYnVmZmVyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uRGF0YShidWZmZXIudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB0aGlzLm9uRGF0YVJlcXVlc3RDbGVhbnVwKCk7XG4gICAgICAgICAgICByZXMuY29yaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzLmVuZChcIm9rXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcy5vbkFib3J0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkRhdGFSZXF1ZXN0Q2xlYW51cCgpO1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwiZGF0YSByZXF1ZXN0IGNvbm5lY3Rpb24gY2xvc2VkIHByZW1hdHVyZWx5XCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzLm9uRGF0YSgoYXJyYXlCdWZmZXIsIGlzTGFzdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdG90YWxMZW5ndGggPSBvZmZzZXQgKyBhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRvdGFsTGVuZ3RoID4gZXhwZWN0ZWRDb250ZW50TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwiY29udGVudC1sZW5ndGggbWlzbWF0Y2hcIik7XG4gICAgICAgICAgICAgICAgcmVzLmNsb3NlKCk7IC8vIGNhbGxzIG9uQWJvcnRlZFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGFzdCkge1xuICAgICAgICAgICAgICAgICAgICBvbkVuZChCdWZmZXIuZnJvbShhcnJheUJ1ZmZlcikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShleHBlY3RlZENvbnRlbnRMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQnVmZmVyLmZyb20oYXJyYXlCdWZmZXIpLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKGlzTGFzdCkge1xuICAgICAgICAgICAgICAgIGlmICh0b3RhbExlbmd0aCAhPSBleHBlY3RlZENvbnRlbnRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwiY29udGVudC1sZW5ndGggbWlzbWF0Y2hcIik7XG4gICAgICAgICAgICAgICAgICAgIHJlcy53cml0ZVN0YXR1cyhcIjQwMCBDb250ZW50LUxlbmd0aCBNaXNtYXRjaFwiKS5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkRhdGFSZXF1ZXN0Q2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9uRW5kKGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ID0gdG90YWxMZW5ndGg7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhbnVwIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uRGF0YVJlcXVlc3RDbGVhbnVwKCkge1xuICAgICAgICB0aGlzLmRhdGFSZXEgPSB0aGlzLmRhdGFSZXMgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzZXMgdGhlIGluY29taW5nIGRhdGEgcGF5bG9hZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBlbmNvZGVkIHBheWxvYWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uRGF0YShkYXRhKSB7XG4gICAgICAgIGRlYnVnKCdyZWNlaXZlZCBcIiVzXCInLCBkYXRhKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAocGFja2V0KSA9PiB7XG4gICAgICAgICAgICBpZiAoXCJjbG9zZVwiID09PSBwYWNrZXQudHlwZSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiZ290IHhociBjbG9zZSBwYWNrZXRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vblBhY2tldChwYWNrZXQpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5wcm90b2NvbCA9PT0gMykge1xuICAgICAgICAgICAgdGhpcy5wYXJzZXIuZGVjb2RlUGF5bG9hZChkYXRhLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlci5kZWNvZGVQYXlsb2FkKGRhdGEpLmZvckVhY2goY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBvbkNsb3NlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbkNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy53cml0YWJsZSkge1xuICAgICAgICAgICAgLy8gY2xvc2UgcGVuZGluZyBwb2xsIHJlcXVlc3RcbiAgICAgICAgICAgIHRoaXMuc2VuZChbeyB0eXBlOiBcIm5vb3BcIiB9XSk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIub25DbG9zZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBwYWNrZXQgcGF5bG9hZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHNlbmQocGFja2V0cykge1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZENsb3NlKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImFwcGVuZGluZyBjbG9zZSBwYWNrZXQgdG8gcGF5bG9hZFwiKTtcbiAgICAgICAgICAgIHBhY2tldHMucHVzaCh7IHR5cGU6IFwiY2xvc2VcIiB9KTtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkQ2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkQ2xvc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvV3JpdGUgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29tcHJlc3MgPSBwYWNrZXRzLnNvbWUoKHBhY2tldCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYWNrZXQub3B0aW9ucyAmJiBwYWNrZXQub3B0aW9ucy5jb21wcmVzcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy53cml0ZShkYXRhLCB7IGNvbXByZXNzIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5wcm90b2NvbCA9PT0gMykge1xuICAgICAgICAgICAgdGhpcy5wYXJzZXIuZW5jb2RlUGF5bG9hZChwYWNrZXRzLCB0aGlzLnN1cHBvcnRzQmluYXJ5LCBkb1dyaXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VyLmVuY29kZVBheWxvYWQocGFja2V0cywgZG9Xcml0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGRhdGEgYXMgcmVzcG9uc2UgdG8gcG9sbCByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgd3JpdGUoZGF0YSwgb3B0aW9ucykge1xuICAgICAgICBkZWJ1Zygnd3JpdGluZyBcIiVzXCInLCBkYXRhKTtcbiAgICAgICAgdGhpcy5kb1dyaXRlKGRhdGEsIG9wdGlvbnMsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVxLmNsZWFudXAoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRyYWluXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIHdyaXRlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBkb1dyaXRlKGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIGV4cGxpY2l0IFVURi04IGlzIHJlcXVpcmVkIGZvciBwYWdlcyBub3Qgc2VydmVkIHVuZGVyIHV0ZlxuICAgICAgICBjb25zdCBpc1N0cmluZyA9IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiO1xuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IGlzU3RyaW5nXG4gICAgICAgICAgICA/IFwidGV4dC9wbGFpbjsgY2hhcnNldD1VVEYtOFwiXG4gICAgICAgICAgICA6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCI7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBjb250ZW50VHlwZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uZCA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnModGhpcy5yZXEsIGhlYWRlcnMpO1xuICAgICAgICAgICAgdGhpcy5yZXMuY29yaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoaGVhZGVycykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzLndyaXRlSGVhZGVyKGtleSwgU3RyaW5nKGhlYWRlcnNba2V5XSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzLmVuZChkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF0aGlzLmh0dHBDb21wcmVzc2lvbiB8fCAhb3B0aW9ucy5jb21wcmVzcykge1xuICAgICAgICAgICAgcmVzcG9uZChkYXRhKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW4gPSBpc1N0cmluZyA/IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpIDogZGF0YS5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPCB0aGlzLmh0dHBDb21wcmVzc2lvbi50aHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHJlc3BvbmQoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5jb2RpbmcgPSBhY2NlcHRzKHRoaXMucmVxKS5lbmNvZGluZ3MoW1wiZ3ppcFwiLCBcImRlZmxhdGVcIl0pO1xuICAgICAgICBpZiAoIWVuY29kaW5nKSB7XG4gICAgICAgICAgICByZXNwb25kKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcHJlc3MoZGF0YSwgZW5jb2RpbmcsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcy53cml0ZVN0YXR1cyhcIjUwMCBJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoZWFkZXJzW1wiQ29udGVudC1FbmNvZGluZ1wiXSA9IGVuY29kaW5nO1xuICAgICAgICAgICAgcmVzcG9uZChkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXByZXNzZXMgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29tcHJlc3MoZGF0YSwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGRlYnVnKFwiY29tcHJlc3NpbmdcIik7XG4gICAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgbGV0IG5yZWFkID0gMDtcbiAgICAgICAgY29tcHJlc3Npb25NZXRob2RzW2VuY29kaW5nXSh0aGlzLmh0dHBDb21wcmVzc2lvbilcbiAgICAgICAgICAgIC5vbihcImVycm9yXCIsIGNhbGxiYWNrKVxuICAgICAgICAgICAgLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChjaHVuayk7XG4gICAgICAgICAgICBucmVhZCArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAub24oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgQnVmZmVyLmNvbmNhdChidWZmZXJzLCBucmVhZCkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmVuZChkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSB0cmFuc3BvcnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRvQ2xvc2UoZm4pIHtcbiAgICAgICAgZGVidWcoXCJjbG9zaW5nXCIpO1xuICAgICAgICBsZXQgY2xvc2VUaW1lb3V0VGltZXI7XG4gICAgICAgIGNvbnN0IG9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoY2xvc2VUaW1lb3V0VGltZXIpO1xuICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgIHRoaXMub25DbG9zZSgpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy53cml0YWJsZSkge1xuICAgICAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgd3JpdGFibGUgLSBjbG9zaW5nIHJpZ2h0IGF3YXlcIik7XG4gICAgICAgICAgICB0aGlzLnNlbmQoW3sgdHlwZTogXCJjbG9zZVwiIH1dKTtcbiAgICAgICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRpc2NhcmRlZCkge1xuICAgICAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgZGlzY2FyZGVkIC0gY2xvc2luZyByaWdodCBhd2F5XCIpO1xuICAgICAgICAgICAgb25DbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgbm90IHdyaXRhYmxlIC0gYnVmZmVyaW5nIG9yZGVybHkgY2xvc2VcIik7XG4gICAgICAgICAgICB0aGlzLnNob3VsZENsb3NlID0gb25DbG9zZTtcbiAgICAgICAgICAgIGNsb3NlVGltZW91dFRpbWVyID0gc2V0VGltZW91dChvbkNsb3NlLCB0aGlzLmNsb3NlVGltZW91dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBoZWFkZXJzIGZvciBhIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlcSAtIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXh0cmEgaGVhZGVyc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaGVhZGVycyhyZXEsIGhlYWRlcnMpIHtcbiAgICAgICAgaGVhZGVycyA9IGhlYWRlcnMgfHwge307XG4gICAgICAgIC8vIHByZXZlbnQgWFNTIHdhcm5pbmdzIG9uIElFXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFybkJvb3N0L3NvY2tldC5pby9wdWxsLzEzMzNcbiAgICAgICAgY29uc3QgdWEgPSByZXEuaGVhZGVyc1tcInVzZXItYWdlbnRcIl07XG4gICAgICAgIGlmICh1YSAmJiAofnVhLmluZGV4T2YoXCI7TVNJRVwiKSB8fCB+dWEuaW5kZXhPZihcIlRyaWRlbnQvXCIpKSkge1xuICAgICAgICAgICAgaGVhZGVyc1tcIlgtWFNTLVByb3RlY3Rpb25cIl0gPSBcIjBcIjtcbiAgICAgICAgfVxuICAgICAgICBoZWFkZXJzW1wiY2FjaGUtY29udHJvbFwiXSA9IFwibm8tc3RvcmVcIjtcbiAgICAgICAgdGhpcy5lbWl0KFwiaGVhZGVyc1wiLCBoZWFkZXJzLCByZXEpO1xuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG59XG5leHBvcnRzLlBvbGxpbmcgPSBQb2xsaW5nO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/engine.io/build/transports-uws/polling.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/engine.io/build/transports-uws/websocket.js":
/*!*******************************************************************!*\
  !*** ../node_modules/engine.io/build/transports-uws/websocket.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WebSocket = void 0;\nconst transport_1 = __webpack_require__(/*! ../transport */ \"(rsc)/../node_modules/engine.io/build/transport.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/../node_modules/engine.io/node_modules/debug/src/index.js\");\nconst debug = (0, debug_1.default)(\"engine:ws\");\nclass WebSocket extends transport_1.Transport {\n    /**\n     * WebSocket transport\n     *\n     * @param req\n     */\n    constructor(req) {\n        super(req);\n        this.writable = false;\n        this.perMessageDeflate = null;\n    }\n    /**\n     * Transport name\n     */\n    get name() {\n        return \"websocket\";\n    }\n    /**\n     * Advertise upgrade support.\n     */\n    get handlesUpgrades() {\n        return true;\n    }\n    /**\n     * Writes a packet payload.\n     *\n     * @param {Array} packets\n     * @private\n     */\n    send(packets) {\n        this.writable = false;\n        for (let i = 0; i < packets.length; i++) {\n            const packet = packets[i];\n            const isLast = i + 1 === packets.length;\n            const send = (data) => {\n                const isBinary = typeof data !== \"string\";\n                const compress = this.perMessageDeflate &&\n                    Buffer.byteLength(data) > this.perMessageDeflate.threshold;\n                debug('writing \"%s\"', data);\n                this.socket.send(data, isBinary, compress);\n                if (isLast) {\n                    this.emit(\"drain\");\n                    this.writable = true;\n                    this.emit(\"ready\");\n                }\n            };\n            if (packet.options && typeof packet.options.wsPreEncoded === \"string\") {\n                send(packet.options.wsPreEncoded);\n            }\n            else {\n                this.parser.encodePacket(packet, this.supportsBinary, send);\n            }\n        }\n    }\n    /**\n     * Closes the transport.\n     *\n     * @private\n     */\n    doClose(fn) {\n        debug(\"closing\");\n        fn && fn();\n        // call fn first since socket.end() immediately emits a \"close\" event\n        this.socket.end();\n    }\n}\nexports.WebSocket = WebSocket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC90cmFuc3BvcnRzLXV3cy93ZWJzb2NrZXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLG9CQUFvQixtQkFBTyxDQUFDLHdFQUFjO0FBQzFDLGdCQUFnQixtQkFBTyxDQUFDLDhFQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWwvcmVkaXMtcHJvamVjdC9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMtdXdzL3dlYnNvY2tldC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2ViU29ja2V0ID0gdm9pZCAwO1xuY29uc3QgdHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi4vdHJhbnNwb3J0XCIpO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoXCJlbmdpbmU6d3NcIik7XG5jbGFzcyBXZWJTb2NrZXQgZXh0ZW5kcyB0cmFuc3BvcnRfMS5UcmFuc3BvcnQge1xuICAgIC8qKlxuICAgICAqIFdlYlNvY2tldCB0cmFuc3BvcnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSByZXFcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZXEpIHtcbiAgICAgICAgc3VwZXIocmVxKTtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNwb3J0IG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwid2Vic29ja2V0XCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkdmVydGlzZSB1cGdyYWRlIHN1cHBvcnQuXG4gICAgICovXG4gICAgZ2V0IGhhbmRsZXNVcGdyYWRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIHBhY2tldCBwYXlsb2FkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc2VuZChwYWNrZXRzKSB7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYWNrZXQgPSBwYWNrZXRzW2ldO1xuICAgICAgICAgICAgY29uc3QgaXNMYXN0ID0gaSArIDEgPT09IHBhY2tldHMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3Qgc2VuZCA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNCaW5hcnkgPSB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIjtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wcmVzcyA9IHRoaXMucGVyTWVzc2FnZURlZmxhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSkgPiB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZDtcbiAgICAgICAgICAgICAgICBkZWJ1Zygnd3JpdGluZyBcIiVzXCInLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNvY2tldC5zZW5kKGRhdGEsIGlzQmluYXJ5LCBjb21wcmVzcyk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGFzdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkcmFpblwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcInJlYWR5XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocGFja2V0Lm9wdGlvbnMgJiYgdHlwZW9mIHBhY2tldC5vcHRpb25zLndzUHJlRW5jb2RlZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHNlbmQocGFja2V0Lm9wdGlvbnMud3NQcmVFbmNvZGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VyLmVuY29kZVBhY2tldChwYWNrZXQsIHRoaXMuc3VwcG9ydHNCaW5hcnksIHNlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgdHJhbnNwb3J0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBkb0Nsb3NlKGZuKSB7XG4gICAgICAgIGRlYnVnKFwiY2xvc2luZ1wiKTtcbiAgICAgICAgZm4gJiYgZm4oKTtcbiAgICAgICAgLy8gY2FsbCBmbiBmaXJzdCBzaW5jZSBzb2NrZXQuZW5kKCkgaW1tZWRpYXRlbHkgZW1pdHMgYSBcImNsb3NlXCIgZXZlbnRcbiAgICAgICAgdGhpcy5zb2NrZXQuZW5kKCk7XG4gICAgfVxufVxuZXhwb3J0cy5XZWJTb2NrZXQgPSBXZWJTb2NrZXQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/engine.io/build/transports-uws/websocket.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/engine.io/build/transports/index.js":
/*!***********************************************************!*\
  !*** ../node_modules/engine.io/build/transports/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst polling_1 = __webpack_require__(/*! ./polling */ \"(rsc)/../node_modules/engine.io/build/transports/polling.js\");\nconst polling_jsonp_1 = __webpack_require__(/*! ./polling-jsonp */ \"(rsc)/../node_modules/engine.io/build/transports/polling-jsonp.js\");\nconst websocket_1 = __webpack_require__(/*! ./websocket */ \"(rsc)/../node_modules/engine.io/build/transports/websocket.js\");\nconst webtransport_1 = __webpack_require__(/*! ./webtransport */ \"(rsc)/../node_modules/engine.io/build/transports/webtransport.js\");\nexports[\"default\"] = {\n    polling: polling,\n    websocket: websocket_1.WebSocket,\n    webtransport: webtransport_1.WebTransport,\n};\n/**\n * Polling polymorphic constructor.\n */\nfunction polling(req) {\n    if (\"string\" === typeof req._query.j) {\n        return new polling_jsonp_1.JSONP(req);\n    }\n    else {\n        return new polling_1.Polling(req);\n    }\n}\npolling.upgradesTo = [\"websocket\", \"webtransport\"];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC90cmFuc3BvcnRzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixtQkFBTyxDQUFDLDhFQUFXO0FBQ3JDLHdCQUF3QixtQkFBTyxDQUFDLDBGQUFpQjtBQUNqRCxvQkFBb0IsbUJBQU8sQ0FBQyxrRkFBYTtBQUN6Qyx1QkFBdUIsbUJBQU8sQ0FBQyx3RkFBZ0I7QUFDL0Msa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhbC9yZWRpcy1wcm9qZWN0L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vYnVpbGQvdHJhbnNwb3J0cy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHBvbGxpbmdfMSA9IHJlcXVpcmUoXCIuL3BvbGxpbmdcIik7XG5jb25zdCBwb2xsaW5nX2pzb25wXzEgPSByZXF1aXJlKFwiLi9wb2xsaW5nLWpzb25wXCIpO1xuY29uc3Qgd2Vic29ja2V0XzEgPSByZXF1aXJlKFwiLi93ZWJzb2NrZXRcIik7XG5jb25zdCB3ZWJ0cmFuc3BvcnRfMSA9IHJlcXVpcmUoXCIuL3dlYnRyYW5zcG9ydFwiKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICBwb2xsaW5nOiBwb2xsaW5nLFxuICAgIHdlYnNvY2tldDogd2Vic29ja2V0XzEuV2ViU29ja2V0LFxuICAgIHdlYnRyYW5zcG9ydDogd2VidHJhbnNwb3J0XzEuV2ViVHJhbnNwb3J0LFxufTtcbi8qKlxuICogUG9sbGluZyBwb2x5bW9ycGhpYyBjb25zdHJ1Y3Rvci5cbiAqL1xuZnVuY3Rpb24gcG9sbGluZyhyZXEpIHtcbiAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHJlcS5fcXVlcnkuaikge1xuICAgICAgICByZXR1cm4gbmV3IHBvbGxpbmdfanNvbnBfMS5KU09OUChyZXEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBwb2xsaW5nXzEuUG9sbGluZyhyZXEpO1xuICAgIH1cbn1cbnBvbGxpbmcudXBncmFkZXNUbyA9IFtcIndlYnNvY2tldFwiLCBcIndlYnRyYW5zcG9ydFwiXTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/engine.io/build/transports/index.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/engine.io/build/transports/polling-jsonp.js":
/*!*******************************************************************!*\
  !*** ../node_modules/engine.io/build/transports/polling-jsonp.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JSONP = void 0;\nconst polling_1 = __webpack_require__(/*! ./polling */ \"(rsc)/../node_modules/engine.io/build/transports/polling.js\");\nconst qs = __webpack_require__(/*! querystring */ \"querystring\");\nconst rDoubleSlashes = /\\\\\\\\n/g;\nconst rSlashes = /(\\\\)?\\\\n/g;\nclass JSONP extends polling_1.Polling {\n    /**\n     * JSON-P polling transport.\n     */\n    constructor(req) {\n        super(req);\n        this.head = \"___eio[\" + (req._query.j || \"\").replace(/[^0-9]/g, \"\") + \"](\";\n        this.foot = \");\";\n    }\n    onData(data) {\n        // we leverage the qs module so that we get built-in DoS protection\n        // and the fast alternative to decodeURIComponent\n        data = qs.parse(data).d;\n        if (\"string\" === typeof data) {\n            // client will send already escaped newlines as \\\\\\\\n and newlines as \\\\n\n            // \\\\n must be replaced with \\n and \\\\\\\\n with \\\\n\n            data = data.replace(rSlashes, function (match, slashes) {\n                return slashes ? match : \"\\n\";\n            });\n            super.onData(data.replace(rDoubleSlashes, \"\\\\n\"));\n        }\n    }\n    doWrite(data, options, callback) {\n        // we must output valid javascript, not valid json\n        // see: http://timelessrepo.com/json-isnt-a-javascript-subset\n        const js = JSON.stringify(data)\n            .replace(/\\u2028/g, \"\\\\u2028\")\n            .replace(/\\u2029/g, \"\\\\u2029\");\n        // prepare response\n        data = this.head + js + this.foot;\n        super.doWrite(data, options, callback);\n    }\n}\nexports.JSONP = JSONP;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC90cmFuc3BvcnRzL3BvbGxpbmctanNvbnAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiLGtCQUFrQixtQkFBTyxDQUFDLDhFQUFXO0FBQ3JDLFdBQVcsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWwvcmVkaXMtcHJvamVjdC9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMvcG9sbGluZy1qc29ucC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSlNPTlAgPSB2b2lkIDA7XG5jb25zdCBwb2xsaW5nXzEgPSByZXF1aXJlKFwiLi9wb2xsaW5nXCIpO1xuY29uc3QgcXMgPSByZXF1aXJlKFwicXVlcnlzdHJpbmdcIik7XG5jb25zdCByRG91YmxlU2xhc2hlcyA9IC9cXFxcXFxcXG4vZztcbmNvbnN0IHJTbGFzaGVzID0gLyhcXFxcKT9cXFxcbi9nO1xuY2xhc3MgSlNPTlAgZXh0ZW5kcyBwb2xsaW5nXzEuUG9sbGluZyB7XG4gICAgLyoqXG4gICAgICogSlNPTi1QIHBvbGxpbmcgdHJhbnNwb3J0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJlcSkge1xuICAgICAgICBzdXBlcihyZXEpO1xuICAgICAgICB0aGlzLmhlYWQgPSBcIl9fX2Vpb1tcIiArIChyZXEuX3F1ZXJ5LmogfHwgXCJcIikucmVwbGFjZSgvW14wLTldL2csIFwiXCIpICsgXCJdKFwiO1xuICAgICAgICB0aGlzLmZvb3QgPSBcIik7XCI7XG4gICAgfVxuICAgIG9uRGF0YShkYXRhKSB7XG4gICAgICAgIC8vIHdlIGxldmVyYWdlIHRoZSBxcyBtb2R1bGUgc28gdGhhdCB3ZSBnZXQgYnVpbHQtaW4gRG9TIHByb3RlY3Rpb25cbiAgICAgICAgLy8gYW5kIHRoZSBmYXN0IGFsdGVybmF0aXZlIHRvIGRlY29kZVVSSUNvbXBvbmVudFxuICAgICAgICBkYXRhID0gcXMucGFyc2UoZGF0YSkuZDtcbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBkYXRhKSB7XG4gICAgICAgICAgICAvLyBjbGllbnQgd2lsbCBzZW5kIGFscmVhZHkgZXNjYXBlZCBuZXdsaW5lcyBhcyBcXFxcXFxcXG4gYW5kIG5ld2xpbmVzIGFzIFxcXFxuXG4gICAgICAgICAgICAvLyBcXFxcbiBtdXN0IGJlIHJlcGxhY2VkIHdpdGggXFxuIGFuZCBcXFxcXFxcXG4gd2l0aCBcXFxcblxuICAgICAgICAgICAgZGF0YSA9IGRhdGEucmVwbGFjZShyU2xhc2hlcywgZnVuY3Rpb24gKG1hdGNoLCBzbGFzaGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNsYXNoZXMgPyBtYXRjaCA6IFwiXFxuXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN1cGVyLm9uRGF0YShkYXRhLnJlcGxhY2UockRvdWJsZVNsYXNoZXMsIFwiXFxcXG5cIikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvV3JpdGUoZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gd2UgbXVzdCBvdXRwdXQgdmFsaWQgamF2YXNjcmlwdCwgbm90IHZhbGlkIGpzb25cbiAgICAgICAgLy8gc2VlOiBodHRwOi8vdGltZWxlc3NyZXBvLmNvbS9qc29uLWlzbnQtYS1qYXZhc2NyaXB0LXN1YnNldFxuICAgICAgICBjb25zdCBqcyA9IEpTT04uc3RyaW5naWZ5KGRhdGEpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCBcIlxcXFx1MjAyOFwiKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgXCJcXFxcdTIwMjlcIik7XG4gICAgICAgIC8vIHByZXBhcmUgcmVzcG9uc2VcbiAgICAgICAgZGF0YSA9IHRoaXMuaGVhZCArIGpzICsgdGhpcy5mb290O1xuICAgICAgICBzdXBlci5kb1dyaXRlKGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9XG59XG5leHBvcnRzLkpTT05QID0gSlNPTlA7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/engine.io/build/transports/polling-jsonp.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/engine.io/build/transports/polling.js":
/*!*************************************************************!*\
  !*** ../node_modules/engine.io/build/transports/polling.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Polling = void 0;\nconst transport_1 = __webpack_require__(/*! ../transport */ \"(rsc)/../node_modules/engine.io/build/transport.js\");\nconst zlib_1 = __webpack_require__(/*! zlib */ \"zlib\");\nconst accepts = __webpack_require__(/*! accepts */ \"(rsc)/../node_modules/accepts/index.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/../node_modules/engine.io/node_modules/debug/src/index.js\");\nconst debug = (0, debug_1.default)(\"engine:polling\");\nconst compressionMethods = {\n    gzip: zlib_1.createGzip,\n    deflate: zlib_1.createDeflate,\n};\nclass Polling extends transport_1.Transport {\n    /**\n     * HTTP polling constructor.\n     */\n    constructor(req) {\n        super(req);\n        this.closeTimeout = 30 * 1000;\n    }\n    /**\n     * Transport name\n     */\n    get name() {\n        return \"polling\";\n    }\n    /**\n     * Overrides onRequest.\n     *\n     * @param {EngineRequest} req\n     * @package\n     */\n    onRequest(req) {\n        const res = req.res;\n        // remove the reference to the ServerResponse object (as the first request of the session is kept in memory by default)\n        req.res = null;\n        if (\"GET\" === req.method) {\n            this.onPollRequest(req, res);\n        }\n        else if (\"POST\" === req.method) {\n            this.onDataRequest(req, res);\n        }\n        else {\n            res.writeHead(500);\n            res.end();\n        }\n    }\n    /**\n     * The client sends a request awaiting for us to send data.\n     *\n     * @private\n     */\n    onPollRequest(req, res) {\n        if (this.req) {\n            debug(\"request overlap\");\n            // assert: this.res, '.req and .res should be (un)set together'\n            this.onError(\"overlap from client\");\n            res.writeHead(400);\n            res.end();\n            return;\n        }\n        debug(\"setting request\");\n        this.req = req;\n        this.res = res;\n        const onClose = () => {\n            this.onError(\"poll connection closed prematurely\");\n        };\n        const cleanup = () => {\n            req.removeListener(\"close\", onClose);\n            this.req = this.res = null;\n        };\n        req.cleanup = cleanup;\n        req.on(\"close\", onClose);\n        this.writable = true;\n        this.emit(\"ready\");\n        // if we're still writable but had a pending close, trigger an empty send\n        if (this.writable && this.shouldClose) {\n            debug(\"triggering empty send to append close packet\");\n            this.send([{ type: \"noop\" }]);\n        }\n    }\n    /**\n     * The client sends a request with data.\n     *\n     * @private\n     */\n    onDataRequest(req, res) {\n        if (this.dataReq) {\n            // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'\n            this.onError(\"data request overlap from client\");\n            res.writeHead(400);\n            res.end();\n            return;\n        }\n        const isBinary = \"application/octet-stream\" === req.headers[\"content-type\"];\n        if (isBinary && this.protocol === 4) {\n            return this.onError(\"invalid content\");\n        }\n        this.dataReq = req;\n        this.dataRes = res;\n        let chunks = isBinary ? Buffer.concat([]) : \"\";\n        const cleanup = () => {\n            req.removeListener(\"data\", onData);\n            req.removeListener(\"end\", onEnd);\n            req.removeListener(\"close\", onClose);\n            this.dataReq = this.dataRes = chunks = null;\n        };\n        const onClose = () => {\n            cleanup();\n            this.onError(\"data request connection closed prematurely\");\n        };\n        const onData = (data) => {\n            let contentLength;\n            if (isBinary) {\n                chunks = Buffer.concat([chunks, data]);\n                contentLength = chunks.length;\n            }\n            else {\n                chunks += data;\n                contentLength = Buffer.byteLength(chunks);\n            }\n            if (contentLength > this.maxHttpBufferSize) {\n                res.writeHead(413).end();\n                cleanup();\n            }\n        };\n        const onEnd = () => {\n            this.onData(chunks);\n            const headers = {\n                // text/html is required instead of text/plain to avoid an\n                // unwanted download dialog on certain user-agents (GH-43)\n                \"Content-Type\": \"text/html\",\n                \"Content-Length\": \"2\",\n            };\n            res.writeHead(200, this.headers(req, headers));\n            res.end(\"ok\");\n            cleanup();\n        };\n        req.on(\"close\", onClose);\n        if (!isBinary)\n            req.setEncoding(\"utf8\");\n        req.on(\"data\", onData);\n        req.on(\"end\", onEnd);\n    }\n    /**\n     * Processes the incoming data payload.\n     *\n     * @param data - encoded payload\n     * @protected\n     */\n    onData(data) {\n        debug('received \"%s\"', data);\n        const callback = (packet) => {\n            if (\"close\" === packet.type) {\n                debug(\"got xhr close packet\");\n                this.onClose();\n                return false;\n            }\n            this.onPacket(packet);\n        };\n        if (this.protocol === 3) {\n            this.parser.decodePayload(data, callback);\n        }\n        else {\n            this.parser.decodePayload(data).forEach(callback);\n        }\n    }\n    /**\n     * Overrides onClose.\n     *\n     * @private\n     */\n    onClose() {\n        if (this.writable) {\n            // close pending poll request\n            this.send([{ type: \"noop\" }]);\n        }\n        super.onClose();\n    }\n    send(packets) {\n        this.writable = false;\n        if (this.shouldClose) {\n            debug(\"appending close packet to payload\");\n            packets.push({ type: \"close\" });\n            this.shouldClose();\n            this.shouldClose = null;\n        }\n        const doWrite = (data) => {\n            const compress = packets.some((packet) => {\n                return packet.options && packet.options.compress;\n            });\n            this.write(data, { compress });\n        };\n        if (this.protocol === 3) {\n            this.parser.encodePayload(packets, this.supportsBinary, doWrite);\n        }\n        else {\n            this.parser.encodePayload(packets, doWrite);\n        }\n    }\n    /**\n     * Writes data as response to poll request.\n     *\n     * @param {String} data\n     * @param {Object} options\n     * @private\n     */\n    write(data, options) {\n        debug('writing \"%s\"', data);\n        this.doWrite(data, options, () => {\n            this.req.cleanup();\n            this.emit(\"drain\");\n        });\n    }\n    /**\n     * Performs the write.\n     *\n     * @protected\n     */\n    doWrite(data, options, callback) {\n        // explicit UTF-8 is required for pages not served under utf\n        const isString = typeof data === \"string\";\n        const contentType = isString\n            ? \"text/plain; charset=UTF-8\"\n            : \"application/octet-stream\";\n        const headers = {\n            \"Content-Type\": contentType,\n        };\n        const respond = (data) => {\n            headers[\"Content-Length\"] =\n                \"string\" === typeof data ? Buffer.byteLength(data) : data.length;\n            this.res.writeHead(200, this.headers(this.req, headers));\n            this.res.end(data);\n            callback();\n        };\n        if (!this.httpCompression || !options.compress) {\n            respond(data);\n            return;\n        }\n        const len = isString ? Buffer.byteLength(data) : data.length;\n        if (len < this.httpCompression.threshold) {\n            respond(data);\n            return;\n        }\n        const encoding = accepts(this.req).encodings([\"gzip\", \"deflate\"]);\n        if (!encoding) {\n            respond(data);\n            return;\n        }\n        this.compress(data, encoding, (err, data) => {\n            if (err) {\n                this.res.writeHead(500);\n                this.res.end();\n                callback(err);\n                return;\n            }\n            headers[\"Content-Encoding\"] = encoding;\n            respond(data);\n        });\n    }\n    /**\n     * Compresses data.\n     *\n     * @private\n     */\n    compress(data, encoding, callback) {\n        debug(\"compressing\");\n        const buffers = [];\n        let nread = 0;\n        compressionMethods[encoding](this.httpCompression)\n            .on(\"error\", callback)\n            .on(\"data\", function (chunk) {\n            buffers.push(chunk);\n            nread += chunk.length;\n        })\n            .on(\"end\", function () {\n            callback(null, Buffer.concat(buffers, nread));\n        })\n            .end(data);\n    }\n    /**\n     * Closes the transport.\n     *\n     * @private\n     */\n    doClose(fn) {\n        debug(\"closing\");\n        let closeTimeoutTimer;\n        if (this.dataReq) {\n            debug(\"aborting ongoing data request\");\n            this.dataReq.destroy();\n        }\n        const onClose = () => {\n            clearTimeout(closeTimeoutTimer);\n            fn();\n            this.onClose();\n        };\n        if (this.writable) {\n            debug(\"transport writable - closing right away\");\n            this.send([{ type: \"close\" }]);\n            onClose();\n        }\n        else if (this.discarded) {\n            debug(\"transport discarded - closing right away\");\n            onClose();\n        }\n        else {\n            debug(\"transport not writable - buffering orderly close\");\n            this.shouldClose = onClose;\n            closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);\n        }\n    }\n    /**\n     * Returns headers for a response.\n     *\n     * @param {http.IncomingMessage} req\n     * @param {Object} headers - extra headers\n     * @private\n     */\n    headers(req, headers = {}) {\n        // prevent XSS warnings on IE\n        // https://github.com/LearnBoost/socket.io/pull/1333\n        const ua = req.headers[\"user-agent\"];\n        if (ua && (~ua.indexOf(\";MSIE\") || ~ua.indexOf(\"Trident/\"))) {\n            headers[\"X-XSS-Protection\"] = \"0\";\n        }\n        headers[\"cache-control\"] = \"no-store\";\n        this.emit(\"headers\", headers, req);\n        return headers;\n    }\n}\nexports.Polling = Polling;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC90cmFuc3BvcnRzL3BvbGxpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmLG9CQUFvQixtQkFBTyxDQUFDLHdFQUFjO0FBQzFDLGVBQWUsbUJBQU8sQ0FBQyxrQkFBTTtBQUM3QixnQkFBZ0IsbUJBQU8sQ0FBQyx1REFBUztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyw4RUFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsY0FBYztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsY0FBYztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiwrQkFBK0IsVUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQyxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlIiwic291cmNlcyI6WyIvVXNlcnMvc2FsL3JlZGlzLXByb2plY3Qvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC90cmFuc3BvcnRzL3BvbGxpbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBvbGxpbmcgPSB2b2lkIDA7XG5jb25zdCB0cmFuc3BvcnRfMSA9IHJlcXVpcmUoXCIuLi90cmFuc3BvcnRcIik7XG5jb25zdCB6bGliXzEgPSByZXF1aXJlKFwiemxpYlwiKTtcbmNvbnN0IGFjY2VwdHMgPSByZXF1aXJlKFwiYWNjZXB0c1wiKTtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwiZW5naW5lOnBvbGxpbmdcIik7XG5jb25zdCBjb21wcmVzc2lvbk1ldGhvZHMgPSB7XG4gICAgZ3ppcDogemxpYl8xLmNyZWF0ZUd6aXAsXG4gICAgZGVmbGF0ZTogemxpYl8xLmNyZWF0ZURlZmxhdGUsXG59O1xuY2xhc3MgUG9sbGluZyBleHRlbmRzIHRyYW5zcG9ydF8xLlRyYW5zcG9ydCB7XG4gICAgLyoqXG4gICAgICogSFRUUCBwb2xsaW5nIGNvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJlcSkge1xuICAgICAgICBzdXBlcihyZXEpO1xuICAgICAgICB0aGlzLmNsb3NlVGltZW91dCA9IDMwICogMTAwMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNwb3J0IG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwicG9sbGluZ1wiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgb25SZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbmdpbmVSZXF1ZXN0fSByZXFcbiAgICAgKiBAcGFja2FnZVxuICAgICAqL1xuICAgIG9uUmVxdWVzdChyZXEpIHtcbiAgICAgICAgY29uc3QgcmVzID0gcmVxLnJlcztcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSByZWZlcmVuY2UgdG8gdGhlIFNlcnZlclJlc3BvbnNlIG9iamVjdCAoYXMgdGhlIGZpcnN0IHJlcXVlc3Qgb2YgdGhlIHNlc3Npb24gaXMga2VwdCBpbiBtZW1vcnkgYnkgZGVmYXVsdClcbiAgICAgICAgcmVxLnJlcyA9IG51bGw7XG4gICAgICAgIGlmIChcIkdFVFwiID09PSByZXEubWV0aG9kKSB7XG4gICAgICAgICAgICB0aGlzLm9uUG9sbFJlcXVlc3QocmVxLCByZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFwiUE9TVFwiID09PSByZXEubWV0aG9kKSB7XG4gICAgICAgICAgICB0aGlzLm9uRGF0YVJlcXVlc3QocmVxLCByZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzLndyaXRlSGVhZCg1MDApO1xuICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjbGllbnQgc2VuZHMgYSByZXF1ZXN0IGF3YWl0aW5nIGZvciB1cyB0byBzZW5kIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uUG9sbFJlcXVlc3QocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKHRoaXMucmVxKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInJlcXVlc3Qgb3ZlcmxhcFwiKTtcbiAgICAgICAgICAgIC8vIGFzc2VydDogdGhpcy5yZXMsICcucmVxIGFuZCAucmVzIHNob3VsZCBiZSAodW4pc2V0IHRvZ2V0aGVyJ1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwib3ZlcmxhcCBmcm9tIGNsaWVudFwiKTtcbiAgICAgICAgICAgIHJlcy53cml0ZUhlYWQoNDAwKTtcbiAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyhcInNldHRpbmcgcmVxdWVzdFwiKTtcbiAgICAgICAgdGhpcy5yZXEgPSByZXE7XG4gICAgICAgIHRoaXMucmVzID0gcmVzO1xuICAgICAgICBjb25zdCBvbkNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwicG9sbCBjb25uZWN0aW9uIGNsb3NlZCBwcmVtYXR1cmVseVwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlcS5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIG9uQ2xvc2UpO1xuICAgICAgICAgICAgdGhpcy5yZXEgPSB0aGlzLnJlcyA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHJlcS5jbGVhbnVwID0gY2xlYW51cDtcbiAgICAgICAgcmVxLm9uKFwiY2xvc2VcIiwgb25DbG9zZSk7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoXCJyZWFkeVwiKTtcbiAgICAgICAgLy8gaWYgd2UncmUgc3RpbGwgd3JpdGFibGUgYnV0IGhhZCBhIHBlbmRpbmcgY2xvc2UsIHRyaWdnZXIgYW4gZW1wdHkgc2VuZFxuICAgICAgICBpZiAodGhpcy53cml0YWJsZSAmJiB0aGlzLnNob3VsZENsb3NlKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInRyaWdnZXJpbmcgZW1wdHkgc2VuZCB0byBhcHBlbmQgY2xvc2UgcGFja2V0XCIpO1xuICAgICAgICAgICAgdGhpcy5zZW5kKFt7IHR5cGU6IFwibm9vcFwiIH1dKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY2xpZW50IHNlbmRzIGEgcmVxdWVzdCB3aXRoIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uRGF0YVJlcXVlc3QocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVJlcSkge1xuICAgICAgICAgICAgLy8gYXNzZXJ0OiB0aGlzLmRhdGFSZXMsICcuZGF0YVJlcSBhbmQgLmRhdGFSZXMgc2hvdWxkIGJlICh1bilzZXQgdG9nZXRoZXInXG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJkYXRhIHJlcXVlc3Qgb3ZlcmxhcCBmcm9tIGNsaWVudFwiKTtcbiAgICAgICAgICAgIHJlcy53cml0ZUhlYWQoNDAwKTtcbiAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0JpbmFyeSA9IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIgPT09IHJlcS5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdO1xuICAgICAgICBpZiAoaXNCaW5hcnkgJiYgdGhpcy5wcm90b2NvbCA9PT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub25FcnJvcihcImludmFsaWQgY29udGVudFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFSZXEgPSByZXE7XG4gICAgICAgIHRoaXMuZGF0YVJlcyA9IHJlcztcbiAgICAgICAgbGV0IGNodW5rcyA9IGlzQmluYXJ5ID8gQnVmZmVyLmNvbmNhdChbXSkgOiBcIlwiO1xuICAgICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVxLnJlbW92ZUxpc3RlbmVyKFwiZGF0YVwiLCBvbkRhdGEpO1xuICAgICAgICAgICAgcmVxLnJlbW92ZUxpc3RlbmVyKFwiZW5kXCIsIG9uRW5kKTtcbiAgICAgICAgICAgIHJlcS5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIG9uQ2xvc2UpO1xuICAgICAgICAgICAgdGhpcy5kYXRhUmVxID0gdGhpcy5kYXRhUmVzID0gY2h1bmtzID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25DbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIHRoaXMub25FcnJvcihcImRhdGEgcmVxdWVzdCBjb25uZWN0aW9uIGNsb3NlZCBwcmVtYXR1cmVseVwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25EYXRhID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGxldCBjb250ZW50TGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGlzQmluYXJ5KSB7XG4gICAgICAgICAgICAgICAgY2h1bmtzID0gQnVmZmVyLmNvbmNhdChbY2h1bmtzLCBkYXRhXSk7XG4gICAgICAgICAgICAgICAgY29udGVudExlbmd0aCA9IGNodW5rcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaHVua3MgKz0gZGF0YTtcbiAgICAgICAgICAgICAgICBjb250ZW50TGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoY2h1bmtzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250ZW50TGVuZ3RoID4gdGhpcy5tYXhIdHRwQnVmZmVyU2l6ZSkge1xuICAgICAgICAgICAgICAgIHJlcy53cml0ZUhlYWQoNDEzKS5lbmQoKTtcbiAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uRW5kID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkRhdGEoY2h1bmtzKTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgLy8gdGV4dC9odG1sIGlzIHJlcXVpcmVkIGluc3RlYWQgb2YgdGV4dC9wbGFpbiB0byBhdm9pZCBhblxuICAgICAgICAgICAgICAgIC8vIHVud2FudGVkIGRvd25sb2FkIGRpYWxvZyBvbiBjZXJ0YWluIHVzZXItYWdlbnRzIChHSC00MylcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvaHRtbFwiLFxuICAgICAgICAgICAgICAgIFwiQ29udGVudC1MZW5ndGhcIjogXCIyXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzLndyaXRlSGVhZCgyMDAsIHRoaXMuaGVhZGVycyhyZXEsIGhlYWRlcnMpKTtcbiAgICAgICAgICAgIHJlcy5lbmQoXCJva1wiKTtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxLm9uKFwiY2xvc2VcIiwgb25DbG9zZSk7XG4gICAgICAgIGlmICghaXNCaW5hcnkpXG4gICAgICAgICAgICByZXEuc2V0RW5jb2RpbmcoXCJ1dGY4XCIpO1xuICAgICAgICByZXEub24oXCJkYXRhXCIsIG9uRGF0YSk7XG4gICAgICAgIHJlcS5vbihcImVuZFwiLCBvbkVuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyB0aGUgaW5jb21pbmcgZGF0YSBwYXlsb2FkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgLSBlbmNvZGVkIHBheWxvYWRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25EYXRhKGRhdGEpIHtcbiAgICAgICAgZGVidWcoJ3JlY2VpdmVkIFwiJXNcIicsIGRhdGEpO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IChwYWNrZXQpID0+IHtcbiAgICAgICAgICAgIGlmIChcImNsb3NlXCIgPT09IHBhY2tldC50eXBlKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJnb3QgeGhyIGNsb3NlIHBhY2tldFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9uUGFja2V0KHBhY2tldCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnByb3RvY29sID09PSAzKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlci5kZWNvZGVQYXlsb2FkKGRhdGEsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VyLmRlY29kZVBheWxvYWQoZGF0YSkuZm9yRWFjaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIG9uQ2xvc2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLndyaXRhYmxlKSB7XG4gICAgICAgICAgICAvLyBjbG9zZSBwZW5kaW5nIHBvbGwgcmVxdWVzdFxuICAgICAgICAgICAgdGhpcy5zZW5kKFt7IHR5cGU6IFwibm9vcFwiIH1dKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5vbkNsb3NlKCk7XG4gICAgfVxuICAgIHNlbmQocGFja2V0cykge1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZENsb3NlKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImFwcGVuZGluZyBjbG9zZSBwYWNrZXQgdG8gcGF5bG9hZFwiKTtcbiAgICAgICAgICAgIHBhY2tldHMucHVzaCh7IHR5cGU6IFwiY2xvc2VcIiB9KTtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkQ2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkQ2xvc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvV3JpdGUgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29tcHJlc3MgPSBwYWNrZXRzLnNvbWUoKHBhY2tldCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYWNrZXQub3B0aW9ucyAmJiBwYWNrZXQub3B0aW9ucy5jb21wcmVzcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy53cml0ZShkYXRhLCB7IGNvbXByZXNzIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5wcm90b2NvbCA9PT0gMykge1xuICAgICAgICAgICAgdGhpcy5wYXJzZXIuZW5jb2RlUGF5bG9hZChwYWNrZXRzLCB0aGlzLnN1cHBvcnRzQmluYXJ5LCBkb1dyaXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VyLmVuY29kZVBheWxvYWQocGFja2V0cywgZG9Xcml0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGRhdGEgYXMgcmVzcG9uc2UgdG8gcG9sbCByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgd3JpdGUoZGF0YSwgb3B0aW9ucykge1xuICAgICAgICBkZWJ1Zygnd3JpdGluZyBcIiVzXCInLCBkYXRhKTtcbiAgICAgICAgdGhpcy5kb1dyaXRlKGRhdGEsIG9wdGlvbnMsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVxLmNsZWFudXAoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRyYWluXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIHdyaXRlLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGRvV3JpdGUoZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gZXhwbGljaXQgVVRGLTggaXMgcmVxdWlyZWQgZm9yIHBhZ2VzIG5vdCBzZXJ2ZWQgdW5kZXIgdXRmXG4gICAgICAgIGNvbnN0IGlzU3RyaW5nID0gdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCI7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gaXNTdHJpbmdcbiAgICAgICAgICAgID8gXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PVVURi04XCJcbiAgICAgICAgICAgIDogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIjtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IGNvbnRlbnRUeXBlLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25kID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJDb250ZW50LUxlbmd0aFwiXSA9XG4gICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGRhdGEgPyBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5yZXMud3JpdGVIZWFkKDIwMCwgdGhpcy5oZWFkZXJzKHRoaXMucmVxLCBoZWFkZXJzKSk7XG4gICAgICAgICAgICB0aGlzLnJlcy5lbmQoZGF0YSk7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIXRoaXMuaHR0cENvbXByZXNzaW9uIHx8ICFvcHRpb25zLmNvbXByZXNzKSB7XG4gICAgICAgICAgICByZXNwb25kKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbiA9IGlzU3RyaW5nID8gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSkgOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA8IHRoaXMuaHR0cENvbXByZXNzaW9uLnRocmVzaG9sZCkge1xuICAgICAgICAgICAgcmVzcG9uZChkYXRhKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmNvZGluZyA9IGFjY2VwdHModGhpcy5yZXEpLmVuY29kaW5ncyhbXCJnemlwXCIsIFwiZGVmbGF0ZVwiXSk7XG4gICAgICAgIGlmICghZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIHJlc3BvbmQoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21wcmVzcyhkYXRhLCBlbmNvZGluZywgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzLndyaXRlSGVhZCg1MDApO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGVhZGVyc1tcIkNvbnRlbnQtRW5jb2RpbmdcIl0gPSBlbmNvZGluZztcbiAgICAgICAgICAgIHJlc3BvbmQoZGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wcmVzc2VzIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbXByZXNzKGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgICBkZWJ1ZyhcImNvbXByZXNzaW5nXCIpO1xuICAgICAgICBjb25zdCBidWZmZXJzID0gW107XG4gICAgICAgIGxldCBucmVhZCA9IDA7XG4gICAgICAgIGNvbXByZXNzaW9uTWV0aG9kc1tlbmNvZGluZ10odGhpcy5odHRwQ29tcHJlc3Npb24pXG4gICAgICAgICAgICAub24oXCJlcnJvclwiLCBjYWxsYmFjaylcbiAgICAgICAgICAgIC5vbihcImRhdGFcIiwgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICBidWZmZXJzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgbnJlYWQgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIEJ1ZmZlci5jb25jYXQoYnVmZmVycywgbnJlYWQpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5lbmQoZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgdHJhbnNwb3J0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBkb0Nsb3NlKGZuKSB7XG4gICAgICAgIGRlYnVnKFwiY2xvc2luZ1wiKTtcbiAgICAgICAgbGV0IGNsb3NlVGltZW91dFRpbWVyO1xuICAgICAgICBpZiAodGhpcy5kYXRhUmVxKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImFib3J0aW5nIG9uZ29pbmcgZGF0YSByZXF1ZXN0XCIpO1xuICAgICAgICAgICAgdGhpcy5kYXRhUmVxLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbkNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNsb3NlVGltZW91dFRpbWVyKTtcbiAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMud3JpdGFibGUpIHtcbiAgICAgICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IHdyaXRhYmxlIC0gY2xvc2luZyByaWdodCBhd2F5XCIpO1xuICAgICAgICAgICAgdGhpcy5zZW5kKFt7IHR5cGU6IFwiY2xvc2VcIiB9XSk7XG4gICAgICAgICAgICBvbkNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kaXNjYXJkZWQpIHtcbiAgICAgICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IGRpc2NhcmRlZCAtIGNsb3NpbmcgcmlnaHQgYXdheVwiKTtcbiAgICAgICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IG5vdCB3cml0YWJsZSAtIGJ1ZmZlcmluZyBvcmRlcmx5IGNsb3NlXCIpO1xuICAgICAgICAgICAgdGhpcy5zaG91bGRDbG9zZSA9IG9uQ2xvc2U7XG4gICAgICAgICAgICBjbG9zZVRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQob25DbG9zZSwgdGhpcy5jbG9zZVRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaGVhZGVycyBmb3IgYSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJzIC0gZXh0cmEgaGVhZGVyc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaGVhZGVycyhyZXEsIGhlYWRlcnMgPSB7fSkge1xuICAgICAgICAvLyBwcmV2ZW50IFhTUyB3YXJuaW5ncyBvbiBJRVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTGVhcm5Cb29zdC9zb2NrZXQuaW8vcHVsbC8xMzMzXG4gICAgICAgIGNvbnN0IHVhID0gcmVxLmhlYWRlcnNbXCJ1c2VyLWFnZW50XCJdO1xuICAgICAgICBpZiAodWEgJiYgKH51YS5pbmRleE9mKFwiO01TSUVcIikgfHwgfnVhLmluZGV4T2YoXCJUcmlkZW50L1wiKSkpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJYLVhTUy1Qcm90ZWN0aW9uXCJdID0gXCIwXCI7XG4gICAgICAgIH1cbiAgICAgICAgaGVhZGVyc1tcImNhY2hlLWNvbnRyb2xcIl0gPSBcIm5vLXN0b3JlXCI7XG4gICAgICAgIHRoaXMuZW1pdChcImhlYWRlcnNcIiwgaGVhZGVycywgcmVxKTtcbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxufVxuZXhwb3J0cy5Qb2xsaW5nID0gUG9sbGluZztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/engine.io/build/transports/polling.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/engine.io/build/transports/websocket.js":
/*!***************************************************************!*\
  !*** ../node_modules/engine.io/build/transports/websocket.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WebSocket = void 0;\nconst transport_1 = __webpack_require__(/*! ../transport */ \"(rsc)/../node_modules/engine.io/build/transport.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/../node_modules/engine.io/node_modules/debug/src/index.js\");\nconst debug = (0, debug_1.default)(\"engine:ws\");\nclass WebSocket extends transport_1.Transport {\n    /**\n     * WebSocket transport\n     *\n     * @param {EngineRequest} req\n     */\n    constructor(req) {\n        super(req);\n        this._doSend = (data) => {\n            this.socket.send(data, this._onSent);\n        };\n        this._doSendLast = (data) => {\n            this.socket.send(data, this._onSentLast);\n        };\n        this._onSent = (err) => {\n            if (err) {\n                this.onError(\"write error\", err.stack);\n            }\n        };\n        this._onSentLast = (err) => {\n            if (err) {\n                this.onError(\"write error\", err.stack);\n            }\n            else {\n                this.emit(\"drain\");\n                this.writable = true;\n                this.emit(\"ready\");\n            }\n        };\n        this.socket = req.websocket;\n        this.socket.on(\"message\", (data, isBinary) => {\n            const message = isBinary ? data : data.toString();\n            debug('received \"%s\"', message);\n            super.onData(message);\n        });\n        this.socket.once(\"close\", this.onClose.bind(this));\n        this.socket.on(\"error\", this.onError.bind(this));\n        this.writable = true;\n        this.perMessageDeflate = null;\n    }\n    /**\n     * Transport name\n     */\n    get name() {\n        return \"websocket\";\n    }\n    /**\n     * Advertise upgrade support.\n     */\n    get handlesUpgrades() {\n        return true;\n    }\n    send(packets) {\n        this.writable = false;\n        for (let i = 0; i < packets.length; i++) {\n            const packet = packets[i];\n            const isLast = i + 1 === packets.length;\n            if (this._canSendPreEncodedFrame(packet)) {\n                // the WebSocket frame was computed with WebSocket.Sender.frame()\n                // see https://github.com/websockets/ws/issues/617#issuecomment-283002469\n                this.socket._sender.sendFrame(\n                // @ts-ignore\n                packet.options.wsPreEncodedFrame, isLast ? this._onSentLast : this._onSent);\n            }\n            else {\n                this.parser.encodePacket(packet, this.supportsBinary, isLast ? this._doSendLast : this._doSend);\n            }\n        }\n    }\n    /**\n     * Whether the encoding of the WebSocket frame can be skipped.\n     * @param packet\n     * @private\n     */\n    _canSendPreEncodedFrame(packet) {\n        var _a, _b, _c;\n        return (!this.perMessageDeflate &&\n            typeof ((_b = (_a = this.socket) === null || _a === void 0 ? void 0 : _a._sender) === null || _b === void 0 ? void 0 : _b.sendFrame) === \"function\" &&\n            // @ts-ignore\n            ((_c = packet.options) === null || _c === void 0 ? void 0 : _c.wsPreEncodedFrame) !== undefined);\n    }\n    doClose(fn) {\n        debug(\"closing\");\n        this.socket.close();\n        fn && fn();\n    }\n}\nexports.WebSocket = WebSocket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC90cmFuc3BvcnRzL3dlYnNvY2tldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsb0JBQW9CLG1CQUFPLENBQUMsd0VBQWM7QUFDMUMsZ0JBQWdCLG1CQUFPLENBQUMsOEVBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCIiwic291cmNlcyI6WyIvVXNlcnMvc2FsL3JlZGlzLXByb2plY3Qvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC90cmFuc3BvcnRzL3dlYnNvY2tldC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2ViU29ja2V0ID0gdm9pZCAwO1xuY29uc3QgdHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi4vdHJhbnNwb3J0XCIpO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoXCJlbmdpbmU6d3NcIik7XG5jbGFzcyBXZWJTb2NrZXQgZXh0ZW5kcyB0cmFuc3BvcnRfMS5UcmFuc3BvcnQge1xuICAgIC8qKlxuICAgICAqIFdlYlNvY2tldCB0cmFuc3BvcnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RW5naW5lUmVxdWVzdH0gcmVxXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVxKSB7XG4gICAgICAgIHN1cGVyKHJlcSk7XG4gICAgICAgIHRoaXMuX2RvU2VuZCA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5zZW5kKGRhdGEsIHRoaXMuX29uU2VudCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2RvU2VuZExhc3QgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQuc2VuZChkYXRhLCB0aGlzLl9vblNlbnRMYXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fb25TZW50ID0gKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcihcIndyaXRlIGVycm9yXCIsIGVyci5zdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX29uU2VudExhc3QgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwid3JpdGUgZXJyb3JcIiwgZXJyLnN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRyYWluXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcInJlYWR5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNvY2tldCA9IHJlcS53ZWJzb2NrZXQ7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uKFwibWVzc2FnZVwiLCAoZGF0YSwgaXNCaW5hcnkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBpc0JpbmFyeSA/IGRhdGEgOiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBkZWJ1ZygncmVjZWl2ZWQgXCIlc1wiJywgbWVzc2FnZSk7XG4gICAgICAgICAgICBzdXBlci5vbkRhdGEobWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNvY2tldC5vbmNlKFwiY2xvc2VcIiwgdGhpcy5vbkNsb3NlLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnNvY2tldC5vbihcImVycm9yXCIsIHRoaXMub25FcnJvci5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc3BvcnQgbmFtZVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJ3ZWJzb2NrZXRcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWR2ZXJ0aXNlIHVwZ3JhZGUgc3VwcG9ydC5cbiAgICAgKi9cbiAgICBnZXQgaGFuZGxlc1VwZ3JhZGVzKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc2VuZChwYWNrZXRzKSB7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYWNrZXQgPSBwYWNrZXRzW2ldO1xuICAgICAgICAgICAgY29uc3QgaXNMYXN0ID0gaSArIDEgPT09IHBhY2tldHMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NhblNlbmRQcmVFbmNvZGVkRnJhbWUocGFja2V0KSkge1xuICAgICAgICAgICAgICAgIC8vIHRoZSBXZWJTb2NrZXQgZnJhbWUgd2FzIGNvbXB1dGVkIHdpdGggV2ViU29ja2V0LlNlbmRlci5mcmFtZSgpXG4gICAgICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL2lzc3Vlcy82MTcjaXNzdWVjb21tZW50LTI4MzAwMjQ2OVxuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0Ll9zZW5kZXIuc2VuZEZyYW1lKFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBwYWNrZXQub3B0aW9ucy53c1ByZUVuY29kZWRGcmFtZSwgaXNMYXN0ID8gdGhpcy5fb25TZW50TGFzdCA6IHRoaXMuX29uU2VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlci5lbmNvZGVQYWNrZXQocGFja2V0LCB0aGlzLnN1cHBvcnRzQmluYXJ5LCBpc0xhc3QgPyB0aGlzLl9kb1NlbmRMYXN0IDogdGhpcy5fZG9TZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBlbmNvZGluZyBvZiB0aGUgV2ViU29ja2V0IGZyYW1lIGNhbiBiZSBza2lwcGVkLlxuICAgICAqIEBwYXJhbSBwYWNrZXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYW5TZW5kUHJlRW5jb2RlZEZyYW1lKHBhY2tldCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgcmV0dXJuICghdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSAmJlxuICAgICAgICAgICAgdHlwZW9mICgoX2IgPSAoX2EgPSB0aGlzLnNvY2tldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLl9zZW5kZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zZW5kRnJhbWUpID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICgoX2MgPSBwYWNrZXQub3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLndzUHJlRW5jb2RlZEZyYW1lKSAhPT0gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgZG9DbG9zZShmbikge1xuICAgICAgICBkZWJ1ZyhcImNsb3NpbmdcIik7XG4gICAgICAgIHRoaXMuc29ja2V0LmNsb3NlKCk7XG4gICAgICAgIGZuICYmIGZuKCk7XG4gICAgfVxufVxuZXhwb3J0cy5XZWJTb2NrZXQgPSBXZWJTb2NrZXQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/engine.io/build/transports/websocket.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/engine.io/build/transports/webtransport.js":
/*!******************************************************************!*\
  !*** ../node_modules/engine.io/build/transports/webtransport.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WebTransport = void 0;\nconst transport_1 = __webpack_require__(/*! ../transport */ \"(rsc)/../node_modules/engine.io/build/transport.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/../node_modules/engine.io/node_modules/debug/src/index.js\");\nconst engine_io_parser_1 = __webpack_require__(/*! engine.io-parser */ \"(rsc)/../node_modules/engine.io-parser/build/cjs/index.js\");\nconst debug = (0, debug_1.default)(\"engine:webtransport\");\n/**\n * Reference: https://developer.mozilla.org/en-US/docs/Web/API/WebTransport_API\n */\nclass WebTransport extends transport_1.Transport {\n    constructor(session, stream, reader) {\n        super({ _query: { EIO: \"4\" } });\n        this.session = session;\n        const transformStream = (0, engine_io_parser_1.createPacketEncoderStream)();\n        transformStream.readable.pipeTo(stream.writable).catch(() => {\n            debug(\"the stream was closed\");\n        });\n        this.writer = transformStream.writable.getWriter();\n        (async () => {\n            try {\n                while (true) {\n                    const { value, done } = await reader.read();\n                    if (done) {\n                        debug(\"session is closed\");\n                        break;\n                    }\n                    debug(\"received chunk: %o\", value);\n                    this.onPacket(value);\n                }\n            }\n            catch (e) {\n                debug(\"error while reading: %s\", e.message);\n            }\n        })();\n        session.closed.then(() => this.onClose());\n        this.writable = true;\n    }\n    get name() {\n        return \"webtransport\";\n    }\n    async send(packets) {\n        this.writable = false;\n        try {\n            for (let i = 0; i < packets.length; i++) {\n                const packet = packets[i];\n                await this.writer.write(packet);\n            }\n        }\n        catch (e) {\n            debug(\"error while writing: %s\", e.message);\n        }\n        this.emit(\"drain\");\n        this.writable = true;\n        this.emit(\"ready\");\n    }\n    doClose(fn) {\n        debug(\"closing WebTransport session\");\n        this.session.close();\n        fn && fn();\n    }\n}\nexports.WebTransport = WebTransport;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC90cmFuc3BvcnRzL3dlYnRyYW5zcG9ydC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEIsb0JBQW9CLG1CQUFPLENBQUMsd0VBQWM7QUFDMUMsZ0JBQWdCLG1CQUFPLENBQUMsOEVBQU87QUFDL0IsMkJBQTJCLG1CQUFPLENBQUMsbUZBQWtCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVLFlBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhbC9yZWRpcy1wcm9qZWN0L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vYnVpbGQvdHJhbnNwb3J0cy93ZWJ0cmFuc3BvcnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldlYlRyYW5zcG9ydCA9IHZvaWQgMDtcbmNvbnN0IHRyYW5zcG9ydF8xID0gcmVxdWlyZShcIi4uL3RyYW5zcG9ydFwiKTtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBlbmdpbmVfaW9fcGFyc2VyXzEgPSByZXF1aXJlKFwiZW5naW5lLmlvLXBhcnNlclwiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoXCJlbmdpbmU6d2VidHJhbnNwb3J0XCIpO1xuLyoqXG4gKiBSZWZlcmVuY2U6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJUcmFuc3BvcnRfQVBJXG4gKi9cbmNsYXNzIFdlYlRyYW5zcG9ydCBleHRlbmRzIHRyYW5zcG9ydF8xLlRyYW5zcG9ydCB7XG4gICAgY29uc3RydWN0b3Ioc2Vzc2lvbiwgc3RyZWFtLCByZWFkZXIpIHtcbiAgICAgICAgc3VwZXIoeyBfcXVlcnk6IHsgRUlPOiBcIjRcIiB9IH0pO1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1TdHJlYW0gPSAoMCwgZW5naW5lX2lvX3BhcnNlcl8xLmNyZWF0ZVBhY2tldEVuY29kZXJTdHJlYW0pKCk7XG4gICAgICAgIHRyYW5zZm9ybVN0cmVhbS5yZWFkYWJsZS5waXBlVG8oc3RyZWFtLndyaXRhYmxlKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyhcInRoZSBzdHJlYW0gd2FzIGNsb3NlZFwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud3JpdGVyID0gdHJhbnNmb3JtU3RyZWFtLndyaXRhYmxlLmdldFdyaXRlcigpO1xuICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJzZXNzaW9uIGlzIGNsb3NlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwicmVjZWl2ZWQgY2h1bms6ICVvXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblBhY2tldCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImVycm9yIHdoaWxlIHJlYWRpbmc6ICVzXCIsIGUubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHNlc3Npb24uY2xvc2VkLnRoZW4oKCkgPT4gdGhpcy5vbkNsb3NlKCkpO1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIndlYnRyYW5zcG9ydFwiO1xuICAgIH1cbiAgICBhc3luYyBzZW5kKHBhY2tldHMpIHtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFja2V0ID0gcGFja2V0c1tpXTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLndyaXRlci53cml0ZShwYWNrZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImVycm9yIHdoaWxlIHdyaXRpbmc6ICVzXCIsIGUubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFwiZHJhaW5cIik7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoXCJyZWFkeVwiKTtcbiAgICB9XG4gICAgZG9DbG9zZShmbikge1xuICAgICAgICBkZWJ1ZyhcImNsb3NpbmcgV2ViVHJhbnNwb3J0IHNlc3Npb25cIik7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5jbG9zZSgpO1xuICAgICAgICBmbiAmJiBmbigpO1xuICAgIH1cbn1cbmV4cG9ydHMuV2ViVHJhbnNwb3J0ID0gV2ViVHJhbnNwb3J0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/engine.io/build/transports/webtransport.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/engine.io/build/userver.js":
/*!**************************************************!*\
  !*** ../node_modules/engine.io/build/userver.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.uServer = void 0;\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/../node_modules/engine.io/node_modules/debug/src/index.js\");\nconst server_1 = __webpack_require__(/*! ./server */ \"(rsc)/../node_modules/engine.io/build/server.js\");\nconst transports_uws_1 = __webpack_require__(/*! ./transports-uws */ \"(rsc)/../node_modules/engine.io/build/transports-uws/index.js\");\nconst debug = (0, debug_1.default)(\"engine:uws\");\n/**\n * An Engine.IO server based on the `uWebSockets.js` package.\n */\n// TODO export it into its own package\nclass uServer extends server_1.BaseServer {\n    init() { }\n    cleanup() { }\n    /**\n     * Prepares a request by processing the query string.\n     *\n     * @private\n     */\n    prepare(req, res) {\n        req.method = req.getMethod().toUpperCase();\n        req.url = req.getUrl();\n        const params = new URLSearchParams(req.getQuery());\n        req._query = Object.fromEntries(params.entries());\n        req.headers = {};\n        req.forEach((key, value) => {\n            req.headers[key] = value;\n        });\n        req.connection = {\n            remoteAddress: Buffer.from(res.getRemoteAddressAsText()).toString(),\n        };\n        res.onAborted(() => {\n            debug(\"response has been aborted\");\n        });\n    }\n    createTransport(transportName, req) {\n        return new transports_uws_1.default[transportName](req);\n    }\n    /**\n     * Attach the engine to a ÂµWebSockets.js server\n     * @param app\n     * @param options\n     */\n    attach(app /* : TemplatedApp */, options = {}) {\n        const path = this._computePath(options);\n        app\n            .any(path, this.handleRequest.bind(this))\n            //\n            .ws(path, {\n            compression: options.compression,\n            idleTimeout: options.idleTimeout,\n            maxBackpressure: options.maxBackpressure,\n            maxPayloadLength: this.opts.maxHttpBufferSize,\n            upgrade: this.handleUpgrade.bind(this),\n            open: (ws) => {\n                const transport = ws.getUserData().transport;\n                transport.socket = ws;\n                transport.writable = true;\n                transport.emit(\"ready\");\n            },\n            message: (ws, message, isBinary) => {\n                ws.getUserData().transport.onData(isBinary ? message : Buffer.from(message).toString());\n            },\n            close: (ws, code, message) => {\n                ws.getUserData().transport.onClose(code, message);\n            },\n        });\n    }\n    _applyMiddlewares(req, res, callback) {\n        if (this.middlewares.length === 0) {\n            return callback();\n        }\n        // needed to buffer headers until the status is computed\n        req.res = new ResponseWrapper(res);\n        super._applyMiddlewares(req, req.res, (err) => {\n            // some middlewares (like express-session) wait for the writeHead() call to flush their headers\n            // see https://github.com/expressjs/session/blob/1010fadc2f071ddf2add94235d72224cf65159c6/index.js#L220-L244\n            req.res.writeHead();\n            callback(err);\n        });\n    }\n    handleRequest(res, req) {\n        debug('handling \"%s\" http request \"%s\"', req.getMethod(), req.getUrl());\n        this.prepare(req, res);\n        req.res = res;\n        const callback = (errorCode, errorContext) => {\n            if (errorCode !== undefined) {\n                this.emit(\"connection_error\", {\n                    req,\n                    code: errorCode,\n                    message: server_1.Server.errorMessages[errorCode],\n                    context: errorContext,\n                });\n                this.abortRequest(req.res, errorCode, errorContext);\n                return;\n            }\n            if (req._query.sid) {\n                debug(\"setting new request for existing client\");\n                // @ts-ignore\n                this.clients[req._query.sid].transport.onRequest(req);\n            }\n            else {\n                const closeConnection = (errorCode, errorContext) => this.abortRequest(res, errorCode, errorContext);\n                this.handshake(req._query.transport, req, closeConnection);\n            }\n        };\n        this._applyMiddlewares(req, res, (err) => {\n            if (err) {\n                callback(server_1.Server.errors.BAD_REQUEST, { name: \"MIDDLEWARE_FAILURE\" });\n            }\n            else {\n                this.verify(req, false, callback);\n            }\n        });\n    }\n    handleUpgrade(res, req, context) {\n        debug(\"on upgrade\");\n        this.prepare(req, res);\n        req.res = res;\n        const callback = async (errorCode, errorContext) => {\n            if (errorCode !== undefined) {\n                this.emit(\"connection_error\", {\n                    req,\n                    code: errorCode,\n                    message: server_1.Server.errorMessages[errorCode],\n                    context: errorContext,\n                });\n                this.abortRequest(res, errorCode, errorContext);\n                return;\n            }\n            const id = req._query.sid;\n            let transport;\n            if (id) {\n                const client = this.clients[id];\n                if (!client) {\n                    debug(\"upgrade attempt for closed client\");\n                    return res.close();\n                }\n                else if (client.upgrading) {\n                    debug(\"transport has already been trying to upgrade\");\n                    return res.close();\n                }\n                else if (client.upgraded) {\n                    debug(\"transport had already been upgraded\");\n                    return res.close();\n                }\n                else {\n                    debug(\"upgrading existing transport\");\n                    transport = this.createTransport(req._query.transport, req);\n                    client._maybeUpgrade(transport);\n                }\n            }\n            else {\n                transport = await this.handshake(req._query.transport, req, (errorCode, errorContext) => this.abortRequest(res, errorCode, errorContext));\n                if (!transport) {\n                    return;\n                }\n            }\n            // calling writeStatus() triggers the flushing of any header added in a middleware\n            req.res.writeStatus(\"101 Switching Protocols\");\n            res.upgrade({\n                transport,\n            }, req.getHeader(\"sec-websocket-key\"), req.getHeader(\"sec-websocket-protocol\"), req.getHeader(\"sec-websocket-extensions\"), context);\n        };\n        this._applyMiddlewares(req, res, (err) => {\n            if (err) {\n                callback(server_1.Server.errors.BAD_REQUEST, { name: \"MIDDLEWARE_FAILURE\" });\n            }\n            else {\n                this.verify(req, true, callback);\n            }\n        });\n    }\n    abortRequest(res, errorCode, errorContext) {\n        const statusCode = errorCode === server_1.Server.errors.FORBIDDEN\n            ? \"403 Forbidden\"\n            : \"400 Bad Request\";\n        const message = errorContext && errorContext.message\n            ? errorContext.message\n            : server_1.Server.errorMessages[errorCode];\n        res.writeStatus(statusCode);\n        res.writeHeader(\"Content-Type\", \"application/json\");\n        res.end(JSON.stringify({\n            code: errorCode,\n            message,\n        }));\n    }\n}\nexports.uServer = uServer;\nclass ResponseWrapper {\n    constructor(res) {\n        this.res = res;\n        this.statusWritten = false;\n        this.headers = [];\n        this.isAborted = false;\n    }\n    set statusCode(status) {\n        if (!status) {\n            return;\n        }\n        // FIXME: handle all status codes?\n        this.writeStatus(status === 200 ? \"200 OK\" : \"204 No Content\");\n    }\n    writeHead(status) {\n        this.statusCode = status;\n    }\n    setHeader(key, value) {\n        if (Array.isArray(value)) {\n            value.forEach((val) => {\n                this.writeHeader(key, val);\n            });\n        }\n        else {\n            this.writeHeader(key, value);\n        }\n    }\n    removeHeader() {\n        // FIXME: not implemented\n    }\n    // needed by vary: https://github.com/jshttp/vary/blob/5d725d059b3871025cf753e9dfa08924d0bcfa8f/index.js#L134\n    getHeader() { }\n    writeStatus(status) {\n        if (this.isAborted)\n            return;\n        this.res.writeStatus(status);\n        this.statusWritten = true;\n        this.writeBufferedHeaders();\n        return this;\n    }\n    writeHeader(key, value) {\n        if (this.isAborted)\n            return;\n        if (key === \"Content-Length\") {\n            // the content length is automatically added by uWebSockets.js\n            return;\n        }\n        if (this.statusWritten) {\n            this.res.writeHeader(key, value);\n        }\n        else {\n            this.headers.push([key, value]);\n        }\n    }\n    writeBufferedHeaders() {\n        this.headers.forEach(([key, value]) => {\n            this.res.writeHeader(key, value);\n        });\n    }\n    end(data) {\n        if (this.isAborted)\n            return;\n        this.res.cork(() => {\n            if (!this.statusWritten) {\n                // status will be inferred as \"200 OK\"\n                this.writeBufferedHeaders();\n            }\n            this.res.end(data);\n        });\n    }\n    onData(fn) {\n        if (this.isAborted)\n            return;\n        this.res.onData(fn);\n    }\n    onAborted(fn) {\n        if (this.isAborted)\n            return;\n        this.res.onAborted(() => {\n            // Any attempt to use the UWS response object after abort will throw!\n            this.isAborted = true;\n            fn();\n        });\n    }\n    cork(fn) {\n        if (this.isAborted)\n            return;\n        this.res.cork(fn);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC91c2VydmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixnQkFBZ0IsbUJBQU8sQ0FBQyw4RUFBTztBQUMvQixpQkFBaUIsbUJBQU8sQ0FBQyxpRUFBVTtBQUNuQyx5QkFBeUIsbUJBQU8sQ0FBQyx1RkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELDRCQUE0QjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsNEJBQTRCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWwvcmVkaXMtcHJvamVjdC9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3VzZXJ2ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVTZXJ2ZXIgPSB2b2lkIDA7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3Qgc2VydmVyXzEgPSByZXF1aXJlKFwiLi9zZXJ2ZXJcIik7XG5jb25zdCB0cmFuc3BvcnRzX3V3c18xID0gcmVxdWlyZShcIi4vdHJhbnNwb3J0cy11d3NcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwiZW5naW5lOnV3c1wiKTtcbi8qKlxuICogQW4gRW5naW5lLklPIHNlcnZlciBiYXNlZCBvbiB0aGUgYHVXZWJTb2NrZXRzLmpzYCBwYWNrYWdlLlxuICovXG4vLyBUT0RPIGV4cG9ydCBpdCBpbnRvIGl0cyBvd24gcGFja2FnZVxuY2xhc3MgdVNlcnZlciBleHRlbmRzIHNlcnZlcl8xLkJhc2VTZXJ2ZXIge1xuICAgIGluaXQoKSB7IH1cbiAgICBjbGVhbnVwKCkgeyB9XG4gICAgLyoqXG4gICAgICogUHJlcGFyZXMgYSByZXF1ZXN0IGJ5IHByb2Nlc3NpbmcgdGhlIHF1ZXJ5IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHJlcGFyZShyZXEsIHJlcykge1xuICAgICAgICByZXEubWV0aG9kID0gcmVxLmdldE1ldGhvZCgpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHJlcS51cmwgPSByZXEuZ2V0VXJsKCk7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocmVxLmdldFF1ZXJ5KCkpO1xuICAgICAgICByZXEuX3F1ZXJ5ID0gT2JqZWN0LmZyb21FbnRyaWVzKHBhcmFtcy5lbnRyaWVzKCkpO1xuICAgICAgICByZXEuaGVhZGVycyA9IHt9O1xuICAgICAgICByZXEuZm9yRWFjaCgoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmVxLmhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVxLmNvbm5lY3Rpb24gPSB7XG4gICAgICAgICAgICByZW1vdGVBZGRyZXNzOiBCdWZmZXIuZnJvbShyZXMuZ2V0UmVtb3RlQWRkcmVzc0FzVGV4dCgpKS50b1N0cmluZygpLFxuICAgICAgICB9O1xuICAgICAgICByZXMub25BYm9ydGVkKCgpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKFwicmVzcG9uc2UgaGFzIGJlZW4gYWJvcnRlZFwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZVRyYW5zcG9ydCh0cmFuc3BvcnROYW1lLCByZXEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0cmFuc3BvcnRzX3V3c18xLmRlZmF1bHRbdHJhbnNwb3J0TmFtZV0ocmVxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0YWNoIHRoZSBlbmdpbmUgdG8gYSDCtVdlYlNvY2tldHMuanMgc2VydmVyXG4gICAgICogQHBhcmFtIGFwcFxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgYXR0YWNoKGFwcCAvKiA6IFRlbXBsYXRlZEFwcCAqLywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSB0aGlzLl9jb21wdXRlUGF0aChvcHRpb25zKTtcbiAgICAgICAgYXBwXG4gICAgICAgICAgICAuYW55KHBhdGgsIHRoaXMuaGFuZGxlUmVxdWVzdC5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC53cyhwYXRoLCB7XG4gICAgICAgICAgICBjb21wcmVzc2lvbjogb3B0aW9ucy5jb21wcmVzc2lvbixcbiAgICAgICAgICAgIGlkbGVUaW1lb3V0OiBvcHRpb25zLmlkbGVUaW1lb3V0LFxuICAgICAgICAgICAgbWF4QmFja3ByZXNzdXJlOiBvcHRpb25zLm1heEJhY2twcmVzc3VyZSxcbiAgICAgICAgICAgIG1heFBheWxvYWRMZW5ndGg6IHRoaXMub3B0cy5tYXhIdHRwQnVmZmVyU2l6ZSxcbiAgICAgICAgICAgIHVwZ3JhZGU6IHRoaXMuaGFuZGxlVXBncmFkZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgb3BlbjogKHdzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNwb3J0ID0gd3MuZ2V0VXNlckRhdGEoKS50cmFuc3BvcnQ7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LnNvY2tldCA9IHdzO1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC53cml0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LmVtaXQoXCJyZWFkeVwiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZXNzYWdlOiAod3MsIG1lc3NhZ2UsIGlzQmluYXJ5KSA9PiB7XG4gICAgICAgICAgICAgICAgd3MuZ2V0VXNlckRhdGEoKS50cmFuc3BvcnQub25EYXRhKGlzQmluYXJ5ID8gbWVzc2FnZSA6IEJ1ZmZlci5mcm9tKG1lc3NhZ2UpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlOiAod3MsIGNvZGUsIG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICB3cy5nZXRVc2VyRGF0YSgpLnRyYW5zcG9ydC5vbkNsb3NlKGNvZGUsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hcHBseU1pZGRsZXdhcmVzKHJlcSwgcmVzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5taWRkbGV3YXJlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5lZWRlZCB0byBidWZmZXIgaGVhZGVycyB1bnRpbCB0aGUgc3RhdHVzIGlzIGNvbXB1dGVkXG4gICAgICAgIHJlcS5yZXMgPSBuZXcgUmVzcG9uc2VXcmFwcGVyKHJlcyk7XG4gICAgICAgIHN1cGVyLl9hcHBseU1pZGRsZXdhcmVzKHJlcSwgcmVxLnJlcywgKGVycikgPT4ge1xuICAgICAgICAgICAgLy8gc29tZSBtaWRkbGV3YXJlcyAobGlrZSBleHByZXNzLXNlc3Npb24pIHdhaXQgZm9yIHRoZSB3cml0ZUhlYWQoKSBjYWxsIHRvIGZsdXNoIHRoZWlyIGhlYWRlcnNcbiAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXhwcmVzc2pzL3Nlc3Npb24vYmxvYi8xMDEwZmFkYzJmMDcxZGRmMmFkZDk0MjM1ZDcyMjI0Y2Y2NTE1OWM2L2luZGV4LmpzI0wyMjAtTDI0NFxuICAgICAgICAgICAgcmVxLnJlcy53cml0ZUhlYWQoKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVSZXF1ZXN0KHJlcywgcmVxKSB7XG4gICAgICAgIGRlYnVnKCdoYW5kbGluZyBcIiVzXCIgaHR0cCByZXF1ZXN0IFwiJXNcIicsIHJlcS5nZXRNZXRob2QoKSwgcmVxLmdldFVybCgpKTtcbiAgICAgICAgdGhpcy5wcmVwYXJlKHJlcSwgcmVzKTtcbiAgICAgICAgcmVxLnJlcyA9IHJlcztcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAoZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvckNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3Rpb25fZXJyb3JcIiwge1xuICAgICAgICAgICAgICAgICAgICByZXEsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGVycm9yQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogc2VydmVyXzEuU2VydmVyLmVycm9yTWVzc2FnZXNbZXJyb3JDb2RlXSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogZXJyb3JDb250ZXh0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuYWJvcnRSZXF1ZXN0KHJlcS5yZXMsIGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxLl9xdWVyeS5zaWQpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInNldHRpbmcgbmV3IHJlcXVlc3QgZm9yIGV4aXN0aW5nIGNsaWVudFwiKTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnRzW3JlcS5fcXVlcnkuc2lkXS50cmFuc3BvcnQub25SZXF1ZXN0KHJlcSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbG9zZUNvbm5lY3Rpb24gPSAoZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpID0+IHRoaXMuYWJvcnRSZXF1ZXN0KHJlcywgZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZHNoYWtlKHJlcS5fcXVlcnkudHJhbnNwb3J0LCByZXEsIGNsb3NlQ29ubmVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2FwcGx5TWlkZGxld2FyZXMocmVxLCByZXMsIChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhzZXJ2ZXJfMS5TZXJ2ZXIuZXJyb3JzLkJBRF9SRVFVRVNULCB7IG5hbWU6IFwiTUlERExFV0FSRV9GQUlMVVJFXCIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZlcmlmeShyZXEsIGZhbHNlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVVcGdyYWRlKHJlcywgcmVxLCBjb250ZXh0KSB7XG4gICAgICAgIGRlYnVnKFwib24gdXBncmFkZVwiKTtcbiAgICAgICAgdGhpcy5wcmVwYXJlKHJlcSwgcmVzKTtcbiAgICAgICAgcmVxLnJlcyA9IHJlcztcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBhc3luYyAoZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvckNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3Rpb25fZXJyb3JcIiwge1xuICAgICAgICAgICAgICAgICAgICByZXEsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGVycm9yQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogc2VydmVyXzEuU2VydmVyLmVycm9yTWVzc2FnZXNbZXJyb3JDb2RlXSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogZXJyb3JDb250ZXh0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuYWJvcnRSZXF1ZXN0KHJlcywgZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlkID0gcmVxLl9xdWVyeS5zaWQ7XG4gICAgICAgICAgICBsZXQgdHJhbnNwb3J0O1xuICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnRzW2lkXTtcbiAgICAgICAgICAgICAgICBpZiAoIWNsaWVudCkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcInVwZ3JhZGUgYXR0ZW1wdCBmb3IgY2xvc2VkIGNsaWVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjbGllbnQudXBncmFkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IGhhcyBhbHJlYWR5IGJlZW4gdHJ5aW5nIHRvIHVwZ3JhZGVcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2xpZW50LnVwZ3JhZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IGhhZCBhbHJlYWR5IGJlZW4gdXBncmFkZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwidXBncmFkaW5nIGV4aXN0aW5nIHRyYW5zcG9ydFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQocmVxLl9xdWVyeS50cmFuc3BvcnQsIHJlcSk7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudC5fbWF5YmVVcGdyYWRlKHRyYW5zcG9ydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0ID0gYXdhaXQgdGhpcy5oYW5kc2hha2UocmVxLl9xdWVyeS50cmFuc3BvcnQsIHJlcSwgKGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KSA9PiB0aGlzLmFib3J0UmVxdWVzdChyZXMsIGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KSk7XG4gICAgICAgICAgICAgICAgaWYgKCF0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNhbGxpbmcgd3JpdGVTdGF0dXMoKSB0cmlnZ2VycyB0aGUgZmx1c2hpbmcgb2YgYW55IGhlYWRlciBhZGRlZCBpbiBhIG1pZGRsZXdhcmVcbiAgICAgICAgICAgIHJlcS5yZXMud3JpdGVTdGF0dXMoXCIxMDEgU3dpdGNoaW5nIFByb3RvY29sc1wiKTtcbiAgICAgICAgICAgIHJlcy51cGdyYWRlKHtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQsXG4gICAgICAgICAgICB9LCByZXEuZ2V0SGVhZGVyKFwic2VjLXdlYnNvY2tldC1rZXlcIiksIHJlcS5nZXRIZWFkZXIoXCJzZWMtd2Vic29ja2V0LXByb3RvY29sXCIpLCByZXEuZ2V0SGVhZGVyKFwic2VjLXdlYnNvY2tldC1leHRlbnNpb25zXCIpLCBjb250ZXh0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fYXBwbHlNaWRkbGV3YXJlcyhyZXEsIHJlcywgKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHNlcnZlcl8xLlNlcnZlci5lcnJvcnMuQkFEX1JFUVVFU1QsIHsgbmFtZTogXCJNSURETEVXQVJFX0ZBSUxVUkVcIiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudmVyaWZ5KHJlcSwgdHJ1ZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWJvcnRSZXF1ZXN0KHJlcywgZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzQ29kZSA9IGVycm9yQ29kZSA9PT0gc2VydmVyXzEuU2VydmVyLmVycm9ycy5GT1JCSURERU5cbiAgICAgICAgICAgID8gXCI0MDMgRm9yYmlkZGVuXCJcbiAgICAgICAgICAgIDogXCI0MDAgQmFkIFJlcXVlc3RcIjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGVycm9yQ29udGV4dCAmJiBlcnJvckNvbnRleHQubWVzc2FnZVxuICAgICAgICAgICAgPyBlcnJvckNvbnRleHQubWVzc2FnZVxuICAgICAgICAgICAgOiBzZXJ2ZXJfMS5TZXJ2ZXIuZXJyb3JNZXNzYWdlc1tlcnJvckNvZGVdO1xuICAgICAgICByZXMud3JpdGVTdGF0dXMoc3RhdHVzQ29kZSk7XG4gICAgICAgIHJlcy53cml0ZUhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICAgIHJlcy5lbmQoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgY29kZTogZXJyb3JDb2RlLFxuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgfSkpO1xuICAgIH1cbn1cbmV4cG9ydHMudVNlcnZlciA9IHVTZXJ2ZXI7XG5jbGFzcyBSZXNwb25zZVdyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKHJlcykge1xuICAgICAgICB0aGlzLnJlcyA9IHJlcztcbiAgICAgICAgdGhpcy5zdGF0dXNXcml0dGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IFtdO1xuICAgICAgICB0aGlzLmlzQWJvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBzZXQgc3RhdHVzQ29kZShzdGF0dXMpIHtcbiAgICAgICAgaWYgKCFzdGF0dXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGSVhNRTogaGFuZGxlIGFsbCBzdGF0dXMgY29kZXM/XG4gICAgICAgIHRoaXMud3JpdGVTdGF0dXMoc3RhdHVzID09PSAyMDAgPyBcIjIwMCBPS1wiIDogXCIyMDQgTm8gQ29udGVudFwiKTtcbiAgICB9XG4gICAgd3JpdGVIZWFkKHN0YXR1cykge1xuICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXM7XG4gICAgfVxuICAgIHNldEhlYWRlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaCgodmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUhlYWRlcihrZXksIHZhbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlSGVhZGVyKCkge1xuICAgICAgICAvLyBGSVhNRTogbm90IGltcGxlbWVudGVkXG4gICAgfVxuICAgIC8vIG5lZWRlZCBieSB2YXJ5OiBodHRwczovL2dpdGh1Yi5jb20vanNodHRwL3ZhcnkvYmxvYi81ZDcyNWQwNTliMzg3MTAyNWNmNzUzZTlkZmEwODkyNGQwYmNmYThmL2luZGV4LmpzI0wxMzRcbiAgICBnZXRIZWFkZXIoKSB7IH1cbiAgICB3cml0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBYm9ydGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnJlcy53cml0ZVN0YXR1cyhzdGF0dXMpO1xuICAgICAgICB0aGlzLnN0YXR1c1dyaXR0ZW4gPSB0cnVlO1xuICAgICAgICB0aGlzLndyaXRlQnVmZmVyZWRIZWFkZXJzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB3cml0ZUhlYWRlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQWJvcnRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJDb250ZW50LUxlbmd0aFwiKSB7XG4gICAgICAgICAgICAvLyB0aGUgY29udGVudCBsZW5ndGggaXMgYXV0b21hdGljYWxseSBhZGRlZCBieSB1V2ViU29ja2V0cy5qc1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXR1c1dyaXR0ZW4pIHtcbiAgICAgICAgICAgIHRoaXMucmVzLndyaXRlSGVhZGVyKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3cml0ZUJ1ZmZlcmVkSGVhZGVycygpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXMud3JpdGVIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbmQoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5pc0Fib3J0ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucmVzLmNvcmsoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXR1c1dyaXR0ZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBzdGF0dXMgd2lsbCBiZSBpbmZlcnJlZCBhcyBcIjIwMCBPS1wiXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcmVkSGVhZGVycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXMuZW5kKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgb25EYXRhKGZuKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQWJvcnRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5yZXMub25EYXRhKGZuKTtcbiAgICB9XG4gICAgb25BYm9ydGVkKGZuKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQWJvcnRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5yZXMub25BYm9ydGVkKCgpID0+IHtcbiAgICAgICAgICAgIC8vIEFueSBhdHRlbXB0IHRvIHVzZSB0aGUgVVdTIHJlc3BvbnNlIG9iamVjdCBhZnRlciBhYm9ydCB3aWxsIHRocm93IVxuICAgICAgICAgICAgdGhpcy5pc0Fib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvcmsoZm4pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBYm9ydGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnJlcy5jb3JrKGZuKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/engine.io/build/userver.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/engine.io/node_modules/debug/node_modules/ms/index.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/engine.io/node_modules/debug/node_modules/ms/index.js ***!
  \*****************************************************************************/
/***/ ((module) => {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9ub2RlX21vZHVsZXMvZGVidWcvbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2FsL3JlZGlzLXByb2plY3Qvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9ub2RlX21vZHVsZXMvZGVidWcvbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgdyA9IGQgKiA3O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWwpKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigtPyg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ3dlZWtzJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICBjYXNlICd3JzpcbiAgICAgIHJldHVybiBuICogdztcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcbiAgfVxuICByZXR1cm4gbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/engine.io/node_modules/debug/node_modules/ms/index.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/engine.io/node_modules/debug/src/browser.js":
/*!*******************************************************************!*\
  !*** ../node_modules/engine.io/node_modules/debug/src/browser.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"(rsc)/../node_modules/engine.io/node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQixZQUFZO0FBQ1osWUFBWTtBQUNaLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2YsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0Q0FBNEM7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQyxrRkFBVTs7QUFFbkMsT0FBTyxZQUFZOztBQUVuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhbC9yZWRpcy1wcm9qZWN0L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuZXhwb3J0cy5kZXN0cm95ID0gKCgpID0+IHtcblx0bGV0IHdhcm5lZCA9IGZhbHNlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCF3YXJuZWQpIHtcblx0XHRcdHdhcm5lZCA9IHRydWU7XG5cdFx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0XHR9XG5cdH07XG59KSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcblx0JyMwMDAwQ0MnLFxuXHQnIzAwMDBGRicsXG5cdCcjMDAzM0NDJyxcblx0JyMwMDMzRkYnLFxuXHQnIzAwNjZDQycsXG5cdCcjMDA2NkZGJyxcblx0JyMwMDk5Q0MnLFxuXHQnIzAwOTlGRicsXG5cdCcjMDBDQzAwJyxcblx0JyMwMENDMzMnLFxuXHQnIzAwQ0M2NicsXG5cdCcjMDBDQzk5Jyxcblx0JyMwMENDQ0MnLFxuXHQnIzAwQ0NGRicsXG5cdCcjMzMwMENDJyxcblx0JyMzMzAwRkYnLFxuXHQnIzMzMzNDQycsXG5cdCcjMzMzM0ZGJyxcblx0JyMzMzY2Q0MnLFxuXHQnIzMzNjZGRicsXG5cdCcjMzM5OUNDJyxcblx0JyMzMzk5RkYnLFxuXHQnIzMzQ0MwMCcsXG5cdCcjMzNDQzMzJyxcblx0JyMzM0NDNjYnLFxuXHQnIzMzQ0M5OScsXG5cdCcjMzNDQ0NDJyxcblx0JyMzM0NDRkYnLFxuXHQnIzY2MDBDQycsXG5cdCcjNjYwMEZGJyxcblx0JyM2NjMzQ0MnLFxuXHQnIzY2MzNGRicsXG5cdCcjNjZDQzAwJyxcblx0JyM2NkNDMzMnLFxuXHQnIzk5MDBDQycsXG5cdCcjOTkwMEZGJyxcblx0JyM5OTMzQ0MnLFxuXHQnIzk5MzNGRicsXG5cdCcjOTlDQzAwJyxcblx0JyM5OUNDMzMnLFxuXHQnI0NDMDAwMCcsXG5cdCcjQ0MwMDMzJyxcblx0JyNDQzAwNjYnLFxuXHQnI0NDMDA5OScsXG5cdCcjQ0MwMENDJyxcblx0JyNDQzAwRkYnLFxuXHQnI0NDMzMwMCcsXG5cdCcjQ0MzMzMzJyxcblx0JyNDQzMzNjYnLFxuXHQnI0NDMzM5OScsXG5cdCcjQ0MzM0NDJyxcblx0JyNDQzMzRkYnLFxuXHQnI0NDNjYwMCcsXG5cdCcjQ0M2NjMzJyxcblx0JyNDQzk5MDAnLFxuXHQnI0NDOTkzMycsXG5cdCcjQ0NDQzAwJyxcblx0JyNDQ0NDMzMnLFxuXHQnI0ZGMDAwMCcsXG5cdCcjRkYwMDMzJyxcblx0JyNGRjAwNjYnLFxuXHQnI0ZGMDA5OScsXG5cdCcjRkYwMENDJyxcblx0JyNGRjAwRkYnLFxuXHQnI0ZGMzMwMCcsXG5cdCcjRkYzMzMzJyxcblx0JyNGRjMzNjYnLFxuXHQnI0ZGMzM5OScsXG5cdCcjRkYzM0NDJyxcblx0JyNGRjMzRkYnLFxuXHQnI0ZGNjYwMCcsXG5cdCcjRkY2NjMzJyxcblx0JyNGRjk5MDAnLFxuXHQnI0ZGOTkzMycsXG5cdCcjRkZDQzAwJyxcblx0JyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcblx0Ly8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2Vcblx0Ly8gZXhwbGljaXRseVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXHRyZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcblx0XHQvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG5cdFx0KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcblx0XHQvLyBJcyBmaXJlZm94ID49IHYzMT9cblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcblx0XHQvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcblx0YXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgK1xuXHRcdHRoaXMubmFtZXNwYWNlICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgK1xuXHRcdGFyZ3NbMF0gK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArXG5cdFx0JysnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuXHRpZiAoIXRoaXMudXNlQ29sb3JzKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG5cdGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpO1xuXG5cdC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG5cdC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cblx0Ly8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cdGxldCBpbmRleCA9IDA7XG5cdGxldCBsYXN0QyA9IDA7XG5cdGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBtYXRjaCA9PiB7XG5cdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGluZGV4Kys7XG5cdFx0aWYgKG1hdGNoID09PSAnJWMnKSB7XG5cdFx0XHQvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcblx0XHRcdC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG5cdFx0XHRsYXN0QyA9IGluZGV4O1xuXHRcdH1cblx0fSk7XG5cblx0YXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUuZGVidWcoKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKiBJZiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGF2YWlsYWJsZSwgZmFsbHMgYmFja1xuICogdG8gYGNvbnNvbGUubG9nYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnRzLmxvZyA9IGNvbnNvbGUuZGVidWcgfHwgY29uc29sZS5sb2cgfHwgKCgpID0+IHt9KTtcblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuXHR0cnkge1xuXHRcdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkKCkge1xuXHRsZXQgcjtcblx0dHJ5IHtcblx0XHRyID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG5cblx0Ly8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXHRpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcblx0XHRyID0gcHJvY2Vzcy5lbnYuREVCVUc7XG5cdH1cblxuXHRyZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG5cdHRyeSB7XG5cdFx0Ly8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuXHRcdC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG5cdFx0cmV0dXJuIGxvY2FsU3RvcmFnZTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xuXG5jb25zdCB7Zm9ybWF0dGVyc30gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG5cdH1cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/engine.io/node_modules/debug/src/browser.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/engine.io/node_modules/debug/src/common.js":
/*!******************************************************************!*\
  !*** ../node_modules/engine.io/node_modules/debug/src/common.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = __webpack_require__(/*! ms */ \"(rsc)/../node_modules/engine.io/node_modules/debug/node_modules/ms/index.js\");\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcyIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQyx1RkFBSTtBQUNwQzs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhbC9yZWRpcy1wcm9qZWN0L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cblxuZnVuY3Rpb24gc2V0dXAoZW52KSB7XG5cdGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuXHRjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcblx0Y3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXHRjcmVhdGVEZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblxuXHRPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goa2V5ID0+IHtcblx0XHRjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG5cdH0pO1xuXG5cdC8qKlxuXHQqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuXHQqL1xuXG5cdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0LyoqXG5cdCogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuXHQqXG5cdCogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuXHQqL1xuXHRjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG5cblx0LyoqXG5cdCogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBkZWJ1ZyBpbnN0YW5jZSB0byBiZSBjb2xvcmVkXG5cdCogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuXHRcdGxldCBoYXNoID0gMDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcblx0XHRcdGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuXHR9XG5cdGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG5cblx0LyoqXG5cdCogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQHJldHVybiB7RnVuY3Rpb259XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cdFx0bGV0IHByZXZUaW1lO1xuXHRcdGxldCBlbmFibGVPdmVycmlkZSA9IG51bGw7XG5cdFx0bGV0IG5hbWVzcGFjZXNDYWNoZTtcblx0XHRsZXQgZW5hYmxlZENhY2hlO1xuXG5cdFx0ZnVuY3Rpb24gZGVidWcoLi4uYXJncykge1xuXHRcdFx0Ly8gRGlzYWJsZWQ/XG5cdFx0XHRpZiAoIWRlYnVnLmVuYWJsZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzZWxmID0gZGVidWc7XG5cblx0XHRcdC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cdFx0XHRjb25zdCBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuXHRcdFx0Y29uc3QgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuXHRcdFx0c2VsZi5kaWZmID0gbXM7XG5cdFx0XHRzZWxmLnByZXYgPSBwcmV2VGltZTtcblx0XHRcdHNlbGYuY3VyciA9IGN1cnI7XG5cdFx0XHRwcmV2VGltZSA9IGN1cnI7XG5cblx0XHRcdGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cblx0XHRcdGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Ly8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cblx0XHRcdFx0YXJncy51bnNoaWZ0KCclTycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXHRcdFx0bGV0IGluZGV4ID0gMDtcblx0XHRcdGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCAobWF0Y2gsIGZvcm1hdCkgPT4ge1xuXHRcdFx0XHQvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG5cdFx0XHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0XHRcdHJldHVybiAnJSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0Y29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXHRcdFx0XHRpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGNvbnN0IHZhbCA9IGFyZ3NbaW5kZXhdO1xuXHRcdFx0XHRcdG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuXHRcdFx0XHRcdC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblx0XHRcdFx0XHRhcmdzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblx0XHRcdGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuXHRcdFx0Y29uc3QgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG5cdFx0XHRsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcblx0XHR9XG5cblx0XHRkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cdFx0ZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG5cdFx0ZGVidWcuY29sb3IgPSBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXHRcdGRlYnVnLmV4dGVuZCA9IGV4dGVuZDtcblx0XHRkZWJ1Zy5kZXN0cm95ID0gY3JlYXRlRGVidWcuZGVzdHJveTsgLy8gWFhYIFRlbXBvcmFyeS4gV2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVidWcsICdlbmFibGVkJywge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0XHRnZXQ6ICgpID0+IHtcblx0XHRcdFx0aWYgKGVuYWJsZU92ZXJyaWRlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVuYWJsZU92ZXJyaWRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChuYW1lc3BhY2VzQ2FjaGUgIT09IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMpIHtcblx0XHRcdFx0XHRuYW1lc3BhY2VzQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzO1xuXHRcdFx0XHRcdGVuYWJsZWRDYWNoZSA9IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbmFibGVkQ2FjaGU7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiB2ID0+IHtcblx0XHRcdFx0ZW5hYmxlT3ZlcnJpZGUgPSB2O1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblx0XHRpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZWJ1Zztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4dGVuZChuYW1lc3BhY2UsIGRlbGltaXRlcikge1xuXHRcdGNvbnN0IG5ld0RlYnVnID0gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcblx0XHRuZXdEZWJ1Zy5sb2cgPSB0aGlzLmxvZztcblx0XHRyZXR1cm4gbmV3RGVidWc7XG5cdH1cblxuXHQvKipcblx0KiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG5cdCogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcblx0XHRjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuXHRcdGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMgPSBuYW1lc3BhY2VzO1xuXG5cdFx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0XHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdFx0bGV0IGk7XG5cdFx0Y29uc3Qgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuXHRcdGNvbnN0IGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKCFzcGxpdFtpXSkge1xuXHRcdFx0XHQvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0bmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cblx0XHRcdGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc2xpY2UoMSkgKyAnJCcpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG5cdCpcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBkaXNhYmxlKCkge1xuXHRcdGNvbnN0IG5hbWVzcGFjZXMgPSBbXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5uYW1lcy5tYXAodG9OYW1lc3BhY2UpLFxuXHRcdFx0Li4uY3JlYXRlRGVidWcuc2tpcHMubWFwKHRvTmFtZXNwYWNlKS5tYXAobmFtZXNwYWNlID0+ICctJyArIG5hbWVzcGFjZSlcblx0XHRdLmpvaW4oJywnKTtcblx0XHRjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuXHRcdHJldHVybiBuYW1lc3BhY2VzO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0KiBAcmV0dXJuIHtCb29sZWFufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuXHRcdGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0bGV0IGk7XG5cdFx0bGV0IGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQqIENvbnZlcnQgcmVnZXhwIHRvIG5hbWVzcGFjZVxuXHQqXG5cdCogQHBhcmFtIHtSZWdFeHB9IHJlZ3hlcFxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHRvTmFtZXNwYWNlKHJlZ2V4cCkge1xuXHRcdHJldHVybiByZWdleHAudG9TdHJpbmcoKVxuXHRcdFx0LnN1YnN0cmluZygyLCByZWdleHAudG9TdHJpbmcoKS5sZW5ndGggLSAyKVxuXHRcdFx0LnJlcGxhY2UoL1xcLlxcKlxcPyQvLCAnKicpO1xuXHR9XG5cblx0LyoqXG5cdCogQ29lcmNlIGB2YWxgLlxuXHQqXG5cdCogQHBhcmFtIHtNaXhlZH0gdmFsXG5cdCogQHJldHVybiB7TWl4ZWR9XG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcblx0XHRpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHQvKipcblx0KiBYWFggRE8gTk9UIFVTRS4gVGhpcyBpcyBhIHRlbXBvcmFyeSBzdHViIGZ1bmN0aW9uLlxuXHQqIFhYWCBJdCBXSUxMIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblx0Ki9cblx0ZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0fVxuXG5cdGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuXG5cdHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/engine.io/node_modules/debug/src/common.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/engine.io/node_modules/debug/src/index.js":
/*!*****************************************************************!*\
  !*** ../node_modules/engine.io/node_modules/debug/src/index.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process === 'undefined' || process.type === 'renderer' || false === true || process.__nwjs) {\n\tmodule.exports = __webpack_require__(/*! ./browser.js */ \"(rsc)/../node_modules/engine.io/node_modules/debug/src/browser.js\");\n} else {\n\tmodule.exports = __webpack_require__(/*! ./node.js */ \"(rsc)/../node_modules/engine.io/node_modules/debug/src/node.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFFQUFxRSxLQUFlO0FBQ3BGLENBQUMsNkhBQXdDO0FBQ3pDLEVBQUU7QUFDRixDQUFDLHVIQUFxQztBQUN0QyIsInNvdXJjZXMiOlsiL1VzZXJzL3NhbC9yZWRpcy1wcm9qZWN0L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIERldGVjdCBFbGVjdHJvbiByZW5kZXJlciAvIG53anMgcHJvY2Vzcywgd2hpY2ggaXMgbm9kZSwgYnV0IHdlIHNob3VsZFxuICogdHJlYXQgYXMgYSBicm93c2VyLlxuICovXG5cbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHByb2Nlc3MuYnJvd3NlciA9PT0gdHJ1ZSB8fCBwcm9jZXNzLl9fbndqcykge1xuXHRtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYnJvd3Nlci5qcycpO1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL25vZGUuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/engine.io/node_modules/debug/src/index.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/engine.io/node_modules/debug/src/node.js":
/*!****************************************************************!*\
  !*** ../node_modules/engine.io/node_modules/debug/src/node.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/**\n * Module dependencies.\n */\n\nconst tty = __webpack_require__(/*! tty */ \"tty\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * This is the Node.js implementation of `debug()`.\n */\n\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.destroy = util.deprecate(\n\t() => {},\n\t'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'\n);\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\ntry {\n\t// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n\t// eslint-disable-next-line import/no-extraneous-dependencies\n\tconst supportsColor = __webpack_require__(/*! supports-color */ \"(rsc)/../node_modules/supports-color/index.js\");\n\n\tif (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n\t\texports.colors = [\n\t\t\t20,\n\t\t\t21,\n\t\t\t26,\n\t\t\t27,\n\t\t\t32,\n\t\t\t33,\n\t\t\t38,\n\t\t\t39,\n\t\t\t40,\n\t\t\t41,\n\t\t\t42,\n\t\t\t43,\n\t\t\t44,\n\t\t\t45,\n\t\t\t56,\n\t\t\t57,\n\t\t\t62,\n\t\t\t63,\n\t\t\t68,\n\t\t\t69,\n\t\t\t74,\n\t\t\t75,\n\t\t\t76,\n\t\t\t77,\n\t\t\t78,\n\t\t\t79,\n\t\t\t80,\n\t\t\t81,\n\t\t\t92,\n\t\t\t93,\n\t\t\t98,\n\t\t\t99,\n\t\t\t112,\n\t\t\t113,\n\t\t\t128,\n\t\t\t129,\n\t\t\t134,\n\t\t\t135,\n\t\t\t148,\n\t\t\t149,\n\t\t\t160,\n\t\t\t161,\n\t\t\t162,\n\t\t\t163,\n\t\t\t164,\n\t\t\t165,\n\t\t\t166,\n\t\t\t167,\n\t\t\t168,\n\t\t\t169,\n\t\t\t170,\n\t\t\t171,\n\t\t\t172,\n\t\t\t173,\n\t\t\t178,\n\t\t\t179,\n\t\t\t184,\n\t\t\t185,\n\t\t\t196,\n\t\t\t197,\n\t\t\t198,\n\t\t\t199,\n\t\t\t200,\n\t\t\t201,\n\t\t\t202,\n\t\t\t203,\n\t\t\t204,\n\t\t\t205,\n\t\t\t206,\n\t\t\t207,\n\t\t\t208,\n\t\t\t209,\n\t\t\t214,\n\t\t\t215,\n\t\t\t220,\n\t\t\t221\n\t\t];\n\t}\n} catch (error) {\n\t// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(key => {\n\treturn /^debug_/i.test(key);\n}).reduce((obj, key) => {\n\t// Camel-case\n\tconst prop = key\n\t\t.substring(6)\n\t\t.toLowerCase()\n\t\t.replace(/_([a-z])/g, (_, k) => {\n\t\t\treturn k.toUpperCase();\n\t\t});\n\n\t// Coerce string value into JS value\n\tlet val = process.env[key];\n\tif (/^(yes|on|true|enabled)$/i.test(val)) {\n\t\tval = true;\n\t} else if (/^(no|off|false|disabled)$/i.test(val)) {\n\t\tval = false;\n\t} else if (val === 'null') {\n\t\tval = null;\n\t} else {\n\t\tval = Number(val);\n\t}\n\n\tobj[prop] = val;\n\treturn obj;\n}, {});\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n\treturn 'colors' in exports.inspectOpts ?\n\t\tBoolean(exports.inspectOpts.colors) :\n\t\ttty.isatty(process.stderr.fd);\n}\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\tconst {namespace: name, useColors} = this;\n\n\tif (useColors) {\n\t\tconst c = this.color;\n\t\tconst colorCode = '\\u001B[3' + (c < 8 ? c : '8;5;' + c);\n\t\tconst prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n\n\t\targs[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n\t\targs.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\\u001B[0m');\n\t} else {\n\t\targs[0] = getDate() + name + ' ' + args[0];\n\t}\n}\n\nfunction getDate() {\n\tif (exports.inspectOpts.hideDate) {\n\t\treturn '';\n\t}\n\treturn new Date().toISOString() + ' ';\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to stderr.\n */\n\nfunction log(...args) {\n\treturn process.stderr.write(util.format(...args) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\tif (namespaces) {\n\t\tprocess.env.DEBUG = namespaces;\n\t} else {\n\t\t// If you set a process.env field to null or undefined, it gets cast to the\n\t\t// string 'null' or 'undefined'. Just delete instead.\n\t\tdelete process.env.DEBUG;\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n\treturn process.env.DEBUG;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init(debug) {\n\tdebug.inspectOpts = {};\n\n\tconst keys = Object.keys(exports.inspectOpts);\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tdebug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"(rsc)/../node_modules/engine.io/node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nformatters.o = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts)\n\t\t.split('\\n')\n\t\t.map(str => str.trim())\n\t\t.join(' ');\n};\n\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */\n\nformatters.O = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9ub2RlX21vZHVsZXMvZGVidWcvc3JjL25vZGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxnQkFBSztBQUN6QixhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1osV0FBVztBQUNYLGtCQUFrQjtBQUNsQixZQUFZO0FBQ1osWUFBWTtBQUNaLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2YsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMscUVBQWdCOztBQUUvQztBQUNBLEVBQUUsY0FBYztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsNkRBQTZEO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyxJQUFJOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLDRCQUE0Qjs7QUFFcEM7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25ELHNCQUFzQixXQUFXLElBQUksTUFBTTs7QUFFM0M7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQyxrRkFBVTs7QUFFbkMsT0FBTyxZQUFZOztBQUVuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2FsL3JlZGlzLXByb2plY3Qvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9ub2RlX21vZHVsZXMvZGVidWcvc3JjL25vZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IHR0eSA9IHJlcXVpcmUoJ3R0eScpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBOb2RlLmpzIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmluaXQgPSBpbml0O1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuZGVzdHJveSA9IHV0aWwuZGVwcmVjYXRlKFxuXHQoKSA9PiB7fSxcblx0J0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nXG4pO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFs2LCAyLCAzLCA0LCA1LCAxXTtcblxudHJ5IHtcblx0Ly8gT3B0aW9uYWwgZGVwZW5kZW5jeSAoYXMgaW4sIGRvZXNuJ3QgbmVlZCB0byBiZSBpbnN0YWxsZWQsIE5PVCBsaWtlIG9wdGlvbmFsRGVwZW5kZW5jaWVzIGluIHBhY2thZ2UuanNvbilcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llc1xuXHRjb25zdCBzdXBwb3J0c0NvbG9yID0gcmVxdWlyZSgnc3VwcG9ydHMtY29sb3InKTtcblxuXHRpZiAoc3VwcG9ydHNDb2xvciAmJiAoc3VwcG9ydHNDb2xvci5zdGRlcnIgfHwgc3VwcG9ydHNDb2xvcikubGV2ZWwgPj0gMikge1xuXHRcdGV4cG9ydHMuY29sb3JzID0gW1xuXHRcdFx0MjAsXG5cdFx0XHQyMSxcblx0XHRcdDI2LFxuXHRcdFx0MjcsXG5cdFx0XHQzMixcblx0XHRcdDMzLFxuXHRcdFx0MzgsXG5cdFx0XHQzOSxcblx0XHRcdDQwLFxuXHRcdFx0NDEsXG5cdFx0XHQ0Mixcblx0XHRcdDQzLFxuXHRcdFx0NDQsXG5cdFx0XHQ0NSxcblx0XHRcdDU2LFxuXHRcdFx0NTcsXG5cdFx0XHQ2Mixcblx0XHRcdDYzLFxuXHRcdFx0NjgsXG5cdFx0XHQ2OSxcblx0XHRcdDc0LFxuXHRcdFx0NzUsXG5cdFx0XHQ3Nixcblx0XHRcdDc3LFxuXHRcdFx0NzgsXG5cdFx0XHQ3OSxcblx0XHRcdDgwLFxuXHRcdFx0ODEsXG5cdFx0XHQ5Mixcblx0XHRcdDkzLFxuXHRcdFx0OTgsXG5cdFx0XHQ5OSxcblx0XHRcdDExMixcblx0XHRcdDExMyxcblx0XHRcdDEyOCxcblx0XHRcdDEyOSxcblx0XHRcdDEzNCxcblx0XHRcdDEzNSxcblx0XHRcdDE0OCxcblx0XHRcdDE0OSxcblx0XHRcdDE2MCxcblx0XHRcdDE2MSxcblx0XHRcdDE2Mixcblx0XHRcdDE2Myxcblx0XHRcdDE2NCxcblx0XHRcdDE2NSxcblx0XHRcdDE2Nixcblx0XHRcdDE2Nyxcblx0XHRcdDE2OCxcblx0XHRcdDE2OSxcblx0XHRcdDE3MCxcblx0XHRcdDE3MSxcblx0XHRcdDE3Mixcblx0XHRcdDE3Myxcblx0XHRcdDE3OCxcblx0XHRcdDE3OSxcblx0XHRcdDE4NCxcblx0XHRcdDE4NSxcblx0XHRcdDE5Nixcblx0XHRcdDE5Nyxcblx0XHRcdDE5OCxcblx0XHRcdDE5OSxcblx0XHRcdDIwMCxcblx0XHRcdDIwMSxcblx0XHRcdDIwMixcblx0XHRcdDIwMyxcblx0XHRcdDIwNCxcblx0XHRcdDIwNSxcblx0XHRcdDIwNixcblx0XHRcdDIwNyxcblx0XHRcdDIwOCxcblx0XHRcdDIwOSxcblx0XHRcdDIxNCxcblx0XHRcdDIxNSxcblx0XHRcdDIyMCxcblx0XHRcdDIyMVxuXHRcdF07XG5cdH1cbn0gY2F0Y2ggKGVycm9yKSB7XG5cdC8vIFN3YWxsb3cgLSB3ZSBvbmx5IGNhcmUgaWYgYHN1cHBvcnRzLWNvbG9yYCBpcyBhdmFpbGFibGU7IGl0IGRvZXNuJ3QgaGF2ZSB0byBiZS5cbn1cblxuLyoqXG4gKiBCdWlsZCB1cCB0aGUgZGVmYXVsdCBgaW5zcGVjdE9wdHNgIG9iamVjdCBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKlxuICogICAkIERFQlVHX0NPTE9SUz1ubyBERUJVR19ERVBUSD0xMCBERUJVR19TSE9XX0hJRERFTj1lbmFibGVkIG5vZGUgc2NyaXB0LmpzXG4gKi9cblxuZXhwb3J0cy5pbnNwZWN0T3B0cyA9IE9iamVjdC5rZXlzKHByb2Nlc3MuZW52KS5maWx0ZXIoa2V5ID0+IHtcblx0cmV0dXJuIC9eZGVidWdfL2kudGVzdChrZXkpO1xufSkucmVkdWNlKChvYmosIGtleSkgPT4ge1xuXHQvLyBDYW1lbC1jYXNlXG5cdGNvbnN0IHByb3AgPSBrZXlcblx0XHQuc3Vic3RyaW5nKDYpXG5cdFx0LnRvTG93ZXJDYXNlKClcblx0XHQucmVwbGFjZSgvXyhbYS16XSkvZywgKF8sIGspID0+IHtcblx0XHRcdHJldHVybiBrLnRvVXBwZXJDYXNlKCk7XG5cdFx0fSk7XG5cblx0Ly8gQ29lcmNlIHN0cmluZyB2YWx1ZSBpbnRvIEpTIHZhbHVlXG5cdGxldCB2YWwgPSBwcm9jZXNzLmVudltrZXldO1xuXHRpZiAoL14oeWVzfG9ufHRydWV8ZW5hYmxlZCkkL2kudGVzdCh2YWwpKSB7XG5cdFx0dmFsID0gdHJ1ZTtcblx0fSBlbHNlIGlmICgvXihub3xvZmZ8ZmFsc2V8ZGlzYWJsZWQpJC9pLnRlc3QodmFsKSkge1xuXHRcdHZhbCA9IGZhbHNlO1xuXHR9IGVsc2UgaWYgKHZhbCA9PT0gJ251bGwnKSB7XG5cdFx0dmFsID0gbnVsbDtcblx0fSBlbHNlIHtcblx0XHR2YWwgPSBOdW1iZXIodmFsKTtcblx0fVxuXG5cdG9ialtwcm9wXSA9IHZhbDtcblx0cmV0dXJuIG9iajtcbn0sIHt9KTtcblxuLyoqXG4gKiBJcyBzdGRvdXQgYSBUVFk/IENvbG9yZWQgb3V0cHV0IGlzIGVuYWJsZWQgd2hlbiBgdHJ1ZWAuXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHRyZXR1cm4gJ2NvbG9ycycgaW4gZXhwb3J0cy5pbnNwZWN0T3B0cyA/XG5cdFx0Qm9vbGVhbihleHBvcnRzLmluc3BlY3RPcHRzLmNvbG9ycykgOlxuXHRcdHR0eS5pc2F0dHkocHJvY2Vzcy5zdGRlcnIuZmQpO1xufVxuXG4vKipcbiAqIEFkZHMgQU5TSSBjb2xvciBlc2NhcGUgY29kZXMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRjb25zdCB7bmFtZXNwYWNlOiBuYW1lLCB1c2VDb2xvcnN9ID0gdGhpcztcblxuXHRpZiAodXNlQ29sb3JzKSB7XG5cdFx0Y29uc3QgYyA9IHRoaXMuY29sb3I7XG5cdFx0Y29uc3QgY29sb3JDb2RlID0gJ1xcdTAwMUJbMycgKyAoYyA8IDggPyBjIDogJzg7NTsnICsgYyk7XG5cdFx0Y29uc3QgcHJlZml4ID0gYCAgJHtjb2xvckNvZGV9OzFtJHtuYW1lfSBcXHUwMDFCWzBtYDtcblxuXHRcdGFyZ3NbMF0gPSBwcmVmaXggKyBhcmdzWzBdLnNwbGl0KCdcXG4nKS5qb2luKCdcXG4nICsgcHJlZml4KTtcblx0XHRhcmdzLnB1c2goY29sb3JDb2RlICsgJ20rJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZikgKyAnXFx1MDAxQlswbScpO1xuXHR9IGVsc2Uge1xuXHRcdGFyZ3NbMF0gPSBnZXREYXRlKCkgKyBuYW1lICsgJyAnICsgYXJnc1swXTtcblx0fVxufVxuXG5mdW5jdGlvbiBnZXREYXRlKCkge1xuXHRpZiAoZXhwb3J0cy5pbnNwZWN0T3B0cy5oaWRlRGF0ZSkge1xuXHRcdHJldHVybiAnJztcblx0fVxuXHRyZXR1cm4gbmV3IERhdGUoKS50b0lTT1N0cmluZygpICsgJyAnO1xufVxuXG4vKipcbiAqIEludm9rZXMgYHV0aWwuZm9ybWF0KClgIHdpdGggdGhlIHNwZWNpZmllZCBhcmd1bWVudHMgYW5kIHdyaXRlcyB0byBzdGRlcnIuXG4gKi9cblxuZnVuY3Rpb24gbG9nKC4uLmFyZ3MpIHtcblx0cmV0dXJuIHByb2Nlc3Muc3RkZXJyLndyaXRlKHV0aWwuZm9ybWF0KC4uLmFyZ3MpICsgJ1xcbicpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0cHJvY2Vzcy5lbnYuREVCVUcgPSBuYW1lc3BhY2VzO1xuXHR9IGVsc2Uge1xuXHRcdC8vIElmIHlvdSBzZXQgYSBwcm9jZXNzLmVudiBmaWVsZCB0byBudWxsIG9yIHVuZGVmaW5lZCwgaXQgZ2V0cyBjYXN0IHRvIHRoZVxuXHRcdC8vIHN0cmluZyAnbnVsbCcgb3IgJ3VuZGVmaW5lZCcuIEp1c3QgZGVsZXRlIGluc3RlYWQuXG5cdFx0ZGVsZXRlIHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcblx0cmV0dXJuIHByb2Nlc3MuZW52LkRFQlVHO1xufVxuXG4vKipcbiAqIEluaXQgbG9naWMgZm9yIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICpcbiAqIENyZWF0ZSBhIG5ldyBgaW5zcGVjdE9wdHNgIG9iamVjdCBpbiBjYXNlIGB1c2VDb2xvcnNgIGlzIHNldFxuICogZGlmZmVyZW50bHkgZm9yIGEgcGFydGljdWxhciBgZGVidWdgIGluc3RhbmNlLlxuICovXG5cbmZ1bmN0aW9uIGluaXQoZGVidWcpIHtcblx0ZGVidWcuaW5zcGVjdE9wdHMgPSB7fTtcblxuXHRjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZXhwb3J0cy5pbnNwZWN0T3B0cyk7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdGRlYnVnLmluc3BlY3RPcHRzW2tleXNbaV1dID0gZXhwb3J0cy5pbnNwZWN0T3B0c1trZXlzW2ldXTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlbyB0byBgdXRpbC5pbnNwZWN0KClgLCBhbGwgb24gYSBzaW5nbGUgbGluZS5cbiAqL1xuXG5mb3JtYXR0ZXJzLm8gPSBmdW5jdGlvbiAodikge1xuXHR0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXHRyZXR1cm4gdXRpbC5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpXG5cdFx0LnNwbGl0KCdcXG4nKVxuXHRcdC5tYXAoc3RyID0+IHN0ci50cmltKCkpXG5cdFx0LmpvaW4oJyAnKTtcbn07XG5cbi8qKlxuICogTWFwICVPIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbG93aW5nIG11bHRpcGxlIGxpbmVzIGlmIG5lZWRlZC5cbiAqL1xuXG5mb3JtYXR0ZXJzLk8gPSBmdW5jdGlvbiAodikge1xuXHR0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXHRyZXR1cm4gdXRpbC5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/engine.io/node_modules/debug/src/node.js\n");

/***/ })

};
;